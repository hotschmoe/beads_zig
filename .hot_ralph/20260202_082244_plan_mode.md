{"type":"system","subtype":"init","cwd":"/home/hotschmoe/beads_zig","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","bd-to-br-migration","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.29","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","code-simplifier:code-simplifier","build-verifier","coder-sonnet"],"skills":["keybindings-help","bd-to-br-migration"],"plugins":[{"name":"code-simplifier","path":"/home/hotschmoe/.claude/plugins/cache/claude-plugins-official/code-simplifier/1.0.0"}],"uuid":"a6dbba87-546c-4f54-a134-c43cc16f6dbe"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RsXLnUxW8x5pEoqaNQtcrS","type":"message","role":"assistant","content":[{"type":"text","text":"I'll implement these two filter features for the beads_zig CLI. Let me start by exploring the current codebase to understand how filtering is implemented."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":20933,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":20933},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"13945df0-ea8b-4ad3-8236-63e79f11fdce"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RsXLnUxW8x5pEoqaNQtcrS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","name":"Task","input":{"subagent_type":"Explore","prompt":"Find how list and ready commands handle filtering in beads_zig. I need to understand:\n1. Where list and ready commands are implemented (likely in src/cli/)\n2. How existing filters like --status, --priority work\n3. How the argument parser handles filter flags\n4. How due_at and defer_until fields are used currently\n\nFocus on src/cli/list.zig, src/cli/ready.zig, src/cli/args.zig, and any related filtering logic.","description":"Explore list/ready filtering"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":20933,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":20933},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"ae6682fe-af42-419d-acb1-63b3ba835389"}
{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Find how list and ready commands handle filtering in beads_zig. I need to understand:\n1. Where list and ready commands are implemented (likely in src/cli/)\n2. How existing filters like --status, --priority work\n3. How the argument parser handles filter flags\n4. How due_at and defer_until fields are used currently\n\nFocus on src/cli/list.zig, src/cli/ready.zig, src/cli/args.zig, and any related filtering logic."}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"ba31451f-7a16-44c0-947f-34bc96298909"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01NkfaLtXWeXFx9yk5A1YqfZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ecu1RdpeRgHg9gLHkrsP2t","name":"Glob","input":{"pattern":"src/cli/{list,ready,args}.zig","path":"/home/hotschmoe/beads_zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3924,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3924},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"926c81c0-55b4-487c-befc-f616e6a1c2fa"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01NkfaLtXWeXFx9yk5A1YqfZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Bgz4EpVcfW6AaaH3jaXHMQ","name":"Glob","input":{"pattern":"src/cli/*.zig","path":"/home/hotschmoe/beads_zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3924,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3924},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"372387b9-2943-4992-ac4e-33acd94dae8b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ecu1RdpeRgHg9gLHkrsP2t","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/args.zig\n/home/hotschmoe/beads_zig/src/cli/list.zig\n/home/hotschmoe/beads_zig/src/cli/ready.zig"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"8ec3d8d0-775b-46d4-b0d5-a49b6035f606"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Bgz4EpVcfW6AaaH3jaXHMQ","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/label.zig\n/home/hotschmoe/beads_zig/src/cli/help.zig\n/home/hotschmoe/beads_zig/src/cli/delete.zig\n/home/hotschmoe/beads_zig/src/cli/audit.zig\n/home/hotschmoe/beads_zig/src/cli/common.zig\n/home/hotschmoe/beads_zig/src/cli/comments.zig\n/home/hotschmoe/beads_zig/src/cli/batch.zig\n/home/hotschmoe/beads_zig/src/cli/metrics.zig\n/home/hotschmoe/beads_zig/src/cli/doctor.zig\n/home/hotschmoe/beads_zig/src/cli/epic.zig\n/home/hotschmoe/beads_zig/src/cli/config.zig\n/home/hotschmoe/beads_zig/src/cli/lint.zig\n/home/hotschmoe/beads_zig/src/cli/dep.zig\n/home/hotschmoe/beads_zig/src/cli/changelog.zig\n/home/hotschmoe/beads_zig/src/cli/history.zig\n/home/hotschmoe/beads_zig/src/cli/init.zig\n/home/hotschmoe/beads_zig/src/cli/defer.zig\n/home/hotschmoe/beads_zig/src/cli/completions.zig\n/home/hotschmoe/beads_zig/src/cli/info.zig\n/home/hotschmoe/beads_zig/src/cli/graph.zig\n/home/hotschmoe/beads_zig/src/cli/version.zig\n/home/hotschmoe/beads_zig/src/cli/schema.zig\n/home/hotschmoe/beads_zig/src/cli/stats.zig\n/home/hotschmoe/beads_zig/src/cli/sync.zig\n/home/hotschmoe/beads_zig/src/cli/show.zig\n/home/hotschmoe/beads_zig/src/cli/orphans.zig\n/home/hotschmoe/beads_zig/src/cli/search.zig\n/home/hotschmoe/beads_zig/src/cli/stale.zig\n/home/hotschmoe/beads_zig/src/cli/upgrade.zig\n/home/hotschmoe/beads_zig/src/cli/mod.zig\n/home/hotschmoe/beads_zig/src/cli/where.zig\n/home/hotschmoe/beads_zig/src/cli/query.zig\n/home/hotschmoe/beads_zig/src/cli/update.zig\n/home/hotschmoe/beads_zig/src/cli/create.zig\n/home/hotschmoe/beads_zig/src/cli/close.zig\n/home/hotschmoe/beads_zig/src/cli/count.zig\n/home/hotschmoe/beads_zig/src/cli/args.zig\n/home/hotschmoe/beads_zig/src/cli/list.zig\n/home/hotschmoe/beads_zig/src/cli/ready.zig"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"b02397ba-56e6-4d8e-83ca-f4bb028bb625"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KYbbFqLJpvuHeL7c585p98","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NiqdMo4yDNGs2J6vyAfz2o","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/list.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1247,"cache_read_input_tokens":13140,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1247},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"508ed6d6-6675-4bee-9155-1597c6493fd6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NiqdMo4yDNGs2J6vyAfz2o","type":"tool_result","content":"     1→//! List command for beads_zig.\n     2→//!\n     3→//! `bz list [--status X] [--priority X] [--type X] [--assignee X] [--label X] [-n LIMIT] [--all]`\n     4→//!\n     5→//! Lists issues with optional filters.\n     6→\n     7→const std = @import(\"std\");\n     8→const models = @import(\"../models/mod.zig\");\n     9→const common = @import(\"common.zig\");\n    10→const args = @import(\"args.zig\");\n    11→const test_util = @import(\"../test_util.zig\");\n    12→\n    13→const Issue = models.Issue;\n    14→const Status = models.Status;\n    15→const Priority = models.Priority;\n    16→const IssueType = models.IssueType;\n    17→const IssueStore = common.IssueStore;\n    18→const CommandContext = common.CommandContext;\n    19→\n    20→pub const ListError = error{\n    21→    WorkspaceNotInitialized,\n    22→    InvalidFilter,\n    23→    StorageError,\n    24→    OutOfMemory,\n    25→};\n    26→\n    27→pub const ListResult = struct {\n    28→    success: bool,\n    29→    issues: ?[]const IssueCompact = null,\n    30→    count: ?usize = null,\n    31→    message: ?[]const u8 = null,\n    32→\n    33→    const IssueCompact = struct {\n    34→        id: []const u8,\n    35→        title: []const u8,\n    36→        status: []const u8,\n    37→        priority: u3,\n    38→        issue_type: []const u8,\n    39→        assignee: ?[]const u8 = null,\n    40→    };\n    41→};\n    42→\n    43→pub fn run(\n    44→    list_args: args.ListArgs,\n    45→    global: args.GlobalOptions,\n    46→    allocator: std.mem.Allocator,\n    47→) !void {\n    48→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    49→        return ListError.WorkspaceNotInitialized;\n    50→    };\n    51→    defer ctx.deinit();\n    52→\n    53→    var filters = IssueStore.ListFilters{};\n    54→\n    55→    if (list_args.status) |s| {\n    56→        filters.status = Status.fromString(s);\n    57→    } else if (!list_args.all) {\n    58→        filters.status = .open;\n    59→    }\n    60→\n    61→    if (list_args.priority) |p| {\n    62→        filters.priority = Priority.fromString(p) catch {\n    63→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority value\");\n    64→            return ListError.InvalidFilter;\n    65→        };\n    66→    }\n    67→\n    68→    if (list_args.priority_min) |p| {\n    69→        filters.priority_min = Priority.fromString(p) catch {\n    70→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-min value\");\n    71→            return ListError.InvalidFilter;\n    72→        };\n    73→    }\n    74→\n    75→    if (list_args.priority_max) |p| {\n    76→        filters.priority_max = Priority.fromString(p) catch {\n    77→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-max value\");\n    78→            return ListError.InvalidFilter;\n    79→        };\n    80→    }\n    81→\n    82→    if (list_args.issue_type) |t| {\n    83→        filters.issue_type = IssueType.fromString(t);\n    84→    }\n    85→\n    86→    if (list_args.assignee) |a| {\n    87→        filters.assignee = a;\n    88→    }\n    89→\n    90→    if (list_args.label) |l| {\n    91→        filters.label = l;\n    92→    }\n    93→\n    94→    if (list_args.label_any.len > 0) {\n    95→        filters.label_any = list_args.label_any;\n    96→    }\n    97→\n    98→    if (list_args.title_contains) |t| {\n    99→        filters.title_contains = t;\n   100→    }\n   101→\n   102→    if (list_args.desc_contains) |d| {\n   103→        filters.desc_contains = d;\n   104→    }\n   105→\n   106→    if (list_args.notes_contains) |n| {\n   107→        filters.notes_contains = n;\n   108→    }\n   109→\n   110→    if (list_args.limit) |n| {\n   111→        filters.limit = n;\n   112→    }\n   113→\n   114→    // Apply sort options\n   115→    filters.order_by = switch (list_args.sort) {\n   116→        .created_at => .created_at,\n   117→        .updated_at => .updated_at,\n   118→        .priority => .priority,\n   119→    };\n   120→    filters.order_desc = list_args.sort_desc;\n   121→\n   122→    const issues = try ctx.store.list(filters);\n   123→    defer {\n   124→        for (issues) |*issue| {\n   125→            var i = issue.*;\n   126→            i.deinit(allocator);\n   127→        }\n   128→        allocator.free(issues);\n   129→    }\n   130→\n   131→    if (global.isStructuredOutput()) {\n   132→        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n   133→        defer allocator.free(compact_issues);\n   134→\n   135→        for (issues, 0..) |issue, i| {\n   136→            compact_issues[i] = .{\n   137→                .id = issue.id,\n   138→                .title = issue.title,\n   139→                .status = issue.status.toString(),\n   140→                .priority = issue.priority.value,\n   141→                .issue_type = issue.issue_type.toString(),\n   142→                .assignee = issue.assignee,\n   143→            };\n   144→        }\n   145→\n   146→        try ctx.output.printJson(ListResult{\n   147→            .success = true,\n   148→            .issues = compact_issues,\n   149→            .count = issues.len,\n   150→        });\n   151→    } else {\n   152→        try ctx.output.printIssueList(issues);\n   153→        if (!global.quiet and issues.len == 0) {\n   154→            try ctx.output.info(\"No issues found\", .{});\n   155→        }\n   156→    }\n   157→}\n   158→\n   159→fn outputError(output: *common.Output, structured_mode: bool, message: []const u8) !void {\n   160→    if (structured_mode) {\n   161→        try output.printJson(ListResult{\n   162→            .success = false,\n   163→            .message = message,\n   164→        });\n   165→    } else {\n   166→        try output.err(\"{s}\", .{message});\n   167→    }\n   168→}\n   169→\n   170→// --- Tests ---\n   171→\n   172→test \"ListError enum exists\" {\n   173→    const err: ListError = ListError.WorkspaceNotInitialized;\n   174→    try std.testing.expect(err == ListError.WorkspaceNotInitialized);\n   175→}\n   176→\n   177→test \"ListResult struct works\" {\n   178→    const result = ListResult{\n   179→        .success = true,\n   180→        .count = 5,\n   181→    };\n   182→    try std.testing.expect(result.success);\n   183→    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n   184→}\n   185→\n   186→test \"run detects uninitialized workspace\" {\n   187→    const allocator = std.testing.allocator;\n   188→\n   189→    const list_args = args.ListArgs{};\n   190→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   191→\n   192→    const result = run(list_args, global, allocator);\n   193→    try std.testing.expectError(ListError.WorkspaceNotInitialized, result);\n   194→}\n   195→\n   196→test \"run lists issues successfully\" {\n   197→    const allocator = std.testing.allocator;\n   198→\n   199→    const tmp_dir_path = try test_util.createTestDir(allocator, \"list_success\");\n   200→    defer allocator.free(tmp_dir_path);\n   201→    defer test_util.cleanupTestDir(tmp_dir_path);\n   202→\n   203→    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   204→    defer allocator.free(data_path);\n   205→\n   206→    try std.fs.cwd().makeDir(data_path);\n   207→\n   208→    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   209→    defer allocator.free(issues_path);\n   210→\n   211→    const f = try std.fs.cwd().createFile(issues_path, .{});\n   212→    defer f.close();\n   213→\n   214→    const list_args = args.ListArgs{ .all = true };\n   215→    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   216→\n   217→    try run(list_args, global, allocator);\n   218→}\n   219→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"b6de7353-7648-409d-8ccf-5eb0d52e510f"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KYbbFqLJpvuHeL7c585p98","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HdBeUEnEZhFDdwwGxRa14E","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/ready.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1247,"cache_read_input_tokens":13140,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1247},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"9a36ab78-9db3-43ba-86ea-aafb9fa2d043"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HdBeUEnEZhFDdwwGxRa14E","type":"tool_result","content":"     1→//! Ready and blocked commands for beads_zig.\n     2→//!\n     3→//! `bz ready [-n LIMIT]` - Show issues ready to work on (no blockers)\n     4→//! `bz blocked [-n LIMIT]` - Show blocked issues\n     5→//!\n     6→//! Workflow queries for finding actionable work.\n     7→\n     8→const std = @import(\"std\");\n     9→const models = @import(\"../models/mod.zig\");\n    10→const store = @import(\"../storage/store.zig\");\n    11→const common = @import(\"common.zig\");\n    12→const args = @import(\"args.zig\");\n    13→const test_util = @import(\"../test_util.zig\");\n    14→\n    15→const Issue = models.Issue;\n    16→const Priority = models.Priority;\n    17→const CommandContext = common.CommandContext;\n    18→const DependencyGraph = common.DependencyGraph;\n    19→const containsIgnoreCase = store.containsIgnoreCase;\n    20→\n    21→pub const ReadyError = error{\n    22→    WorkspaceNotInitialized,\n    23→    StorageError,\n    24→    OutOfMemory,\n    25→    InvalidFilter,\n    26→};\n    27→\n    28→pub const ReadyResult = struct {\n    29→    success: bool,\n    30→    issues: ?[]const IssueCompact = null,\n    31→    count: ?usize = null,\n    32→    message: ?[]const u8 = null,\n    33→\n    34→    const IssueCompact = struct {\n    35→        id: []const u8,\n    36→        title: []const u8,\n    37→        priority: u3,\n    38→    };\n    39→};\n    40→\n    41→pub const BlockedResult = struct {\n    42→    success: bool,\n    43→    issues: ?[]const BlockedIssue = null,\n    44→    count: ?usize = null,\n    45→    message: ?[]const u8 = null,\n    46→\n    47→    const BlockedIssue = struct {\n    48→        id: []const u8,\n    49→        title: []const u8,\n    50→        priority: u3,\n    51→        blocked_by: []const []const u8,\n    52→    };\n    53→};\n    54→\n    55→pub fn run(\n    56→    ready_args: args.ReadyArgs,\n    57→    global: args.GlobalOptions,\n    58→    allocator: std.mem.Allocator,\n    59→) !void {\n    60→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    61→        return ReadyError.WorkspaceNotInitialized;\n    62→    };\n    63→    defer ctx.deinit();\n    64→\n    65→    // Parse priority filters\n    66→    var priority_min: ?Priority = null;\n    67→    var priority_max: ?Priority = null;\n    68→    if (ready_args.priority_min) |p| {\n    69→        priority_min = Priority.fromString(p) catch {\n    70→            try ctx.output.err(\"invalid priority-min value\", .{});\n    71→            return ReadyError.InvalidFilter;\n    72→        };\n    73→    }\n    74→    if (ready_args.priority_max) |p| {\n    75→        priority_max = Priority.fromString(p) catch {\n    76→            try ctx.output.err(\"invalid priority-max value\", .{});\n    77→            return ReadyError.InvalidFilter;\n    78→        };\n    79→    }\n    80→\n    81→    var graph = ctx.createGraph();\n    82→    const issues = try graph.getReadyIssues();\n    83→    defer graph.freeIssues(issues);\n    84→\n    85→    // Apply filters\n    86→    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains);\n    87→    defer allocator.free(filtered);\n    88→\n    89→    const display_issues = applyLimit(filtered, ready_args.limit);\n    90→\n    91→    if (global.isStructuredOutput()) {\n    92→        var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);\n    93→        defer allocator.free(compact_issues);\n    94→\n    95→        for (display_issues, 0..) |issue, i| {\n    96→            compact_issues[i] = .{\n    97→                .id = issue.id,\n    98→                .title = issue.title,\n    99→                .priority = issue.priority.value,\n   100→            };\n   101→        }\n   102→\n   103→        try ctx.output.printJson(ReadyResult{\n   104→            .success = true,\n   105→            .issues = compact_issues,\n   106→            .count = display_issues.len,\n   107→        });\n   108→    } else {\n   109→        try ctx.output.printIssueList(display_issues);\n   110→        if (!global.quiet and display_issues.len == 0) {\n   111→            try ctx.output.info(\"No ready issues\", .{});\n   112→        }\n   113→    }\n   114→}\n   115→\n   116→pub fn runBlocked(\n   117→    blocked_args: args.BlockedArgs,\n   118→    global: args.GlobalOptions,\n   119→    allocator: std.mem.Allocator,\n   120→) !void {\n   121→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   122→        return ReadyError.WorkspaceNotInitialized;\n   123→    };\n   124→    defer ctx.deinit();\n   125→\n   126→    // Parse priority filters\n   127→    var priority_min: ?Priority = null;\n   128→    var priority_max: ?Priority = null;\n   129→    if (blocked_args.priority_min) |p| {\n   130→        priority_min = Priority.fromString(p) catch {\n   131→            try ctx.output.err(\"invalid priority-min value\", .{});\n   132→            return ReadyError.InvalidFilter;\n   133→        };\n   134→    }\n   135→    if (blocked_args.priority_max) |p| {\n   136→        priority_max = Priority.fromString(p) catch {\n   137→            try ctx.output.err(\"invalid priority-max value\", .{});\n   138→            return ReadyError.InvalidFilter;\n   139→        };\n   140→    }\n   141→\n   142→    var graph = ctx.createGraph();\n   143→    const issues = try graph.getBlockedIssues();\n   144→    defer graph.freeIssues(issues);\n   145→\n   146→    // Apply filters\n   147→    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains);\n   148→    defer allocator.free(filtered);\n   149→\n   150→    const display_issues = applyLimit(filtered, blocked_args.limit);\n   151→\n   152→    if (global.isStructuredOutput()) {\n   153→        var blocked_issues = try allocator.alloc(BlockedResult.BlockedIssue, display_issues.len);\n   154→        defer {\n   155→            for (blocked_issues) |bi| {\n   156→                allocator.free(bi.blocked_by);\n   157→            }\n   158→            allocator.free(blocked_issues);\n   159→        }\n   160→\n   161→        for (display_issues, 0..) |issue, i| {\n   162→            const blockers = try graph.getBlockers(issue.id);\n   163→            defer graph.freeIssues(blockers);\n   164→\n   165→            var blocker_ids = try allocator.alloc([]const u8, blockers.len);\n   166→            for (blockers, 0..) |blocker, j| {\n   167→                blocker_ids[j] = blocker.id;\n   168→            }\n   169→\n   170→            blocked_issues[i] = .{\n   171→                .id = issue.id,\n   172→                .title = issue.title,\n   173→                .priority = issue.priority.value,\n   174→                .blocked_by = blocker_ids,\n   175→            };\n   176→        }\n   177→\n   178→        try ctx.output.printJson(BlockedResult{\n   179→            .success = true,\n   180→            .issues = blocked_issues,\n   181→            .count = display_issues.len,\n   182→        });\n   183→    } else {\n   184→        for (display_issues) |issue| {\n   185→            const blockers = try graph.getBlockers(issue.id);\n   186→            defer graph.freeIssues(blockers);\n   187→\n   188→            try ctx.output.print(\"{s}  {s}\\n\", .{ issue.id, issue.title });\n   189→\n   190→            if (blockers.len > 0) {\n   191→                try ctx.output.print(\"  blocked by: \", .{});\n   192→                for (blockers, 0..) |blocker, j| {\n   193→                    if (j > 0) try ctx.output.print(\", \", .{});\n   194→                    try ctx.output.print(\"{s}\", .{blocker.id});\n   195→                }\n   196→                try ctx.output.print(\"\\n\", .{});\n   197→            }\n   198→        }\n   199→\n   200→        if (!global.quiet and display_issues.len == 0) {\n   201→            try ctx.output.info(\"No blocked issues\", .{});\n   202→        }\n   203→    }\n   204→}\n   205→\n   206→fn applyLimit(issues: []Issue, limit: ?u32) []Issue {\n   207→    if (limit) |n| {\n   208→        if (n < issues.len) {\n   209→            return issues[0..n];\n   210→        }\n   211→    }\n   212→    return issues;\n   213→}\n   214→\n   215→fn applyFilters(\n   216→    allocator: std.mem.Allocator,\n   217→    issues: []Issue,\n   218→    priority_min: ?Priority,\n   219→    priority_max: ?Priority,\n   220→    title_contains: ?[]const u8,\n   221→    desc_contains: ?[]const u8,\n   222→    notes_contains: ?[]const u8,\n   223→) ![]Issue {\n   224→    // No filters - return original slice\n   225→    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null) {\n   226→        return try allocator.dupe(Issue, issues);\n   227→    }\n   228→\n   229→    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n   230→    errdefer filtered.deinit(allocator);\n   231→\n   232→    for (issues) |issue| {\n   233→        // Priority range filters (lower value = higher priority)\n   234→        if (priority_min) |min_p| {\n   235→            if (issue.priority.value < min_p.value) continue;\n   236→        }\n   237→        if (priority_max) |max_p| {\n   238→            if (issue.priority.value > max_p.value) continue;\n   239→        }\n   240→\n   241→        // Substring filters (case-insensitive)\n   242→        if (title_contains) |query| {\n   243→            if (!containsIgnoreCase(issue.title, query)) continue;\n   244→        }\n   245→        if (desc_contains) |query| {\n   246→            if (issue.description) |desc| {\n   247→                if (!containsIgnoreCase(desc, query)) continue;\n   248→            } else continue;\n   249→        }\n   250→        if (notes_contains) |query| {\n   251→            if (issue.notes) |notes| {\n   252→                if (!containsIgnoreCase(notes, query)) continue;\n   253→            } else continue;\n   254→        }\n   255→\n   256→        try filtered.append(allocator, issue);\n   257→    }\n   258→\n   259→    return filtered.toOwnedSlice(allocator);\n   260→}\n   261→\n   262→// --- Tests ---\n   263→\n   264→test \"ReadyError enum exists\" {\n   265→    const err: ReadyError = ReadyError.WorkspaceNotInitialized;\n   266→    try std.testing.expect(err == ReadyError.WorkspaceNotInitialized);\n   267→}\n   268→\n   269→test \"ReadyResult struct works\" {\n   270→    const result = ReadyResult{\n   271→        .success = true,\n   272→        .count = 3,\n   273→    };\n   274→    try std.testing.expect(result.success);\n   275→    try std.testing.expectEqual(@as(usize, 3), result.count.?);\n   276→}\n   277→\n   278→test \"BlockedResult struct works\" {\n   279→    const result = BlockedResult{\n   280→        .success = true,\n   281→        .count = 2,\n   282→    };\n   283→    try std.testing.expect(result.success);\n   284→    try std.testing.expectEqual(@as(usize, 2), result.count.?);\n   285→}\n   286→\n   287→test \"run detects uninitialized workspace\" {\n   288→    const allocator = std.testing.allocator;\n   289→\n   290→    const ready_args = args.ReadyArgs{};\n   291→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   292→\n   293→    const result = run(ready_args, global, allocator);\n   294→    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n   295→}\n   296→\n   297→test \"runBlocked detects uninitialized workspace\" {\n   298→    const allocator = std.testing.allocator;\n   299→\n   300→    const blocked_args = args.BlockedArgs{};\n   301→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   302→\n   303→    const result = runBlocked(blocked_args, global, allocator);\n   304→    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n   305→}\n   306→\n   307→test \"run returns empty list for empty workspace\" {\n   308→    const allocator = std.testing.allocator;\n   309→\n   310→    const tmp_dir_path = try test_util.createTestDir(allocator, \"ready_empty\");\n   311→    defer allocator.free(tmp_dir_path);\n   312→    defer test_util.cleanupTestDir(tmp_dir_path);\n   313→\n   314→    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   315→    defer allocator.free(data_path);\n   316→\n   317→    try std.fs.cwd().makeDir(data_path);\n   318→\n   319→    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   320→    defer allocator.free(issues_path);\n   321→\n   322→    const f = try std.fs.cwd().createFile(issues_path, .{});\n   323→    f.close();\n   324→\n   325→    const ready_args = args.ReadyArgs{};\n   326→    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   327→\n   328→    try run(ready_args, global, allocator);\n   329→}\n   330→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"a5ad4122-8064-497a-869d-1965cafdd4a9"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KYbbFqLJpvuHeL7c585p98","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WPUMQaHBP7o5zaLEUYA3jB","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1247,"cache_read_input_tokens":13140,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1247},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"7922bd6c-5c0e-4262-8100-77bc86758ceb"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (27001 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01WPUMQaHBP7o5zaLEUYA3jB"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f68e8636-5822-494c-af22-df76a3aeff90","tool_use_result":"Error: File content (27001 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Py1PE7nRq3wwSCsjdu92N5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VqKvZMDSJc65oxD3kXZ4U7","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1,"limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7383,"cache_read_input_tokens":14387,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7383},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"2161f74c-3002-4a4e-83c3-f431d1aa93cc"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VqKvZMDSJc65oxD3kXZ4U7","type":"tool_result","content":"     1→//! CLI argument parsing for beads_zig.\n     2→//!\n     3→//! Parses command-line arguments into structured data for command dispatch.\n     4→//! Supports global flags, subcommands, and subcommand-specific arguments.\n     5→\n     6→const std = @import(\"std\");\n     7→\n     8→/// Global CLI options that apply to all commands.\n     9→pub const GlobalOptions = struct {\n    10→    json: bool = false,\n    11→    toon: bool = false,\n    12→    quiet: bool = false,\n    13→    silent: bool = false, // Suppress ALL output including errors (for tests)\n    14→    verbose: u8 = 0,\n    15→    no_color: bool = false,\n    16→    data_path: ?[]const u8 = null,\n    17→    actor: ?[]const u8 = null,\n    18→    lock_timeout: u32 = 5000,\n    19→    no_auto_flush: bool = false,\n    20→    no_auto_import: bool = false,\n    21→\n    22→    /// Returns true if structured output (JSON or TOON) is enabled.\n    23→    pub fn isStructuredOutput(self: GlobalOptions) bool {\n    24→        return self.json or self.toon;\n    25→    }\n    26→};\n    27→\n    28→/// All available subcommands.\n    29→pub const Command = union(enum) {\n    30→    // Workspace\n    31→    init: InitArgs,\n    32→    info: void,\n    33→    stats: void,\n    34→    doctor: void,\n    35→    config: ConfigArgs,\n    36→    orphans: OrphansArgs,\n    37→    lint: LintArgs,\n    38→    where: void,\n    39→\n    40→    // Issue CRUD\n    41→    create: CreateArgs,\n    42→    q: QuickArgs,\n    43→    show: ShowArgs,\n    44→    update: UpdateArgs,\n    45→    close: CloseArgs,\n    46→    reopen: ReopenArgs,\n    47→    delete: DeleteArgs,\n    48→\n    49→    // Batch Operations\n    50→    add_batch: AddBatchArgs,\n    51→    import_cmd: ImportArgs,\n    52→\n    53→    // Query\n    54→    list: ListArgs,\n    55→    ready: ReadyArgs,\n    56→    blocked: BlockedArgs,\n    57→    search: SearchArgs,\n    58→    stale: StaleArgs,\n    59→    count: CountArgs,\n    60→    defer_cmd: DeferArgs,\n    61→    undefer: UndeferArgs,\n    62→\n    63→    // Dependencies\n    64→    dep: DepArgs,\n    65→    graph: GraphArgs,\n    66→\n    67→    // Epics\n    68→    epic: EpicArgs,\n    69→\n    70→    // Labels\n    71→    label: LabelArgs,\n    72→\n    73→    // Comments\n    74→    comments: CommentsArgs,\n    75→\n    76→    // Audit\n    77→    history: HistoryArgs,\n    78→    audit: AuditArgs,\n    79→\n    80→    // Changelog\n    81→    changelog: ChangelogArgs,\n    82→\n    83→    // Sync\n    84→    sync: SyncArgs,\n    85→\n    86→    // System\n    87→    version: void,\n    88→    schema: void,\n    89→    completions: CompletionsArgs,\n    90→    metrics: MetricsArgs,\n    91→\n    92→    // Saved Queries\n    93→    query: QueryArgs,\n    94→\n    95→    // Self-upgrade\n    96→    upgrade: UpgradeArgs,\n    97→\n    98→    // Help\n    99→    help: HelpArgs,\n   100→};\n   101→\n   102→/// Init command arguments.\n   103→pub const InitArgs = struct {\n   104→    prefix: []const u8 = \"bd\",\n   105→};\n   106→\n   107→/// Create command arguments.\n   108→pub const CreateArgs = struct {\n   109→    title: []const u8,\n   110→    description: ?[]const u8 = null,\n   111→    issue_type: ?[]const u8 = null,\n   112→    priority: ?[]const u8 = null,\n   113→    assignee: ?[]const u8 = null,\n   114→    owner: ?[]const u8 = null,\n   115→    design: ?[]const u8 = null,\n   116→    acceptance_criteria: ?[]const u8 = null,\n   117→    external_ref: ?[]const u8 = null,\n   118→    labels: []const []const u8 = &[_][]const u8{},\n   119→    deps: []const []const u8 = &[_][]const u8{},\n   120→    due: ?[]const u8 = null,\n   121→    estimate: ?i32 = null,\n   122→    ephemeral: bool = false, // Local-only, not written to JSONL\n   123→};\n   124→\n   125→/// Quick capture command arguments.\n   126→pub const QuickArgs = struct {\n   127→    title: []const u8,\n   128→    priority: ?[]const u8 = null,\n   129→};\n   130→\n   131→/// Show command arguments.\n   132→pub const ShowArgs = struct {\n   133→    id: []const u8,\n   134→    with_comments: bool = true,\n   135→    with_history: bool = false,\n   136→};\n   137→\n   138→/// Update command arguments.\n   139→pub const UpdateArgs = struct {\n   140→    id: []const u8,\n   141→    title: ?[]const u8 = null,\n   142→    description: ?[]const u8 = null,\n   143→    issue_type: ?[]const u8 = null,\n   144→    priority: ?[]const u8 = null,\n   145→    assignee: ?[]const u8 = null,\n   146→    owner: ?[]const u8 = null,\n   147→    design: ?[]const u8 = null,\n   148→    acceptance_criteria: ?[]const u8 = null,\n   149→    external_ref: ?[]const u8 = null,\n   150→    status: ?[]const u8 = null,\n   151→    /// Expected version for optimistic locking (compare-and-swap).\n   152→    expected_version: ?u64 = null,\n   153→    /// Claim: set assignee to actor AND status to in_progress atomically.\n   154→    claim: bool = false,\n   155→};\n   156→\n   157→/// Close command arguments.\n   158→pub const CloseArgs = struct {\n   159→    id: []const u8,\n   160→    reason: ?[]const u8 = null,\n   161→    session: ?[]const u8 = null,\n   162→};\n   163→\n   164→/// Reopen command arguments.\n   165→pub const ReopenArgs = struct {\n   166→    id: []const u8,\n   167→};\n   168→\n   169→/// Delete command arguments.\n   170→pub const DeleteArgs = struct {\n   171→    id: []const u8,\n   172→};\n   173→\n   174→/// Add-batch command arguments.\n   175→/// Creates multiple issues from stdin or a file with single lock acquisition.\n   176→pub const AddBatchArgs = struct {\n   177→    file: ?[]const u8 = null, // Read from file instead of stdin\n   178→    format: BatchFormat = .titles, // Input format\n   179→};\n   180→\n   181→/// Batch input format.\n   182→pub const BatchFormat = enum {\n   183→    titles, // One title per line\n   184→    jsonl, // Full JSONL format (one issue per line)\n   185→\n   186→    pub fn fromString(s: []const u8) ?BatchFormat {\n   187→        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n   188→        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n   189→        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n   190→        return null;\n   191→    }\n   192→};\n   193→\n   194→/// Import command arguments.\n   195→/// Imports issues from a JSONL file with single lock acquisition.\n   196→pub const ImportArgs = struct {\n   197→    file: []const u8, // Path to JSONL file (required)\n   198→    merge: bool = false, // Merge instead of replace\n   199→    dry_run: bool = false, // Show what would be imported without importing\n   200→};\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"e1e5dd63-3d1e-4174-8c96-6b17bd05be13"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Py1PE7nRq3wwSCsjdu92N5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PxcwS8p6J8UMVxAj6nX87s","name":"Grep","input":{"pattern":"pub const ListArgs|pub const ReadyArgs|pub const BlockedArgs","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":15}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7383,"cache_read_input_tokens":14387,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7383},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"7dc028d0-8952-49e1-869d-e8c3d4489c02"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PxcwS8p6J8UMVxAj6nX87s","type":"tool_result","content":"202-/// Sort field options for list command.\n203-pub const SortField = enum {\n204-    created_at,\n205-    updated_at,\n206-    priority,\n207-\n208-    pub fn fromString(s: []const u8) ?SortField {\n209-        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n210-        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n211-        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n212-        return null;\n213-    }\n214-};\n215-\n216-/// List command arguments.\n217:pub const ListArgs = struct {\n218-    status: ?[]const u8 = null,\n219-    priority: ?[]const u8 = null,\n220-    priority_min: ?[]const u8 = null,\n221-    priority_max: ?[]const u8 = null,\n222-    issue_type: ?[]const u8 = null,\n223-    assignee: ?[]const u8 = null,\n224-    label: ?[]const u8 = null,\n225-    label_any: []const []const u8 = &[_][]const u8{},\n226-    title_contains: ?[]const u8 = null,\n227-    desc_contains: ?[]const u8 = null,\n228-    notes_contains: ?[]const u8 = null,\n229-    limit: ?u32 = null,\n230-    all: bool = false,\n231-    sort: SortField = .created_at,\n232-    sort_desc: bool = true,\n233-};\n234-\n235-/// Ready command arguments.\n236:pub const ReadyArgs = struct {\n237-    limit: ?u32 = null,\n238-    priority_min: ?[]const u8 = null,\n239-    priority_max: ?[]const u8 = null,\n240-    title_contains: ?[]const u8 = null,\n241-    desc_contains: ?[]const u8 = null,\n242-    notes_contains: ?[]const u8 = null,\n243-};\n244-\n245-/// Blocked command arguments.\n246:pub const BlockedArgs = struct {\n247-    limit: ?u32 = null,\n248-    priority_min: ?[]const u8 = null,\n249-    priority_max: ?[]const u8 = null,\n250-    title_contains: ?[]const u8 = null,\n251-    desc_contains: ?[]const u8 = null,\n252-    notes_contains: ?[]const u8 = null,\n253-};\n254-\n255-/// Search command arguments.\n256-pub const SearchArgs = struct {\n257-    query: []const u8,\n258-    limit: ?u32 = null,\n259-};\n260-\n261-/// Stale command arguments."}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"bee2233b-aaaf-42fa-ab0b-4249ef9d87fb"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UvNu3DP8Zh9TM8pobBkNnA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016KLXPnDbLka8hJY3MVhg1u","name":"Grep","input":{"pattern":"pub const ListFilters|fn list\\(","path":"/home/hotschmoe/beads_zig/src/storage/store.zig","output_mode":"content","context":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3571,"cache_read_input_tokens":21770,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3571},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"906c223f-a859-41c4-b221-203c9d88d334"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016KLXPnDbLka8hJY3MVhg1u","type":"tool_result","content":"311-        if (updates.pinned) |v| {\n312-            issue.pinned = v;\n313-        }\n314-        if (updates.is_template) |v| {\n315-            issue.is_template = v;\n316-        }\n317-        if (updates.content_hash) |v| {\n318-            if (issue.content_hash) |h| self.allocator.free(h);\n319-            issue.content_hash = try self.allocator.dupe(u8, v);\n320-        }\n321-\n322-        try self.markDirty(id);\n323-    }\n324-\n325-    /// Soft delete an issue by setting its status to tombstone.\n326-    pub fn delete(self: *Self, id: []const u8, now: i64) !void {\n327-        try self.update(id, .{ .status = .tombstone }, now);\n328-    }\n329-\n330-    /// Filters for listing issues.\n331:    pub const ListFilters = struct {\n332-        status: ?Status = null,\n333-        priority: ?Priority = null,\n334-        priority_min: ?Priority = null,\n335-        priority_max: ?Priority = null,\n336-        issue_type: ?IssueType = null,\n337-        assignee: ?[]const u8 = null,\n338-        label: ?[]const u8 = null,\n339-        label_any: []const []const u8 = &[_][]const u8{},\n340-        title_contains: ?[]const u8 = null,\n341-        desc_contains: ?[]const u8 = null,\n342-        notes_contains: ?[]const u8 = null,\n343-        include_tombstones: bool = false,\n344-        limit: ?u32 = null,\n345-        offset: ?u32 = null,\n346-        order_by: OrderBy = .created_at,\n347-        order_desc: bool = true,\n348-\n349-        pub const OrderBy = enum {\n350-            created_at,\n351-            updated_at,\n352-            priority,\n353-        };\n354-    };\n355-\n356-    /// List issues with optional filters.\n357:    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n358-        var results: std.ArrayListUnmanaged(Issue) = .{};\n359-        errdefer {\n360-            for (results.items) |*issue| {\n361-                issue.deinit(self.allocator);\n362-            }\n363-            results.deinit(self.allocator);\n364-        }\n365-\n366-        for (self.issues.items) |issue| {\n367-            // Filter tombstones\n368-            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n369-                continue;\n370-            }\n371-\n372-            // Apply filters\n373-            if (filters.status) |s| {\n374-                if (!statusEql(issue.status, s)) continue;\n375-            }\n376-            if (filters.priority) |p| {\n377-                if (issue.priority.value != p.value) continue;"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"51aa3a58-ec7d-44a1-b05f-5265bc522894"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UvNu3DP8Zh9TM8pobBkNnA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012bhMehHRnszvxffJieAo6a","name":"Grep","input":{"pattern":"parseListCommand|parseReadyCommand|parseBlockedCommand","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":15}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3571,"cache_read_input_tokens":21770,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3571},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"ad7f62bd-fe05-4bfa-b231-a2fee8bcdde8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012bhMehHRnszvxffJieAo6a","type":"tool_result","content":"No matches found"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"d2372a29-010e-4220-bce2-b3fb1bb97d42"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01F9VKmtLpRH8WtBX7YyVCVG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0154dXQ8MbZWT4u3AT4oEchu","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","offset":331,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1191,"cache_read_input_tokens":25341,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1191},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"30ee5785-f8dc-4898-a41d-20dfae350e35"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0154dXQ8MbZWT4u3AT4oEchu","type":"tool_result","content":"   331→    pub const ListFilters = struct {\n   332→        status: ?Status = null,\n   333→        priority: ?Priority = null,\n   334→        priority_min: ?Priority = null,\n   335→        priority_max: ?Priority = null,\n   336→        issue_type: ?IssueType = null,\n   337→        assignee: ?[]const u8 = null,\n   338→        label: ?[]const u8 = null,\n   339→        label_any: []const []const u8 = &[_][]const u8{},\n   340→        title_contains: ?[]const u8 = null,\n   341→        desc_contains: ?[]const u8 = null,\n   342→        notes_contains: ?[]const u8 = null,\n   343→        include_tombstones: bool = false,\n   344→        limit: ?u32 = null,\n   345→        offset: ?u32 = null,\n   346→        order_by: OrderBy = .created_at,\n   347→        order_desc: bool = true,\n   348→\n   349→        pub const OrderBy = enum {\n   350→            created_at,\n   351→            updated_at,\n   352→            priority,\n   353→        };\n   354→    };\n   355→\n   356→    /// List issues with optional filters.\n   357→    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n   358→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   359→        errdefer {\n   360→            for (results.items) |*issue| {\n   361→                issue.deinit(self.allocator);\n   362→            }\n   363→            results.deinit(self.allocator);\n   364→        }\n   365→\n   366→        for (self.issues.items) |issue| {\n   367→            // Filter tombstones\n   368→            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n   369→                continue;\n   370→            }\n   371→\n   372→            // Apply filters\n   373→            if (filters.status) |s| {\n   374→                if (!statusEql(issue.status, s)) continue;\n   375→            }\n   376→            if (filters.priority) |p| {\n   377→                if (issue.priority.value != p.value) continue;\n   378→            }\n   379→            if (filters.issue_type) |t| {\n   380→                if (!issueTypeEql(issue.issue_type, t)) continue;\n   381→            }\n   382→            if (filters.assignee) |a| {\n   383→                if (issue.assignee == null) continue;\n   384→                if (!std.mem.eql(u8, issue.assignee.?, a)) continue;\n   385→            }\n   386→            if (filters.label) |lbl| {\n   387→                var found = false;\n   388→                for (issue.labels) |label| {\n   389→                    if (std.mem.eql(u8, label, lbl)) {\n   390→                        found = true;\n   391→                        break;\n   392→                    }\n   393→                }\n   394→                if (!found) continue;\n   395→            }\n   396→\n   397→            // label_any: OR logic - issue must have at least ONE of the specified labels\n   398→            if (filters.label_any.len > 0) {\n   399→                var found_any = false;\n   400→                for (filters.label_any) |any_label| {\n   401→                    for (issue.labels) |issue_label| {\n   402→                        if (std.mem.eql(u8, issue_label, any_label)) {\n   403→                            found_any = true;\n   404→                            break;\n   405→                        }\n   406→                    }\n   407→                    if (found_any) break;\n   408→                }\n   409→                if (!found_any) continue;\n   410→            }\n   411→\n   412→            // Priority range filters (lower value = higher priority)\n   413→            if (filters.priority_min) |min_p| {\n   414→                if (issue.priority.value < min_p.value) continue;\n   415→            }\n   416→            if (filters.priority_max) |max_p| {\n   417→                if (issue.priority.value > max_p.value) continue;\n   418→            }\n   419→\n   420→            // Substring filters (case-insensitive)\n   421→            if (filters.title_contains) |query| {\n   422→                if (!containsIgnoreCase(issue.title, query)) continue;\n   423→            }\n   424→            if (filters.desc_contains) |query| {\n   425→                if (issue.description) |desc| {\n   426→                    if (!containsIgnoreCase(desc, query)) continue;\n   427→                } else continue;\n   428→            }\n   429→            if (filters.notes_contains) |query| {\n   430→                if (issue.notes) |notes| {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"2d53ac78-715d-4cf1-917f-d22d0457e64a"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01F9VKmtLpRH8WtBX7YyVCVG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CfwYpA3eF5vT6Bdk5HSV5f","name":"Bash","input":{"command":"grep -n \"fn parse.*list\\|fn parse.*ready\\|fn parse.*blocked\" /home/hotschmoe/beads_zig/src/cli/args.zig | head -20"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1191,"cache_read_input_tokens":25341,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1191},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f18dbc37-57a8-4517-b7f3-778b7f179199"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CfwYpA3eF5vT6Bdk5HSV5f","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f935c722-791f-472d-8b41-b210fdc274ec"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VneLq3Qw55r6LgskYBqLJb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Lf9qdJiigXG1t3V535M4zP","name":"Bash","input":{"command":"grep -n \"\\\"list\\\"\\|\\\"ready\\\"\\|\\\"blocked\\\"\" /home/hotschmoe/beads_zig/src/cli/args.zig | head -30"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1688,"cache_read_input_tokens":26532,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1688},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"9845a8bd-c718-4d4a-996d-6f42674750fc"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Lf9qdJiigXG1t3V535M4zP","type":"tool_result","content":"708:        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n711:        if (std.mem.eql(u8, cmd, \"ready\")) {\n714:        if (std.mem.eql(u8, cmd, \"blocked\")) {\n1190:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1258:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1285:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1303:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1384:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1442:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1530:    const args = [_][]const u8{ \"--json\", \"list\" };\n1539:    const args = [_][]const u8{ \"--toon\", \"list\" };\n1548:    const args = [_][]const u8{ \"-q\", \"list\" };\n1557:    const args = [_][]const u8{ \"--quiet\", \"list\" };\n1566:    const args = [_][]const u8{ \"-v\", \"list\" };\n1574:    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n1582:    const args = [_][]const u8{ \"-vv\", \"list\" };\n1590:    const args = [_][]const u8{ \"--no-color\", \"list\" };\n1598:    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n1606:    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n1614:    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n1622:    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n1630:    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n1638:    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n1849:    const args = [_][]const u8{\"list\"};\n1857:    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n1868:    const args = [_][]const u8{ \"list\", \"--all\" };\n1876:    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n1885:    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n1894:    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n1913:    const args = [_][]const u8{\"ready\"};","is_error":false}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"00ed5cc8-f6ab-4d5f-800c-c7f33ca94104"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VneLq3Qw55r6LgskYBqLJb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NY93UyFquhPp8HWzZNa1HD","name":"Grep","input":{"pattern":"--priority-min|--priority-max|--due|--defer","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":2}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1688,"cache_read_input_tokens":26532,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1688},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"78df14d0-94b3-46ed-9d77-854a5d8bb1e7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NY93UyFquhPp8HWzZNa1HD","type":"tool_result","content":"843-            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n844-                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n845:            } else if (self.consumeFlag(null, \"--due\")) {\n846-                result.due = self.next() orelse return error.MissingFlagValue;\n847-            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n--\n1031-            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n1032-                result.priority = self.next() orelse return error.MissingFlagValue;\n1033:            } else if (self.consumeFlag(null, \"--priority-min\")) {\n1034-                result.priority_min = self.next() orelse return error.MissingFlagValue;\n1035:            } else if (self.consumeFlag(null, \"--priority-max\")) {\n1036-                result.priority_max = self.next() orelse return error.MissingFlagValue;\n1037-            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n--\n1075-            if (try self.parseLimitFlag()) |limit| {\n1076-                result.limit = limit;\n1077:            } else if (self.consumeFlag(null, \"--priority-min\")) {\n1078-                result.priority_min = self.next() orelse return error.MissingFlagValue;\n1079:            } else if (self.consumeFlag(null, \"--priority-max\")) {\n1080-                result.priority_max = self.next() orelse return error.MissingFlagValue;\n1081-            } else if (self.consumeFlag(null, \"--title-contains\")) {\n--\n1095-            if (try self.parseLimitFlag()) |limit| {\n1096-                result.limit = limit;\n1097:            } else if (self.consumeFlag(null, \"--priority-min\")) {\n1098-                result.priority_min = self.next() orelse return error.MissingFlagValue;\n1099:            } else if (self.consumeFlag(null, \"--priority-max\")) {\n1100-                result.priority_max = self.next() orelse return error.MissingFlagValue;\n1101-            } else if (self.consumeFlag(null, \"--title-contains\")) {\n--\n1756-        \"--assignee\",\n1757-        \"alice\",\n1758:        \"--due\",\n1759-        \"2024-02-15\",\n1760-        \"--estimate\","}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"ea8d7788-e80d-4f4b-a30d-52cc76797412"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Fsfqi4sv5mj1HmNe4bbQx7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011HnL9ru94k546qJrK6233h","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1000,"limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1846,"cache_read_input_tokens":28220,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1846},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"e65899e1-0768-4154-847a-093bb9cf988e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011HnL9ru94k546qJrK6233h","type":"tool_result","content":"  1000→        return result;\n  1001→    }\n  1002→\n  1003→    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n  1004→        var result = ImportArgs{ .file = undefined };\n  1005→        var file_set = false;\n  1006→\n  1007→        while (self.hasNext()) {\n  1008→            if (self.consumeFlag(\"-m\", \"--merge\")) {\n  1009→                result.merge = true;\n  1010→            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n  1011→                result.dry_run = true;\n  1012→            } else if (self.peekPositional()) |_| {\n  1013→                if (!file_set) {\n  1014→                    result.file = self.next().?;\n  1015→                    file_set = true;\n  1016→                } else break;\n  1017→            } else break;\n  1018→        }\n  1019→\n  1020→        if (!file_set) return error.MissingRequiredArgument;\n  1021→        return result;\n  1022→    }\n  1023→\n  1024→    fn parseListArgs(self: *Self) ParseError!ListArgs {\n  1025→        var result = ListArgs{};\n  1026→        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n  1027→\n  1028→        while (self.hasNext()) {\n  1029→            if (self.consumeFlag(\"-s\", \"--status\")) {\n  1030→                result.status = self.next() orelse return error.MissingFlagValue;\n  1031→            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n  1032→                result.priority = self.next() orelse return error.MissingFlagValue;\n  1033→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1034→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1035→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1036→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1037→            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n  1038→                result.issue_type = self.next() orelse return error.MissingFlagValue;\n  1039→            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n  1040→                result.assignee = self.next() orelse return error.MissingFlagValue;\n  1041→            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n  1042→                result.label = self.next() orelse return error.MissingFlagValue;\n  1043→            } else if (self.consumeFlag(null, \"--label-any\")) {\n  1044→                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n  1045→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1046→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1047→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1048→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1049→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1050→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1051→            } else if (try self.parseLimitFlag()) |limit| {\n  1052→                result.limit = limit;\n  1053→            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n  1054→                result.all = true;\n  1055→            } else if (self.consumeFlag(null, \"--sort\")) {\n  1056→                const sort_str = self.next() orelse return error.MissingFlagValue;\n  1057→                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n  1058→            } else if (self.consumeFlag(null, \"--asc\")) {\n  1059→                result.sort_desc = false;\n  1060→            } else if (self.consumeFlag(null, \"--desc\")) {\n  1061→                result.sort_desc = true;\n  1062→            } else break;\n  1063→        }\n  1064→\n  1065→        if (label_any_list.items.len > 0) {\n  1066→            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n  1067→        }\n  1068→\n  1069→        return result;\n  1070→    }\n  1071→\n  1072→    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n  1073→        var result = ReadyArgs{};\n  1074→        while (self.hasNext()) {\n  1075→            if (try self.parseLimitFlag()) |limit| {\n  1076→                result.limit = limit;\n  1077→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1078→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1079→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1080→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1081→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1082→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1083→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1084→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1085→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1086→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1087→            } else break;\n  1088→        }\n  1089→        return result;\n  1090→    }\n  1091→\n  1092→    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n  1093→        var result = BlockedArgs{};\n  1094→        while (self.hasNext()) {\n  1095→            if (try self.parseLimitFlag()) |limit| {\n  1096→                result.limit = limit;\n  1097→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1098→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1099→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1100→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1101→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1102→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1103→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1104→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1105→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1106→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1107→            } else break;\n  1108→        }\n  1109→        return result;\n  1110→    }\n  1111→\n  1112→    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n  1113→        var result = SearchArgs{ .query = undefined };\n  1114→        var query_set = false;\n  1115→\n  1116→        while (self.hasNext()) {\n  1117→            if (try self.parseLimitFlag()) |limit| {\n  1118→                result.limit = limit;\n  1119→            } else if (self.peekPositional()) |_| {\n  1120→                if (!query_set) {\n  1121→                    result.query = self.next().?;\n  1122→                    query_set = true;\n  1123→                } else break;\n  1124→            } else break;\n  1125→        }\n  1126→\n  1127→        if (!query_set) return error.MissingRequiredArgument;\n  1128→        return result;\n  1129→    }\n  1130→\n  1131→    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n  1132→        var result = StaleArgs{};\n  1133→        while (self.hasNext()) {\n  1134→            if (self.consumeFlag(\"-d\", \"--days\")) {\n  1135→                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n  1136→            } else if (try self.parseLimitFlag()) |limit| {\n  1137→                result.limit = limit;\n  1138→            } else break;\n  1139→        }\n  1140→        return result;\n  1141→    }\n  1142→\n  1143→    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n  1144→        var result = CountArgs{};\n  1145→        while (self.hasNext()) {\n  1146→            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n  1147→                result.group_by = self.next() orelse return error.MissingFlagValue;\n  1148→            } else break;\n  1149→        }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"efbe1214-54ec-462e-b263-b9e21d867e10"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Fsfqi4sv5mj1HmNe4bbQx7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017a881odkPtreTPfZuJECez","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":700,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1846,"cache_read_input_tokens":28220,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1846},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"0c9b91bf-4447-489e-877b-7bb3ab69b3de"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017a881odkPtreTPfZuJECez","type":"tool_result","content":"   700→        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n   701→            return .{ .add_batch = try self.parseAddBatchArgs() };\n   702→        }\n   703→        if (std.mem.eql(u8, cmd, \"import\")) {\n   704→            return .{ .import_cmd = try self.parseImportArgs() };\n   705→        }\n   706→\n   707→        // Query\n   708→        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n   709→            return .{ .list = try self.parseListArgs() };\n   710→        }\n   711→        if (std.mem.eql(u8, cmd, \"ready\")) {\n   712→            return .{ .ready = try self.parseReadyArgs() };\n   713→        }\n   714→        if (std.mem.eql(u8, cmd, \"blocked\")) {\n   715→            return .{ .blocked = try self.parseBlockedArgs() };\n   716→        }\n   717→        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n   718→            return .{ .search = try self.parseSearchArgs() };\n   719→        }\n   720→        if (std.mem.eql(u8, cmd, \"stale\")) {\n   721→            return .{ .stale = try self.parseStaleArgs() };\n   722→        }\n   723→        if (std.mem.eql(u8, cmd, \"count\")) {\n   724→            return .{ .count = try self.parseCountArgs() };\n   725→        }\n   726→        if (std.mem.eql(u8, cmd, \"defer\")) {\n   727→            return .{ .defer_cmd = try self.parseDeferArgs() };\n   728→        }\n   729→        if (std.mem.eql(u8, cmd, \"undefer\")) {\n   730→            return .{ .undefer = try self.parseUndeferArgs() };\n   731→        }\n   732→\n   733→        // Dependencies\n   734→        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n   735→            return .{ .dep = try self.parseDepArgs() };\n   736→        }\n   737→        if (std.mem.eql(u8, cmd, \"graph\")) {\n   738→            return .{ .graph = try self.parseGraphArgs() };\n   739→        }\n   740→\n   741→        // Epics\n   742→        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n   743→            return .{ .epic = try self.parseEpicArgs() };\n   744→        }\n   745→\n   746→        // Labels\n   747→        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n   748→            return .{ .label = try self.parseLabelArgs() };\n   749→        }\n   750→\n   751→        // Comments\n   752→        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n   753→            return .{ .comments = try self.parseCommentsArgs() };\n   754→        }\n   755→\n   756→        // Audit\n   757→        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n   758→            return .{ .history = try self.parseHistoryArgs() };\n   759→        }\n   760→        if (std.mem.eql(u8, cmd, \"audit\")) {\n   761→            return .{ .audit = try self.parseAuditArgs() };\n   762→        }\n   763→\n   764→        // Changelog\n   765→        if (std.mem.eql(u8, cmd, \"changelog\")) {\n   766→            return .{ .changelog = try self.parseChangelogArgs() };\n   767→        }\n   768→\n   769→        // Sync\n   770→        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n   771→            return .{ .sync = try self.parseSyncArgs() };\n   772→        }\n   773→\n   774→        // System\n   775→        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n   776→            return .{ .version = {} };\n   777→        }\n   778→        if (std.mem.eql(u8, cmd, \"schema\")) {\n   779→            return .{ .schema = {} };\n   780→        }\n   781→        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n   782→            return .{ .completions = try self.parseCompletionsArgs() };\n   783→        }\n   784→        if (std.mem.eql(u8, cmd, \"metrics\")) {\n   785→            return .{ .metrics = try self.parseMetricsArgs() };\n   786→        }\n   787→\n   788→        // Saved Queries\n   789→        if (std.mem.eql(u8, cmd, \"query\")) {\n   790→            return .{ .query = try self.parseQueryArgs() };\n   791→        }\n   792→\n   793→        // Self-upgrade\n   794→        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n   795→            return .{ .upgrade = try self.parseUpgradeArgs() };\n   796→        }\n   797→\n   798→        // Help\n   799→        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"2b89faaa-97ab-44c9-9b19-5f0942c47203"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013wcw34xvoPALfn6TGdBo5h","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018diM96ZiPN5jNsaiuBuzVT","name":"Bash","input":{"command":"grep -n \"due_at\\|defer_until\" /home/hotschmoe/beads_zig/src/models/*.zig | head -50"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4857,"cache_read_input_tokens":30066,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4857},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"2af3672b-ef58-44cd-9716-d6564534b851"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013wcw34xvoPALfn6TGdBo5h","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019SJyCF622vj3HGyBnxT3xU","name":"Grep","input":{"pattern":"containsIgnoreCase","path":"/home/hotschmoe/beads_zig/src/storage/store.zig","output_mode":"content","context":10}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4857,"cache_read_input_tokens":30066,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4857},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f3350d02-6bb5-4808-b4f2-6d7df8682314"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018diM96ZiPN5jNsaiuBuzVT","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/models/issue.zig:136:    due_at: OptionalRfc3339Timestamp,\n/home/hotschmoe/beads_zig/src/models/issue.zig:137:    defer_until: OptionalRfc3339Timestamp,\n/home/hotschmoe/beads_zig/src/models/issue.zig:186:        if (a.due_at.value != b.due_at.value) return false;\n/home/hotschmoe/beads_zig/src/models/issue.zig:187:        if (a.defer_until.value != b.defer_until.value) return false;\n/home/hotschmoe/beads_zig/src/models/issue.zig:249:        result.due_at = self.due_at;\n/home/hotschmoe/beads_zig/src/models/issue.zig:250:        result.defer_until = self.defer_until;\n/home/hotschmoe/beads_zig/src/models/issue.zig:399:            .due_at = .{ .value = null },\n/home/hotschmoe/beads_zig/src/models/issue.zig:400:            .defer_until = .{ .value = null },\n/home/hotschmoe/beads_zig/src/models/issue.zig:678:        .due_at = .{ .value = null },\n/home/hotschmoe/beads_zig/src/models/issue.zig:679:        .defer_until = .{ .value = null },\n/home/hotschmoe/beads_zig/src/models/issue.zig:822:    issue.due_at = .{ .value = 1706600000 };\n/home/hotschmoe/beads_zig/src/models/issue.zig:823:    issue.defer_until = .{ .value = 1706560000 };","is_error":false}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"63ce5459-45d8-4796-be17-a1bd34e80207"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019SJyCF622vj3HGyBnxT3xU","type":"tool_result","content":"412-            // Priority range filters (lower value = higher priority)\n413-            if (filters.priority_min) |min_p| {\n414-                if (issue.priority.value < min_p.value) continue;\n415-            }\n416-            if (filters.priority_max) |max_p| {\n417-                if (issue.priority.value > max_p.value) continue;\n418-            }\n419-\n420-            // Substring filters (case-insensitive)\n421-            if (filters.title_contains) |query| {\n422:                if (!containsIgnoreCase(issue.title, query)) continue;\n423-            }\n424-            if (filters.desc_contains) |query| {\n425-                if (issue.description) |desc| {\n426:                    if (!containsIgnoreCase(desc, query)) continue;\n427-                } else continue;\n428-            }\n429-            if (filters.notes_contains) |query| {\n430-                if (issue.notes) |notes| {\n431:                    if (!containsIgnoreCase(notes, query)) continue;\n432-                } else continue;\n433-            }\n434-\n435-            try results.append(self.allocator, try issue.clone(self.allocator));\n436-        }\n437-\n438-        // Sort\n439-        const SortContext = struct {\n440-            order_by: ListFilters.OrderBy,\n441-            order_desc: bool,\n--\n855-}\n856-\n857-fn issueTypeEql(a: IssueType, b: IssueType) bool {\n858-    const Tag = std.meta.Tag(IssueType);\n859-    const tag_a: Tag = a;\n860-    const tag_b: Tag = b;\n861-    if (tag_a != tag_b) return false;\n862-    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n863-}\n864-\n865:pub fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {\n866-    if (needle.len == 0) return true;\n867-    if (needle.len > haystack.len) return false;\n868-\n869-    const end = haystack.len - needle.len + 1;\n870-    var i: usize = 0;\n871-    while (i < end) : (i += 1) {\n872-        var match = true;\n873-        for (needle, 0..) |nc, j| {\n874-            const hc = haystack[i + j];\n875-            if (std.ascii.toLower(hc) != std.ascii.toLower(nc)) {"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"231cfc1e-f3a1-48c4-915c-b9ab9f36ab48"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01C9xzUgtTyUZPZJyyPJy9aT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012Mw9e7P2DAbAdXy7bexgNo","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/models/issue.zig","offset":120,"limit":80}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1497,"cache_read_input_tokens":34923,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1497},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"cc1277e2-8bfe-460d-a9e7-3ff279e96f93"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012Mw9e7P2DAbAdXy7bexgNo","type":"tool_result","content":"   120→    priority: Priority,\n   121→    issue_type: IssueType,\n   122→\n   123→    // Assignment\n   124→    assignee: ?[]const u8,\n   125→    owner: ?[]const u8,\n   126→\n   127→    // Timestamps (Unix epoch seconds, serialized as RFC3339)\n   128→    created_at: Rfc3339Timestamp,\n   129→    created_by: ?[]const u8,\n   130→    updated_at: Rfc3339Timestamp,\n   131→    closed_at: OptionalRfc3339Timestamp,\n   132→    close_reason: ?[]const u8,\n   133→    closed_by_session: ?[]const u8 = null,\n   134→\n   135→    // Scheduling\n   136→    due_at: OptionalRfc3339Timestamp,\n   137→    defer_until: OptionalRfc3339Timestamp,\n   138→    estimated_minutes: ?i32,\n   139→\n   140→    // External references\n   141→    external_ref: ?[]const u8,\n   142→    source_system: ?[]const u8,\n   143→\n   144→    // Flags\n   145→    pinned: bool,\n   146→    is_template: bool,\n   147→    ephemeral: bool = false, // Local-only, not written to JSONL\n   148→\n   149→    // Version for optimistic locking (incremented on every update)\n   150→    version: u64 = 1,\n   151→\n   152→    // Embedded relations (populated on read, not stored in issues table)\n   153→    labels: []const []const u8,\n   154→    dependencies: []const Dependency,\n   155→    comments: []const Comment,\n   156→\n   157→    const Self = @This();\n   158→\n   159→    /// Validate that the issue has all required fields and constraints.\n   160→    pub fn validate(self: Self) IssueError!void {\n   161→        if (self.id.len == 0) return IssueError.EmptyId;\n   162→        if (self.title.len == 0) return IssueError.EmptyTitle;\n   163→        if (self.title.len > 500) return IssueError.TitleTooLong;\n   164→    }\n   165→\n   166→    /// Check equality between two Issues (compares all fields except embedded relations).\n   167→    pub fn eql(a: Self, b: Self) bool {\n   168→        if (!std.mem.eql(u8, a.id, b.id)) return false;\n   169→        if (!optionalStrEql(a.content_hash, b.content_hash)) return false;\n   170→        if (!std.mem.eql(u8, a.title, b.title)) return false;\n   171→        if (!optionalStrEql(a.description, b.description)) return false;\n   172→        if (!optionalStrEql(a.design, b.design)) return false;\n   173→        if (!optionalStrEql(a.acceptance_criteria, b.acceptance_criteria)) return false;\n   174→        if (!optionalStrEql(a.notes, b.notes)) return false;\n   175→        if (!statusEql(a.status, b.status)) return false;\n   176→        if (a.priority.value != b.priority.value) return false;\n   177→        if (!issueTypeEql(a.issue_type, b.issue_type)) return false;\n   178→        if (!optionalStrEql(a.assignee, b.assignee)) return false;\n   179→        if (!optionalStrEql(a.owner, b.owner)) return false;\n   180→        if (a.created_at.value != b.created_at.value) return false;\n   181→        if (!optionalStrEql(a.created_by, b.created_by)) return false;\n   182→        if (a.updated_at.value != b.updated_at.value) return false;\n   183→        if (a.closed_at.value != b.closed_at.value) return false;\n   184→        if (!optionalStrEql(a.close_reason, b.close_reason)) return false;\n   185→        if (!optionalStrEql(a.closed_by_session, b.closed_by_session)) return false;\n   186→        if (a.due_at.value != b.due_at.value) return false;\n   187→        if (a.defer_until.value != b.defer_until.value) return false;\n   188→        if (a.estimated_minutes != b.estimated_minutes) return false;\n   189→        if (!optionalStrEql(a.external_ref, b.external_ref)) return false;\n   190→        if (!optionalStrEql(a.source_system, b.source_system)) return false;\n   191→        if (a.pinned != b.pinned) return false;\n   192→        if (a.is_template != b.is_template) return false;\n   193→        if (a.ephemeral != b.ephemeral) return false;\n   194→        if (a.version != b.version) return false;\n   195→        return true;\n   196→    }\n   197→\n   198→    /// Clone the issue with deep copy of all allocated strings.\n   199→    pub fn clone(self: Self, allocator: std.mem.Allocator) !Self {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"610903e1-8f7d-455c-b19f-6c449f1c07ae"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01C9xzUgtTyUZPZJyyPJy9aT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01E2QrJbdu5qSXj4L4QqVy5z","name":"Bash","input":{"command":"grep -n \"defer\\|DeferArgs\" /home/hotschmoe/beads_zig/src/cli/args.zig | head -30"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1497,"cache_read_input_tokens":34923,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1497},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f282faa3-18df-40bc-ac1a-8cc27a83c4fe"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01E2QrJbdu5qSXj4L4QqVy5z","type":"tool_result","content":"60:    defer_cmd: DeferArgs,\n61:    undefer: UndeferArgs,\n273:pub const DeferArgs = struct {\n279:/// Undefer command arguments.\n280:pub const UndeferArgs = struct {\n726:        if (std.mem.eql(u8, cmd, \"defer\")) {\n727:            return .{ .defer_cmd = try self.parseDeferArgs() };\n729:        if (std.mem.eql(u8, cmd, \"undefer\")) {\n730:            return .{ .undefer = try self.parseUndeferArgs() };\n1153:    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n1155:        var result = DeferArgs{ .id = id };\n1166:    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n1168:        return UndeferArgs{ .id = id };\n2036:    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n2049:    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);","is_error":false}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"0ab3f317-3e08-4601-88f7-a5f2099f0781"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KSA48BxP88nyuF7Vp3UQZ8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WM3WoiKrb5bH8uCmsQ4tb9","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":273,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2034,"cache_read_input_tokens":36420,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2034},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"61a956a2-0a14-409c-bc15-455288eccc63"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WM3WoiKrb5bH8uCmsQ4tb9","type":"tool_result","content":"   273→pub const DeferArgs = struct {\n   274→    id: []const u8,\n   275→    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n   276→    reason: ?[]const u8 = null,\n   277→};\n   278→\n   279→/// Undefer command arguments.\n   280→pub const UndeferArgs = struct {\n   281→    id: []const u8,\n   282→};\n   283→\n   284→/// Epic subcommand variants.\n   285→pub const EpicSubcommand = union(enum) {\n   286→    create: struct {\n   287→        title: []const u8,\n   288→        description: ?[]const u8 = null,\n   289→        priority: ?[]const u8 = null,\n   290→    },\n   291→    add: struct {\n   292→        epic_id: []const u8,\n   293→        issue_id: []const u8,\n   294→    },\n   295→    remove: struct {\n   296→        epic_id: []const u8,\n   297→        issue_id: []const u8,\n   298→    },\n   299→    list: struct {\n   300→        epic_id: []const u8,\n   301→    },\n   302→};\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"bf837f77-80db-4b03-93ad-1776d77f3b8d"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KSA48BxP88nyuF7Vp3UQZ8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RXk2WNp2Sb4btgkec6WWAT","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1153,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2034,"cache_read_input_tokens":36420,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2034},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"b9aa7df6-f2c8-4777-9b20-08ee37735194"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RXk2WNp2Sb4btgkec6WWAT","type":"tool_result","content":"  1153→    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n  1154→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1155→        var result = DeferArgs{ .id = id };\n  1156→        while (self.hasNext()) {\n  1157→            if (self.consumeFlag(\"-u\", \"--until\")) {\n  1158→                result.until = self.next() orelse return error.MissingFlagValue;\n  1159→            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n  1160→                result.reason = self.next() orelse return error.MissingFlagValue;\n  1161→            } else break;\n  1162→        }\n  1163→        return result;\n  1164→    }\n  1165→\n  1166→    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n  1167→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1168→        return UndeferArgs{ .id = id };\n  1169→    }\n  1170→\n  1171→    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n  1172→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1173→\n  1174→        if (std.mem.eql(u8, subcmd, \"add\")) {\n  1175→            const child = self.next() orelse return error.MissingRequiredArgument;\n  1176→            const parent = self.next() orelse return error.MissingRequiredArgument;\n  1177→            var dep_type: []const u8 = \"blocks\";\n  1178→            while (self.hasNext()) {\n  1179→                if (self.consumeFlag(\"-t\", \"--type\")) {\n  1180→                    dep_type = self.next() orelse return error.MissingFlagValue;\n  1181→                } else break;\n  1182→            }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"d4aaae41-da7e-4c50-80b7-85bee1e5004a"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KSA48BxP88nyuF7Vp3UQZ8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019vdw77LP5PgAUXG7xhy4wj","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/defer.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2034,"cache_read_input_tokens":36420,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2034},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"e182d5dd-84f7-4eca-ba8b-39e2b6d19623"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019vdw77LP5PgAUXG7xhy4wj","type":"tool_result","content":"     1→//! Defer and Undefer commands for beads_zig.\n     2→//!\n     3→//! `bz defer <id> [--until <date>] [--reason <reason>]` - defer an issue\n     4→//! `bz undefer <id>` - remove defer status from an issue\n     5→\n     6→const std = @import(\"std\");\n     7→const args = @import(\"args.zig\");\n     8→const common = @import(\"common.zig\");\n     9→const models = @import(\"../models/mod.zig\");\n    10→const timestamp = @import(\"../models/timestamp.zig\");\n    11→\n    12→const Issue = models.Issue;\n    13→const Status = models.Status;\n    14→const CommandContext = common.CommandContext;\n    15→const IssueStore = common.IssueStore;\n    16→\n    17→pub const DeferError = error{\n    18→    WorkspaceNotInitialized,\n    19→    IssueNotFound,\n    20→    AlreadyDeferred,\n    21→    InvalidDate,\n    22→    StorageError,\n    23→    OutOfMemory,\n    24→};\n    25→\n    26→pub const DeferResult = struct {\n    27→    success: bool,\n    28→    id: ?[]const u8 = null,\n    29→    defer_until: ?i64 = null,\n    30→    message: ?[]const u8 = null,\n    31→};\n    32→\n    33→pub fn run(\n    34→    defer_args: args.DeferArgs,\n    35→    global: args.GlobalOptions,\n    36→    allocator: std.mem.Allocator,\n    37→) !void {\n    38→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    39→        return DeferError.WorkspaceNotInitialized;\n    40→    };\n    41→    defer ctx.deinit();\n    42→\n    43→    // Find the issue\n    44→    const issue = ctx.store.getRef(defer_args.id) orelse {\n    45→        if (global.isStructuredOutput()) {\n    46→            try ctx.output.printJson(DeferResult{\n    47→                .success = false,\n    48→                .message = \"issue not found\",\n    49→            });\n    50→        } else {\n    51→            try ctx.output.err(\"issue not found: {s}\", .{defer_args.id});\n    52→        }\n    53→        return DeferError.IssueNotFound;\n    54→    };\n    55→\n    56→    // Check if already deferred\n    57→    if (issue.status.eql(.deferred)) {\n    58→        if (global.isStructuredOutput()) {\n    59→            try ctx.output.printJson(DeferResult{\n    60→                .success = false,\n    61→                .id = defer_args.id,\n    62→                .message = \"issue is already deferred\",\n    63→            });\n    64→        } else {\n    65→            try ctx.output.warn(\"issue {s} is already deferred\", .{defer_args.id});\n    66→        }\n    67→        return DeferError.AlreadyDeferred;\n    68→    }\n    69→\n    70→    // Parse until date if provided\n    71→    var defer_until: ?i64 = null;\n    72→    if (defer_args.until) |until_str| {\n    73→        defer_until = parseUntilDate(until_str, allocator) catch |err| {\n    74→            if (global.isStructuredOutput()) {\n    75→                try ctx.output.printJson(DeferResult{\n    76→                    .success = false,\n    77→                    .message = \"invalid date format\",\n    78→                });\n    79→            } else {\n    80→                try ctx.output.err(\"invalid date format: {s}\", .{until_str});\n    81→            }\n    82→            return err;\n    83→        };\n    84→    }\n    85→\n    86→    // Update the issue\n    87→    const now = std.time.timestamp();\n    88→    try ctx.store.update(defer_args.id, .{\n    89→        .status = .deferred,\n    90→        .defer_until = defer_until,\n    91→    }, now);\n    92→\n    93→    try ctx.saveIfAutoFlush();\n    94→\n    95→    // Output result\n    96→    if (global.isStructuredOutput()) {\n    97→        try ctx.output.printJson(DeferResult{\n    98→            .success = true,\n    99→            .id = defer_args.id,\n   100→            .defer_until = defer_until,\n   101→        });\n   102→    } else {\n   103→        if (defer_until) |until| {\n   104→            var buf: [timestamp.RFC3339_BUFFER_SIZE]u8 = undefined;\n   105→            const formatted = timestamp.formatRfc3339(until, &buf) catch \"unknown\";\n   106→            try ctx.output.success(\"Deferred issue {s} until {s}\", .{ defer_args.id, formatted });\n   107→        } else {\n   108→            try ctx.output.success(\"Deferred issue {s} indefinitely\", .{defer_args.id});\n   109→        }\n   110→    }\n   111→}\n   112→\n   113→pub fn runUndefer(\n   114→    undefer_args: args.UndeferArgs,\n   115→    global: args.GlobalOptions,\n   116→    allocator: std.mem.Allocator,\n   117→) !void {\n   118→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   119→        return DeferError.WorkspaceNotInitialized;\n   120→    };\n   121→    defer ctx.deinit();\n   122→\n   123→    // Find the issue\n   124→    const issue = ctx.store.getRef(undefer_args.id) orelse {\n   125→        if (global.isStructuredOutput()) {\n   126→            try ctx.output.printJson(DeferResult{\n   127→                .success = false,\n   128→                .message = \"issue not found\",\n   129→            });\n   130→        } else {\n   131→            try ctx.output.err(\"issue not found: {s}\", .{undefer_args.id});\n   132→        }\n   133→        return DeferError.IssueNotFound;\n   134→    };\n   135→\n   136→    // Check if not deferred\n   137→    if (!issue.status.eql(.deferred)) {\n   138→        if (global.isStructuredOutput()) {\n   139→            try ctx.output.printJson(DeferResult{\n   140→                .success = false,\n   141→                .id = undefer_args.id,\n   142→                .message = \"issue is not deferred\",\n   143→            });\n   144→        } else {\n   145→            try ctx.output.warn(\"issue {s} is not deferred\", .{undefer_args.id});\n   146→        }\n   147→        return;\n   148→    }\n   149→\n   150→    // Update the issue - set status back to open and clear defer_until\n   151→    const now = std.time.timestamp();\n   152→    try ctx.store.update(undefer_args.id, .{\n   153→        .status = .open,\n   154→        .defer_until = null,\n   155→    }, now);\n   156→\n   157→    try ctx.saveIfAutoFlush();\n   158→\n   159→    // Output result\n   160→    if (global.isStructuredOutput()) {\n   161→        try ctx.output.printJson(DeferResult{\n   162→            .success = true,\n   163→            .id = undefer_args.id,\n   164→        });\n   165→    } else {\n   166→        try ctx.output.success(\"Undeferred issue {s}\", .{undefer_args.id});\n   167→    }\n   168→}\n   169→\n   170→/// Parse an \"until\" date string into an epoch timestamp.\n   171→/// Supports:\n   172→/// - RFC3339: \"2025-02-01T00:00:00Z\"\n   173→/// - ISO date: \"2025-02-01\"\n   174→/// - Relative: \"+7d\" (7 days from now), \"+2w\" (2 weeks), \"+1m\" (1 month)\n   175→fn parseUntilDate(s: []const u8, allocator: std.mem.Allocator) !i64 {\n   176→    // Try RFC3339 first\n   177→    if (timestamp.parseRfc3339(s)) |ts| {\n   178→        return ts;\n   179→    }\n   180→\n   181→    // Try ISO date (YYYY-MM-DD)\n   182→    if (s.len == 10 and s[4] == '-' and s[7] == '-') {\n   183→        const with_time = try std.fmt.allocPrint(allocator, \"{s}T00:00:00Z\", .{s});\n   184→        defer allocator.free(with_time);\n   185→        if (timestamp.parseRfc3339(with_time)) |ts| {\n   186→            return ts;\n   187→        }\n   188→    }\n   189→\n   190→    // Try relative format (+Nd, +Nw, +Nm)\n   191→    if (s.len >= 2 and s[0] == '+') {\n   192→        const unit = s[s.len - 1];\n   193→        const count_str = s[1 .. s.len - 1];\n   194→        const count = std.fmt.parseInt(i64, count_str, 10) catch return DeferError.InvalidDate;\n   195→\n   196→        const now = std.time.timestamp();\n   197→        return switch (unit) {\n   198→            'd' => now + count * 24 * 60 * 60,\n   199→            'w' => now + count * 7 * 24 * 60 * 60,\n   200→            'm' => now + count * 30 * 24 * 60 * 60, // Approximate month\n   201→            else => return DeferError.InvalidDate,\n   202→        };\n   203→    }\n   204→\n   205→    return DeferError.InvalidDate;\n   206→}\n   207→\n   208→test \"parseUntilDate parses RFC3339\" {\n   209→    const ts = try parseUntilDate(\"2025-02-01T12:00:00Z\", std.testing.allocator);\n   210→    try std.testing.expect(ts > 0);\n   211→}\n   212→\n   213→test \"parseUntilDate parses ISO date\" {\n   214→    const ts = try parseUntilDate(\"2025-02-01\", std.testing.allocator);\n   215→    try std.testing.expect(ts > 0);\n   216→}\n   217→\n   218→test \"parseUntilDate parses relative days\" {\n   219→    const now = std.time.timestamp();\n   220→    const ts = try parseUntilDate(\"+7d\", std.testing.allocator);\n   221→    // Should be approximately 7 days in the future\n   222→    try std.testing.expect(ts > now);\n   223→    try std.testing.expect(ts < now + 8 * 24 * 60 * 60);\n   224→}\n   225→\n   226→test \"parseUntilDate parses relative weeks\" {\n   227→    const now = std.time.timestamp();\n   228→    const ts = try parseUntilDate(\"+2w\", std.testing.allocator);\n   229→    // Should be approximately 2 weeks in the future\n   230→    try std.testing.expect(ts > now);\n   231→    try std.testing.expect(ts < now + 15 * 24 * 60 * 60);\n   232→}\n   233→\n   234→test \"parseUntilDate rejects invalid format\" {\n   235→    try std.testing.expectError(DeferError.InvalidDate, parseUntilDate(\"invalid\", std.testing.allocator));\n   236→}\n   237→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"2aaac7dd-5f69-49ea-a09a-64780fdead6a"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01XrzQzz6PXNX4VTRMkXzgqN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LF3SfenrEMqWs74fL97T55","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","offset":430,"limit":80}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4761,"cache_read_input_tokens":38454,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4761},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"5a288181-b22d-43aa-8ae8-4c49bc0aa135"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LF3SfenrEMqWs74fL97T55","type":"tool_result","content":"   430→                if (issue.notes) |notes| {\n   431→                    if (!containsIgnoreCase(notes, query)) continue;\n   432→                } else continue;\n   433→            }\n   434→\n   435→            try results.append(self.allocator, try issue.clone(self.allocator));\n   436→        }\n   437→\n   438→        // Sort\n   439→        const SortContext = struct {\n   440→            order_by: ListFilters.OrderBy,\n   441→            order_desc: bool,\n   442→        };\n   443→        const ctx = SortContext{ .order_by = filters.order_by, .order_desc = filters.order_desc };\n   444→\n   445→        std.mem.sortUnstable(Issue, results.items, ctx, struct {\n   446→            fn lessThan(c: SortContext, a: Issue, b: Issue) bool {\n   447→                const cmp: i64 = switch (c.order_by) {\n   448→                    .created_at => a.created_at.value - b.created_at.value,\n   449→                    .updated_at => a.updated_at.value - b.updated_at.value,\n   450→                    .priority => @as(i64, a.priority.value) - @as(i64, b.priority.value),\n   451→                };\n   452→                return if (c.order_desc) cmp > 0 else cmp < 0;\n   453→            }\n   454→        }.lessThan);\n   455→\n   456→        // Apply offset and limit\n   457→        var start: usize = 0;\n   458→        if (filters.offset) |off| {\n   459→            start = @min(off, results.items.len);\n   460→        }\n   461→\n   462→        var end: usize = results.items.len;\n   463→        if (filters.limit) |lim| {\n   464→            end = @min(start + lim, results.items.len);\n   465→        }\n   466→\n   467→        // Free items outside the range\n   468→        for (results.items[0..start]) |*issue| {\n   469→            issue.deinit(self.allocator);\n   470→        }\n   471→        for (results.items[end..]) |*issue| {\n   472→            issue.deinit(self.allocator);\n   473→        }\n   474→\n   475→        // Return slice\n   476→        const slice = try self.allocator.dupe(Issue, results.items[start..end]);\n   477→        results.deinit(self.allocator);\n   478→        return slice;\n   479→    }\n   480→\n   481→    /// Result from counting issues.\n   482→    pub const CountResult = struct {\n   483→        key: []const u8,\n   484→        count: u64,\n   485→    };\n   486→\n   487→    /// Count issues, optionally grouped by a field.\n   488→    pub fn count(self: *Self, group_by: ?GroupBy) ![]CountResult {\n   489→        var counts: std.StringHashMapUnmanaged(u64) = .{};\n   490→        defer counts.deinit(self.allocator);\n   491→\n   492→        for (self.issues.items) |issue| {\n   493→            if (statusEql(issue.status, .tombstone)) continue;\n   494→\n   495→            const key_str: []const u8 = if (group_by) |g| switch (g) {\n   496→                .status => issue.status.toString(),\n   497→                .priority => switch (issue.priority.value) {\n   498→                    0 => \"0\",\n   499→                    1 => \"1\",\n   500→                    2 => \"2\",\n   501→                    3 => \"3\",\n   502→                    4 => \"4\",\n   503→                    else => unreachable,\n   504→                },\n   505→                .issue_type => issue.issue_type.toString(),\n   506→                .assignee => issue.assignee orelse \"(unassigned)\",\n   507→            } else \"total\";\n   508→\n   509→            const entry = counts.getOrPutValue(self.allocator, key_str, 0) catch continue;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"5ee45498-6e47-4714-8946-1d86aa89a199"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01XrzQzz6PXNX4VTRMkXzgqN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EZPxYRrU1RLBskqmVpTUS1","name":"Bash","input":{"command":"grep -n \"defer_until\\|due_at\" /home/hotschmoe/beads_zig/src/cli/list.zig /home/hotschmoe/beads_zig/src/cli/ready.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4761,"cache_read_input_tokens":38454,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4761},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"eea89199-819a-4ff2-897e-d93102ed49d3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EZPxYRrU1RLBskqmVpTUS1","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"4348a8bb-9a5e-477c-b68d-50deff1eef1e"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01NpM8Sm4h26DfjWuVe87jRM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014yjW2vV4XNzxChV1dtpdcu","name":"Bash","input":{"command":"grep -n \"getReadyIssues\\|getBlockedIssues\\|getBlockers\" /home/hotschmoe/beads_zig/src/storage/graph.zig | head -20"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1499,"cache_read_input_tokens":43215,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1499},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"2f558ad5-d40d-4ec4-aa57-7e901f9d9dd3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014yjW2vV4XNzxChV1dtpdcu","type":"tool_result","content":"282:    pub fn getReadyIssues(self: *Self) ![]Issue {\n333:    pub fn getBlockedIssues(self: *Self) ![]Issue {\n377:    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue {\n571:test \"DependencyGraph getReadyIssues excludes blocked\" {\n592:    const ready = try graph.getReadyIssues();\n603:test \"DependencyGraph getReadyIssues includes when blocker closed\" {\n625:    const ready = try graph.getReadyIssues();\n632:test \"DependencyGraph getBlockedIssues returns only blocked\" {\n653:    const blocked = try graph.getBlockedIssues();","is_error":false}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"d1490ee5-3ada-467b-8265-131a5b477127"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01NpM8Sm4h26DfjWuVe87jRM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JxyntrmUE1SBtvw1YRCHa8","name":"Grep","input":{"pattern":"pub fn getReadyIssues|pub fn getBlockedIssues","path":"/home/hotschmoe/beads_zig/src/storage/graph.zig","output_mode":"content","context":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1499,"cache_read_input_tokens":43215,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1499},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"a2e1d9a1-5a80-4123-add0-03824f3d2163"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JxyntrmUE1SBtvw1YRCHa8","type":"tool_result","content":"262-            return false;\n263-        };\n264-\n265-        for (issue.dependencies) |dep| {\n266-            if (!visited.contains(dep.depends_on_id)) {\n267-                if (try self.detectCycleDfs(dep.depends_on_id, visited, rec_stack, path)) {\n268-                    return true;\n269-                }\n270-            } else if (rec_stack.contains(dep.depends_on_id)) {\n271-                try path.append(self.allocator, dep.depends_on_id);\n272-                return true;\n273-            }\n274-        }\n275-\n276-        _ = rec_stack.remove(node);\n277-        _ = path.pop();\n278-        return false;\n279-    }\n280-\n281-    /// Get all issues that are ready (open, not blocked by open issues, not deferred).\n282:    pub fn getReadyIssues(self: *Self) ![]Issue {\n283-        const now = std.time.timestamp();\n284-\n285-        var results: std.ArrayListUnmanaged(Issue) = .{};\n286-        errdefer {\n287-            for (results.items) |*issue| {\n288-                issue.deinit(self.allocator);\n289-            }\n290-            results.deinit(self.allocator);\n291-        }\n292-\n293-        for (self.store.getAllRef()) |issue| {\n294-            // Must be open\n295-            if (!statusEql(issue.status, .open)) continue;\n296-\n297-            // Must not be deferred to future\n298-            if (issue.defer_until.value) |defer_time| {\n299-                if (defer_time > now) continue;\n300-            }\n301-\n302-            // Must not have any open blockers\n--\n313-            }\n314-            if (has_open_blocker) continue;\n315-\n316-            try results.append(self.allocator, try issue.clone(self.allocator));\n317-        }\n318-\n319-        // Sort by priority then created_at\n320-        std.mem.sortUnstable(Issue, results.items, {}, struct {\n321-            fn lessThan(_: void, a: Issue, b: Issue) bool {\n322-                if (a.priority.value != b.priority.value) {\n323-                    return a.priority.value < b.priority.value;\n324-                }\n325-                return a.created_at.value < b.created_at.value;\n326-            }\n327-        }.lessThan);\n328-\n329-        return results.toOwnedSlice(self.allocator);\n330-    }\n331-\n332-    /// Get all blocked issues (open issues with unresolved dependencies).\n333:    pub fn getBlockedIssues(self: *Self) ![]Issue {\n334-        var results: std.ArrayListUnmanaged(Issue) = .{};\n335-        errdefer {\n336-            for (results.items) |*issue| {\n337-                issue.deinit(self.allocator);\n338-            }\n339-            results.deinit(self.allocator);\n340-        }\n341-\n342-        for (self.store.getAllRef()) |issue| {\n343-            // Must be open\n344-            if (!statusEql(issue.status, .open)) continue;\n345-\n346-            // Must have at least one open blocker\n347-            var has_open_blocker = false;\n348-            for (issue.dependencies) |dep| {\n349-                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n350-                    if (!statusEql(blocker.status, .closed) and\n351-                        !statusEql(blocker.status, .tombstone))\n352-                    {\n353-                        has_open_blocker = true;"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"51cd8906-8ec8-4bcf-bd67-15f95d95db20"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0151pQahfQESrSqDJhWCpwj8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QCvByY5MGUZdgqasVKeKxM","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","offset":865,"limit":25}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1506,"cache_read_input_tokens":44714,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1506},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"5a41c58c-9762-43b4-9785-1e1b9c7f40d8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QCvByY5MGUZdgqasVKeKxM","type":"tool_result","content":"   865→pub fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {\n   866→    if (needle.len == 0) return true;\n   867→    if (needle.len > haystack.len) return false;\n   868→\n   869→    const end = haystack.len - needle.len + 1;\n   870→    var i: usize = 0;\n   871→    while (i < end) : (i += 1) {\n   872→        var match = true;\n   873→        for (needle, 0..) |nc, j| {\n   874→            const hc = haystack[i + j];\n   875→            if (std.ascii.toLower(hc) != std.ascii.toLower(nc)) {\n   876→                match = false;\n   877→                break;\n   878→            }\n   879→        }\n   880→        if (match) return true;\n   881→    }\n   882→    return false;\n   883→}\n   884→\n   885→fn cloneStatus(status: Status, allocator: std.mem.Allocator) !Status {\n   886→    return switch (status) {\n   887→        .custom => |s| Status{ .custom = try allocator.dupe(u8, s) },\n   888→        else => status,\n   889→    };\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"59bdbcc0-1199-43a8-a3c8-ca8dc8b64cc4"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0151pQahfQESrSqDJhWCpwj8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014S9NXzkbhPdw8VH5nw1LLp","name":"Bash","input":{"command":"head -50 /home/hotschmoe/beads_zig/src/cli/common.zig | tail -30"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1506,"cache_read_input_tokens":44714,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1506},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"37fb856c-314a-44cf-8678-23f9c3f7fcf4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014S9NXzkbhPdw8VH5nw1LLp","type":"tool_result","content":"    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\n/// Context for executing a CLI command with an initialized workspace.\npub const CommandContext = struct {\n    allocator: std.mem.Allocator,\n    output: Output,\n    store: IssueStore,\n    event_store: EventStore,\n    beads_dir: []const u8,\n    issues_path: []const u8,\n    events_path: []const u8,\n    global: args.GlobalOptions,\n    /// Number of corrupt entries skipped during load.\n    corruption_count: usize = 0,\n    /// Line numbers of corrupt JSONL entries (owned memory).\n    corrupt_lines: []const usize = &.{},\n    /// Number of WAL entries replayed during load.\n    wal_entries_replayed: usize = 0,\n\n    /// Initialize a command context by loading the workspace.\n    /// Returns null and outputs an error if workspace is not initialized.\n    /// Uses graceful corruption recovery: logs and skips corrupt entries.\n    /// Replays WAL entries after loading main file for consistency.\n    pub fn init(\n        allocator: std.mem.Allocator,\n        global: args.GlobalOptions,\n    ) CommandError!?CommandContext {","is_error":false}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"ddcacf8c-d582-4605-93b2-4053330d6ee5"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DBFL3eKS9BchaUjMGo26rZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014cigwkKJvuPTNpCKNhKkDa","name":"Bash","input":{"command":"grep -n \"OptionalRfc3339Timestamp\\|Rfc3339Timestamp\" /home/hotschmoe/beads_zig/src/models/timestamp.zig | head -20"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1008,"cache_read_input_tokens":46220,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1008},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"04b684e9-3386-4403-9e08-6247a9c196ca"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014cigwkKJvuPTNpCKNhKkDa","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"4c53c429-60ec-458b-9b04-154a0ee8c362"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01EqWWcxttCyu22PAA7bdkLq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FGd8X7PFd9mpAFP9LHYkiA","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/models/timestamp.zig","offset":1,"limit":80}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":280,"cache_read_input_tokens":47228,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":280},"output_tokens":18,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"c2617128-8227-4a8c-a8cd-36fd1a78028a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FGd8X7PFd9mpAFP9LHYkiA","type":"tool_result","content":"     1→//! RFC3339 timestamp utilities for JSONL compatibility.\n     2→//!\n     3→//! Timestamps are stored internally as Unix epoch seconds (i64) but serialized\n     4→//! to JSON as RFC3339 UTC strings for JSONL export compatibility with beads_rust.\n     5→//!\n     6→//! Example formats:\n     7→//! - \"2024-01-29T15:30:00Z\" (UTC with Z suffix)\n     8→//! - \"2024-01-29T15:30:00+00:00\" (UTC with explicit offset)\n     9→//! - \"2024-01-29T15:30:00.123Z\" (with fractional seconds, ignored on parse)\n    10→//! - \"2024-01-29T15:30:00-05:00\" (with timezone offset)\n    11→\n    12→const std = @import(\"std\");\n    13→\n    14→pub const TimestampError = error{\n    15→    InvalidFormat,\n    16→    InvalidDate,\n    17→    InvalidTime,\n    18→    InvalidTimezone,\n    19→    BufferTooSmall,\n    20→};\n    21→\n    22→/// RFC3339 timestamp length: \"YYYY-MM-DDTHH:MM:SSZ\" = 20 chars\n    23→pub const RFC3339_LEN: usize = 20;\n    24→\n    25→/// Minimum buffer size for formatRfc3339\n    26→pub const RFC3339_BUFFER_SIZE: usize = 25;\n    27→\n    28→/// Parse RFC3339 timestamp string to Unix epoch seconds.\n    29→///\n    30→/// Accepts formats:\n    31→/// - \"2024-01-29T15:30:00Z\" (UTC)\n    32→/// - \"2024-01-29T15:30:00+HH:MM\" (positive offset)\n    33→/// - \"2024-01-29T15:30:00-HH:MM\" (negative offset)\n    34→/// - \"2024-01-29T15:30:00.NNNZ\" (with fractional seconds, ignored)\n    35→///\n    36→/// Returns null for invalid input (for compatibility with existing code).\n    37→pub fn parseRfc3339(s: []const u8) ?i64 {\n    38→    return parseRfc3339Strict(s) catch null;\n    39→}\n    40→\n    41→/// Parse RFC3339 timestamp string to Unix epoch seconds.\n    42→/// Returns a detailed error for invalid input.\n    43→pub fn parseRfc3339Strict(s: []const u8) TimestampError!i64 {\n    44→    if (s.len < 20) return TimestampError.InvalidFormat;\n    45→\n    46→    // Parse date: YYYY-MM-DD\n    47→    const year = std.fmt.parseInt(i32, s[0..4], 10) catch return TimestampError.InvalidFormat;\n    48→    if (s[4] != '-') return TimestampError.InvalidFormat;\n    49→    const month = std.fmt.parseInt(u8, s[5..7], 10) catch return TimestampError.InvalidFormat;\n    50→    if (s[7] != '-') return TimestampError.InvalidFormat;\n    51→    const day = std.fmt.parseInt(u8, s[8..10], 10) catch return TimestampError.InvalidFormat;\n    52→\n    53→    // Validate date components\n    54→    if (month < 1 or month > 12) return TimestampError.InvalidDate;\n    55→    if (day < 1 or day > daysInMonth(year, month)) return TimestampError.InvalidDate;\n    56→\n    57→    // Parse time separator\n    58→    if (s[10] != 'T' and s[10] != 't') return TimestampError.InvalidFormat;\n    59→\n    60→    // Parse time: HH:MM:SS\n    61→    const hour = std.fmt.parseInt(u8, s[11..13], 10) catch return TimestampError.InvalidFormat;\n    62→    if (s[13] != ':') return TimestampError.InvalidFormat;\n    63→    const minute = std.fmt.parseInt(u8, s[14..16], 10) catch return TimestampError.InvalidFormat;\n    64→    if (s[16] != ':') return TimestampError.InvalidFormat;\n    65→    const second = std.fmt.parseInt(u8, s[17..19], 10) catch return TimestampError.InvalidFormat;\n    66→\n    67→    // Validate time components\n    68→    if (hour > 23) return TimestampError.InvalidTime;\n    69→    if (minute > 59) return TimestampError.InvalidTime;\n    70→    if (second > 59) return TimestampError.InvalidTime;\n    71→\n    72→    // Parse timezone offset\n    73→    var pos: usize = 19;\n    74→\n    75→    // Skip fractional seconds if present (.NNN)\n    76→    if (pos < s.len and s[pos] == '.') {\n    77→        pos += 1;\n    78→        while (pos < s.len and std.ascii.isDigit(s[pos])) {\n    79→            pos += 1;\n    80→        }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"90c1714d-759e-4287-b098-a432ea2c2c0c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JtB2BaE4Enbex9YHBM3YRZ","type":"tool_result","content":[{"type":"text","text":"Perfect! Now I have all the information needed. Let me create a comprehensive analysis document.\n\n## Summary: List and Ready Commands Filtering in beads_zig\n\nBased on my thorough exploration of the codebase, here's a complete understanding of how list and ready commands handle filtering:\n\n---\n\n### 1. WHERE LIST AND READY COMMANDS ARE IMPLEMENTED\n\n**File Locations:**\n- **List command:** `/home/hotschmoe/beads_zig/src/cli/list.zig` (219 lines)\n- **Ready/Blocked commands:** `/home/hotschmoe/beads_zig/src/cli/ready.zig` (330 lines)\n- **Argument parsing:** `/home/hotschmoe/beads_zig/src/cli/args.zig` (lines 217-243 for structures, 1024-1110 for parsing)\n- **Storage filtering logic:** `/home/hotschmoe/beads_zig/src/storage/store.zig` (lines 331-479 for ListFilters)\n- **Graph-based ready/blocked logic:** `/home/hotschmoe/beads_zig/src/storage/graph.zig` (lines 282-376)\n\n---\n\n### 2. HOW EXISTING FILTERS WORK\n\n#### **List Command Filters** (`ListArgs` struct at args.zig:217-233)\n\nThe list command supports these flags:\n\n```\n--status / -s          Filter by status (e.g., \"open\", \"closed\", \"deferred\")\n--priority / -p        Filter by exact priority level\n--priority-min         Filter by minimum priority (lower value = higher priority)\n--priority-max         Filter by maximum priority\n--type / -t            Filter by issue type\n--assignee / -a        Filter by assignee name\n--label / -l           Exact label match (single label)\n--label-any            Multiple OR'ed labels (any one must match)\n--title-contains       Substring search in title (case-insensitive)\n--desc-contains        Substring search in description\n--notes-contains       Substring search in notes\n--limit / -n           Limit number of results\n--all / -A             Include all statuses (default: open only)\n--sort                 Sort by: created_at (default), updated_at, priority\n--asc / --desc         Sort direction\n```\n\n**Key Behaviors in list.zig (lines 53-120):**\n- If `--status` not provided and NOT `--all`, defaults to `.open` status\n- Priority range filters use `>=` and `<=` logic (lines 68-80)\n- Label filtering uses exact match (line 91)\n- `label_any` uses OR logic - issue must have AT LEAST ONE of specified labels (line 94-96)\n- Substring filters are case-insensitive using `containsIgnoreCase()` helper (lines 98-108)\n- Sorting applied via comparator in store.zig with `order_by` and `order_desc` fields\n\n#### **Ready Command Filters** (`ReadyArgs` struct at args.zig:236-243)\n\n```\n--priority-min         Minimum priority filter\n--priority-max         Maximum priority filter\n--title-contains       Substring search in title (case-insensitive)\n--desc-contains        Substring search in description\n--notes-contains       Substring search in notes\n--limit / -n           Limit number of results\n```\n\n**Note:** Ready command does NOT have status, type, label, or assignee filters - it only returns \"ready\" issues with optional priority and text filtering.\n\n#### **Blocked Command Filters** (`BlockedArgs` struct at args.zig:246-253)\n\nSame as ready (no status/type/label filtering).\n\n---\n\n### 3. HOW THE ARGUMENT PARSER HANDLES FILTER FLAGS\n\n**Parser structure in args.zig:**\n\n1. **Command dispatch** (line 708-715): Routes to appropriate parser\n   ```zig\n   if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n       return .{ .list = try self.parseListArgs() };\n   }\n   if (std.mem.eql(u8, cmd, \"ready\")) {\n       return .{ .ready = try self.parseReadyArgs() };\n   }\n   if (std.mem.eql(u8, cmd, \"blocked\")) {\n       return .{ .blocked = try self.parseBlockedArgs() };\n   }\n   ```\n\n2. **parseListArgs()** (lines 1024-1070):\n   - Uses a loop calling `hasNext()` and `consumeFlag()` to check for flags\n   - Builds `label_any_list` as an `ArrayListUnmanaged` then converts to owned slice (line 1065-1066)\n   - Priority parsing converts string values to `Priority` enum using `Priority.fromString()` with error handling (lines 1031-1036)\n   - Sort field parsing uses `SortField.fromString()` (line 1057)\n\n3. **parseReadyArgs()** (lines 1072-1090) and **parseBlockedArgs()** (lines 1092-1110):\n   - Simpler parsers, only handle priority range and text filters\n   - Same error handling pattern as list command\n\n**Key parsing utilities:**\n- `consumeFlag(short_name, long_name)` - Checks if flag is present and consumes it\n- `next()` - Gets the next argument value\n- `parseLimitFlag()` - Helper for `-n` / `--limit` parsing\n\n---\n\n### 4. DUE_AT AND DEFER_UNTIL FIELDS - CURRENT USAGE\n\n#### **Field Definitions** (models/issue.zig:136-137)\n\n```zig\ndue_at: OptionalRfc3339Timestamp,\ndefer_until: OptionalRfc3339Timestamp,\nestimated_minutes: ?i32,\n```\n\nBoth store Unix epoch seconds internally, serialized as RFC3339 strings in JSONL.\n\n#### **Current Usage:**\n\n**Defer/Undefer Commands** (`defer.zig`):\n- `defer <id> [--until <date>] [--reason <reason>]` - Sets `defer_until` timestamp\n- Supports multiple date formats:\n  - RFC3339: `\"2025-02-01T12:00:00Z\"`\n  - ISO date: `\"2025-02-01\"`\n  - Relative: `\"+7d\"`, `\"+2w\"`, `\"+1m\"` (parseUntilDate() at defer.zig:175-206)\n- Sets status to `.deferred` when deferring\n\n**Ready Command Logic** (graph.zig:282-330):\n- **Checks `defer_until` to filter out deferred issues** (lines 298-300):\n  ```zig\n  if (issue.defer_until.value) |defer_time| {\n      if (defer_time > now) continue;\n  }\n  ```\n- Only includes open issues that are NOT deferred to future dates\n- Sorts by priority (ascending), then created_at (ascending)\n\n**Blocked Command Logic** (graph.zig:333-376):\n- Does NOT explicitly check `defer_until`\n- Only checks for open blockers, doesn't filter based on defer status\n\n**List Command:**\n- **NO FILTERING on due_at or defer_until** - These fields are not currently used as filters\n- Filters only by: status, priority, type, assignee, labels, substrings\n\n**Undefer Command**:\n- Sets issue status back to `.open` and clears `defer_until` to null (defer.zig:152-155)\n\n---\n\n### 5. FILTERING FLOW SUMMARY\n\n#### **List Command Flow (list.zig:43-156):**\n```\n1. Parse ListArgs from CLI\n2. Create ListFilters struct with parsed values\n3. Call ctx.store.list(filters) [store.zig:357-479]\n   - Iterate all issues in memory\n   - Filter by: status, priority ranges, type, assignee, labels (exact + any), substrings\n   - Skip tombstones unless explicitly included\n   - Apply sort (created_at/updated_at/priority, ascending/descending)\n   - Apply limit and offset\n4. Format output (JSON or rich text)\n```\n\n#### **Ready Command Flow (ready.zig:55-113):**\n```\n1. Parse ReadyArgs from CLI\n2. Create DependencyGraph from store\n3. Call graph.getReadyIssues() [graph.zig:282-330]\n   - Filter to open issues only\n   - EXCLUDE if defer_until > now\n   - EXCLUDE if has open blocker\n   - Sort by priority (ascending), created_at (ascending)\n4. Apply filters: priority range + text substrings (ready.zig:86)\n   - Uses applyFilters() helper (lines 215-260)\n5. Apply limit\n6. Format output\n```\n\n---\n\n### 6. KEY FILTERING IMPLEMENTATION DETAILS\n\n#### **Store.ListFilters Structure** (store.zig:331-354)\n\n```zig\npub const ListFilters = struct {\n    status: ?Status = null,\n    priority: ?Priority = null,\n    priority_min: ?Priority = null,\n    priority_max: ?Priority = null,\n    issue_type: ?IssueType = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    include_tombstones: bool = false,\n    limit: ?u32 = null,\n    offset: ?u32 = null,\n    order_by: OrderBy = .created_at,\n    order_desc: bool = true,\n};\n```\n\n#### **Substring Filtering** (store.zig:865-883)\n\nThe `containsIgnoreCase()` function:\n- Case-insensitive substring matching\n- Returns true if needle is empty (any string matches)\n- Returns false if needle longer than haystack\n- Uses ASCII lowercase for comparison\n\n```zig\npub fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {\n    if (needle.len == 0) return true;\n    if (needle.len > haystack.len) return false;\n    \n    const end = haystack.len - needle.len + 1;\n    var i: usize = 0;\n    while (i < end) : (i += 1) {\n        var match = true;\n        for (needle, 0..) |nc, j| {\n            const hc = haystack[i + j];\n            if (std.ascii.toLower(hc) != std.ascii.toLower(nc)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n```\n\n#### **Priority Range Logic** (store.zig:413-418)\n\n- `priority_min`: Lower value (higher priority) cutoff - issues with LOWER priority value continue\n- `priority_max`: Upper value (lower priority) cutoff - issues with HIGHER priority value continue\n- Priority values: 0 (highest) to 4 (lowest)\n- Range filter: `priority_min <= issue.priority <= priority_max`\n\n#### **Label Filtering Logic** (store.zig:386-410)\n\n- **Exact label** (single match required):\n  ```zig\n  for (issue.labels) |label| {\n      if (std.mem.eql(u8, label, lbl)) {\n          found = true; break;\n      }\n  }\n  if (!found) continue;\n  ```\n\n- **Label_any** (OR logic - any one label must match):\n  ```zig\n  for (filters.label_any) |any_label| {\n      for (issue.labels) |issue_label| {\n          if (std.mem.eql(u8, issue_label, any_label)) {\n              found_any = true; break;\n          }\n      }\n      if (found_any) break;\n  }\n  if (!found_any) continue;\n  ```\n\n---\n\n### 7. WHAT'S NOT CURRENTLY FILTERED\n\n- **due_at:** Field exists but has NO filtering in list/ready/blocked commands\n- **defer_until:** Only implicitly used in ready command to exclude future-deferred issues\n- **Can't filter by:** due date ranges, deferred status, estimated time, external references\n- **List command:** Doesn't check `defer_until` at all (unlike ready command)\n\nThis represents opportunities for enhancement if you want to add due-date-based filtering or deferred-status filtering to the list command."},{"type":"text","text":"agentId: add0991 (for resuming to continue this agent's work if needed)"}]}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"6060a23b-a3c8-457f-b40b-9c95973eb211","tool_use_result":{"status":"completed","prompt":"Find how list and ready commands handle filtering in beads_zig. I need to understand:\n1. Where list and ready commands are implemented (likely in src/cli/)\n2. How existing filters like --status, --priority work\n3. How the argument parser handles filter flags\n4. How due_at and defer_until fields are used currently\n\nFocus on src/cli/list.zig, src/cli/ready.zig, src/cli/args.zig, and any related filtering logic.","agentId":"add0991","content":[{"type":"text","text":"Perfect! Now I have all the information needed. Let me create a comprehensive analysis document.\n\n## Summary: List and Ready Commands Filtering in beads_zig\n\nBased on my thorough exploration of the codebase, here's a complete understanding of how list and ready commands handle filtering:\n\n---\n\n### 1. WHERE LIST AND READY COMMANDS ARE IMPLEMENTED\n\n**File Locations:**\n- **List command:** `/home/hotschmoe/beads_zig/src/cli/list.zig` (219 lines)\n- **Ready/Blocked commands:** `/home/hotschmoe/beads_zig/src/cli/ready.zig` (330 lines)\n- **Argument parsing:** `/home/hotschmoe/beads_zig/src/cli/args.zig` (lines 217-243 for structures, 1024-1110 for parsing)\n- **Storage filtering logic:** `/home/hotschmoe/beads_zig/src/storage/store.zig` (lines 331-479 for ListFilters)\n- **Graph-based ready/blocked logic:** `/home/hotschmoe/beads_zig/src/storage/graph.zig` (lines 282-376)\n\n---\n\n### 2. HOW EXISTING FILTERS WORK\n\n#### **List Command Filters** (`ListArgs` struct at args.zig:217-233)\n\nThe list command supports these flags:\n\n```\n--status / -s          Filter by status (e.g., \"open\", \"closed\", \"deferred\")\n--priority / -p        Filter by exact priority level\n--priority-min         Filter by minimum priority (lower value = higher priority)\n--priority-max         Filter by maximum priority\n--type / -t            Filter by issue type\n--assignee / -a        Filter by assignee name\n--label / -l           Exact label match (single label)\n--label-any            Multiple OR'ed labels (any one must match)\n--title-contains       Substring search in title (case-insensitive)\n--desc-contains        Substring search in description\n--notes-contains       Substring search in notes\n--limit / -n           Limit number of results\n--all / -A             Include all statuses (default: open only)\n--sort                 Sort by: created_at (default), updated_at, priority\n--asc / --desc         Sort direction\n```\n\n**Key Behaviors in list.zig (lines 53-120):**\n- If `--status` not provided and NOT `--all`, defaults to `.open` status\n- Priority range filters use `>=` and `<=` logic (lines 68-80)\n- Label filtering uses exact match (line 91)\n- `label_any` uses OR logic - issue must have AT LEAST ONE of specified labels (line 94-96)\n- Substring filters are case-insensitive using `containsIgnoreCase()` helper (lines 98-108)\n- Sorting applied via comparator in store.zig with `order_by` and `order_desc` fields\n\n#### **Ready Command Filters** (`ReadyArgs` struct at args.zig:236-243)\n\n```\n--priority-min         Minimum priority filter\n--priority-max         Maximum priority filter\n--title-contains       Substring search in title (case-insensitive)\n--desc-contains        Substring search in description\n--notes-contains       Substring search in notes\n--limit / -n           Limit number of results\n```\n\n**Note:** Ready command does NOT have status, type, label, or assignee filters - it only returns \"ready\" issues with optional priority and text filtering.\n\n#### **Blocked Command Filters** (`BlockedArgs` struct at args.zig:246-253)\n\nSame as ready (no status/type/label filtering).\n\n---\n\n### 3. HOW THE ARGUMENT PARSER HANDLES FILTER FLAGS\n\n**Parser structure in args.zig:**\n\n1. **Command dispatch** (line 708-715): Routes to appropriate parser\n   ```zig\n   if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n       return .{ .list = try self.parseListArgs() };\n   }\n   if (std.mem.eql(u8, cmd, \"ready\")) {\n       return .{ .ready = try self.parseReadyArgs() };\n   }\n   if (std.mem.eql(u8, cmd, \"blocked\")) {\n       return .{ .blocked = try self.parseBlockedArgs() };\n   }\n   ```\n\n2. **parseListArgs()** (lines 1024-1070):\n   - Uses a loop calling `hasNext()` and `consumeFlag()` to check for flags\n   - Builds `label_any_list` as an `ArrayListUnmanaged` then converts to owned slice (line 1065-1066)\n   - Priority parsing converts string values to `Priority` enum using `Priority.fromString()` with error handling (lines 1031-1036)\n   - Sort field parsing uses `SortField.fromString()` (line 1057)\n\n3. **parseReadyArgs()** (lines 1072-1090) and **parseBlockedArgs()** (lines 1092-1110):\n   - Simpler parsers, only handle priority range and text filters\n   - Same error handling pattern as list command\n\n**Key parsing utilities:**\n- `consumeFlag(short_name, long_name)` - Checks if flag is present and consumes it\n- `next()` - Gets the next argument value\n- `parseLimitFlag()` - Helper for `-n` / `--limit` parsing\n\n---\n\n### 4. DUE_AT AND DEFER_UNTIL FIELDS - CURRENT USAGE\n\n#### **Field Definitions** (models/issue.zig:136-137)\n\n```zig\ndue_at: OptionalRfc3339Timestamp,\ndefer_until: OptionalRfc3339Timestamp,\nestimated_minutes: ?i32,\n```\n\nBoth store Unix epoch seconds internally, serialized as RFC3339 strings in JSONL.\n\n#### **Current Usage:**\n\n**Defer/Undefer Commands** (`defer.zig`):\n- `defer <id> [--until <date>] [--reason <reason>]` - Sets `defer_until` timestamp\n- Supports multiple date formats:\n  - RFC3339: `\"2025-02-01T12:00:00Z\"`\n  - ISO date: `\"2025-02-01\"`\n  - Relative: `\"+7d\"`, `\"+2w\"`, `\"+1m\"` (parseUntilDate() at defer.zig:175-206)\n- Sets status to `.deferred` when deferring\n\n**Ready Command Logic** (graph.zig:282-330):\n- **Checks `defer_until` to filter out deferred issues** (lines 298-300):\n  ```zig\n  if (issue.defer_until.value) |defer_time| {\n      if (defer_time > now) continue;\n  }\n  ```\n- Only includes open issues that are NOT deferred to future dates\n- Sorts by priority (ascending), then created_at (ascending)\n\n**Blocked Command Logic** (graph.zig:333-376):\n- Does NOT explicitly check `defer_until`\n- Only checks for open blockers, doesn't filter based on defer status\n\n**List Command:**\n- **NO FILTERING on due_at or defer_until** - These fields are not currently used as filters\n- Filters only by: status, priority, type, assignee, labels, substrings\n\n**Undefer Command**:\n- Sets issue status back to `.open` and clears `defer_until` to null (defer.zig:152-155)\n\n---\n\n### 5. FILTERING FLOW SUMMARY\n\n#### **List Command Flow (list.zig:43-156):**\n```\n1. Parse ListArgs from CLI\n2. Create ListFilters struct with parsed values\n3. Call ctx.store.list(filters) [store.zig:357-479]\n   - Iterate all issues in memory\n   - Filter by: status, priority ranges, type, assignee, labels (exact + any), substrings\n   - Skip tombstones unless explicitly included\n   - Apply sort (created_at/updated_at/priority, ascending/descending)\n   - Apply limit and offset\n4. Format output (JSON or rich text)\n```\n\n#### **Ready Command Flow (ready.zig:55-113):**\n```\n1. Parse ReadyArgs from CLI\n2. Create DependencyGraph from store\n3. Call graph.getReadyIssues() [graph.zig:282-330]\n   - Filter to open issues only\n   - EXCLUDE if defer_until > now\n   - EXCLUDE if has open blocker\n   - Sort by priority (ascending), created_at (ascending)\n4. Apply filters: priority range + text substrings (ready.zig:86)\n   - Uses applyFilters() helper (lines 215-260)\n5. Apply limit\n6. Format output\n```\n\n---\n\n### 6. KEY FILTERING IMPLEMENTATION DETAILS\n\n#### **Store.ListFilters Structure** (store.zig:331-354)\n\n```zig\npub const ListFilters = struct {\n    status: ?Status = null,\n    priority: ?Priority = null,\n    priority_min: ?Priority = null,\n    priority_max: ?Priority = null,\n    issue_type: ?IssueType = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    include_tombstones: bool = false,\n    limit: ?u32 = null,\n    offset: ?u32 = null,\n    order_by: OrderBy = .created_at,\n    order_desc: bool = true,\n};\n```\n\n#### **Substring Filtering** (store.zig:865-883)\n\nThe `containsIgnoreCase()` function:\n- Case-insensitive substring matching\n- Returns true if needle is empty (any string matches)\n- Returns false if needle longer than haystack\n- Uses ASCII lowercase for comparison\n\n```zig\npub fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {\n    if (needle.len == 0) return true;\n    if (needle.len > haystack.len) return false;\n    \n    const end = haystack.len - needle.len + 1;\n    var i: usize = 0;\n    while (i < end) : (i += 1) {\n        var match = true;\n        for (needle, 0..) |nc, j| {\n            const hc = haystack[i + j];\n            if (std.ascii.toLower(hc) != std.ascii.toLower(nc)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n```\n\n#### **Priority Range Logic** (store.zig:413-418)\n\n- `priority_min`: Lower value (higher priority) cutoff - issues with LOWER priority value continue\n- `priority_max`: Upper value (lower priority) cutoff - issues with HIGHER priority value continue\n- Priority values: 0 (highest) to 4 (lowest)\n- Range filter: `priority_min <= issue.priority <= priority_max`\n\n#### **Label Filtering Logic** (store.zig:386-410)\n\n- **Exact label** (single match required):\n  ```zig\n  for (issue.labels) |label| {\n      if (std.mem.eql(u8, label, lbl)) {\n          found = true; break;\n      }\n  }\n  if (!found) continue;\n  ```\n\n- **Label_any** (OR logic - any one label must match):\n  ```zig\n  for (filters.label_any) |any_label| {\n      for (issue.labels) |issue_label| {\n          if (std.mem.eql(u8, issue_label, any_label)) {\n              found_any = true; break;\n          }\n      }\n      if (found_any) break;\n  }\n  if (!found_any) continue;\n  ```\n\n---\n\n### 7. WHAT'S NOT CURRENTLY FILTERED\n\n- **due_at:** Field exists but has NO filtering in list/ready/blocked commands\n- **defer_until:** Only implicitly used in ready command to exclude future-deferred issues\n- **Can't filter by:** due date ranges, deferred status, estimated time, external references\n- **List command:** Doesn't check `defer_until` at all (unlike ready command)\n\nThis represents opportunities for enhancement if you want to add due-date-based filtering or deferred-status filtering to the list command."}],"totalDurationMs":74618,"totalTokens":49108,"totalToolUseCount":30,"usage":{"input_tokens":4,"cache_creation_input_tokens":1595,"cache_read_input_tokens":47508,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1595},"output_tokens":1,"service_tier":"standard"}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DzoCLebrqdWJWF2YgBhSwZ","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a comprehensive understanding. Let me look at the specific files I need to modify."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3389,"cache_read_input_tokens":38909,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3389},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"8f7295c1-61b2-4c6c-a78a-47a265d81b5f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DzoCLebrqdWJWF2YgBhSwZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T1mwBCEvzEnYjnf25fgNnS","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":210,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3389,"cache_read_input_tokens":38909,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3389},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f4dfd0d3-2d02-4c4f-bc15-4503380fd212"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T1mwBCEvzEnYjnf25fgNnS","type":"tool_result","content":"   210→        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n   211→        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n   212→        return null;\n   213→    }\n   214→};\n   215→\n   216→/// List command arguments.\n   217→pub const ListArgs = struct {\n   218→    status: ?[]const u8 = null,\n   219→    priority: ?[]const u8 = null,\n   220→    priority_min: ?[]const u8 = null,\n   221→    priority_max: ?[]const u8 = null,\n   222→    issue_type: ?[]const u8 = null,\n   223→    assignee: ?[]const u8 = null,\n   224→    label: ?[]const u8 = null,\n   225→    label_any: []const []const u8 = &[_][]const u8{},\n   226→    title_contains: ?[]const u8 = null,\n   227→    desc_contains: ?[]const u8 = null,\n   228→    notes_contains: ?[]const u8 = null,\n   229→    limit: ?u32 = null,\n   230→    all: bool = false,\n   231→    sort: SortField = .created_at,\n   232→    sort_desc: bool = true,\n   233→};\n   234→\n   235→/// Ready command arguments.\n   236→pub const ReadyArgs = struct {\n   237→    limit: ?u32 = null,\n   238→    priority_min: ?[]const u8 = null,\n   239→    priority_max: ?[]const u8 = null,\n   240→    title_contains: ?[]const u8 = null,\n   241→    desc_contains: ?[]const u8 = null,\n   242→    notes_contains: ?[]const u8 = null,\n   243→};\n   244→\n   245→/// Blocked command arguments.\n   246→pub const BlockedArgs = struct {\n   247→    limit: ?u32 = null,\n   248→    priority_min: ?[]const u8 = null,\n   249→    priority_max: ?[]const u8 = null,\n   250→    title_contains: ?[]const u8 = null,\n   251→    desc_contains: ?[]const u8 = null,\n   252→    notes_contains: ?[]const u8 = null,\n   253→};\n   254→\n   255→/// Search command arguments.\n   256→pub const SearchArgs = struct {\n   257→    query: []const u8,\n   258→    limit: ?u32 = null,\n   259→};\n   260→\n   261→/// Stale command arguments.\n   262→pub const StaleArgs = struct {\n   263→    days: u32 = 30,\n   264→    limit: ?u32 = null,\n   265→};\n   266→\n   267→/// Count command arguments.\n   268→pub const CountArgs = struct {\n   269→    group_by: ?[]const u8 = null,\n   270→};\n   271→\n   272→/// Defer command arguments.\n   273→pub const DeferArgs = struct {\n   274→    id: []const u8,\n   275→    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n   276→    reason: ?[]const u8 = null,\n   277→};\n   278→\n   279→/// Undefer command arguments.\n   280→pub const UndeferArgs = struct {\n   281→    id: []const u8,\n   282→};\n   283→\n   284→/// Epic subcommand variants.\n   285→pub const EpicSubcommand = union(enum) {\n   286→    create: struct {\n   287→        title: []const u8,\n   288→        description: ?[]const u8 = null,\n   289→        priority: ?[]const u8 = null,\n   290→    },\n   291→    add: struct {\n   292→        epic_id: []const u8,\n   293→        issue_id: []const u8,\n   294→    },\n   295→    remove: struct {\n   296→        epic_id: []const u8,\n   297→        issue_id: []const u8,\n   298→    },\n   299→    list: struct {\n   300→        epic_id: []const u8,\n   301→    },\n   302→};\n   303→\n   304→/// Epic command arguments.\n   305→pub const EpicArgs = struct {\n   306→    subcommand: EpicSubcommand,\n   307→};\n   308→\n   309→/// Dependency subcommand variants.\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f006de30-f931-4a9e-b905-bd2969706e5a","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.","numLines":100,"startLine":210,"totalLines":2372}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DzoCLebrqdWJWF2YgBhSwZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BwPUEryNkWzW7GatqbMSaH","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/list.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3389,"cache_read_input_tokens":38909,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3389},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"11718c1f-b55f-44f4-a0f5-bde6e267e2b3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BwPUEryNkWzW7GatqbMSaH","type":"tool_result","content":"     1→//! List command for beads_zig.\n     2→//!\n     3→//! `bz list [--status X] [--priority X] [--type X] [--assignee X] [--label X] [-n LIMIT] [--all]`\n     4→//!\n     5→//! Lists issues with optional filters.\n     6→\n     7→const std = @import(\"std\");\n     8→const models = @import(\"../models/mod.zig\");\n     9→const common = @import(\"common.zig\");\n    10→const args = @import(\"args.zig\");\n    11→const test_util = @import(\"../test_util.zig\");\n    12→\n    13→const Issue = models.Issue;\n    14→const Status = models.Status;\n    15→const Priority = models.Priority;\n    16→const IssueType = models.IssueType;\n    17→const IssueStore = common.IssueStore;\n    18→const CommandContext = common.CommandContext;\n    19→\n    20→pub const ListError = error{\n    21→    WorkspaceNotInitialized,\n    22→    InvalidFilter,\n    23→    StorageError,\n    24→    OutOfMemory,\n    25→};\n    26→\n    27→pub const ListResult = struct {\n    28→    success: bool,\n    29→    issues: ?[]const IssueCompact = null,\n    30→    count: ?usize = null,\n    31→    message: ?[]const u8 = null,\n    32→\n    33→    const IssueCompact = struct {\n    34→        id: []const u8,\n    35→        title: []const u8,\n    36→        status: []const u8,\n    37→        priority: u3,\n    38→        issue_type: []const u8,\n    39→        assignee: ?[]const u8 = null,\n    40→    };\n    41→};\n    42→\n    43→pub fn run(\n    44→    list_args: args.ListArgs,\n    45→    global: args.GlobalOptions,\n    46→    allocator: std.mem.Allocator,\n    47→) !void {\n    48→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    49→        return ListError.WorkspaceNotInitialized;\n    50→    };\n    51→    defer ctx.deinit();\n    52→\n    53→    var filters = IssueStore.ListFilters{};\n    54→\n    55→    if (list_args.status) |s| {\n    56→        filters.status = Status.fromString(s);\n    57→    } else if (!list_args.all) {\n    58→        filters.status = .open;\n    59→    }\n    60→\n    61→    if (list_args.priority) |p| {\n    62→        filters.priority = Priority.fromString(p) catch {\n    63→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority value\");\n    64→            return ListError.InvalidFilter;\n    65→        };\n    66→    }\n    67→\n    68→    if (list_args.priority_min) |p| {\n    69→        filters.priority_min = Priority.fromString(p) catch {\n    70→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-min value\");\n    71→            return ListError.InvalidFilter;\n    72→        };\n    73→    }\n    74→\n    75→    if (list_args.priority_max) |p| {\n    76→        filters.priority_max = Priority.fromString(p) catch {\n    77→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-max value\");\n    78→            return ListError.InvalidFilter;\n    79→        };\n    80→    }\n    81→\n    82→    if (list_args.issue_type) |t| {\n    83→        filters.issue_type = IssueType.fromString(t);\n    84→    }\n    85→\n    86→    if (list_args.assignee) |a| {\n    87→        filters.assignee = a;\n    88→    }\n    89→\n    90→    if (list_args.label) |l| {\n    91→        filters.label = l;\n    92→    }\n    93→\n    94→    if (list_args.label_any.len > 0) {\n    95→        filters.label_any = list_args.label_any;\n    96→    }\n    97→\n    98→    if (list_args.title_contains) |t| {\n    99→        filters.title_contains = t;\n   100→    }\n   101→\n   102→    if (list_args.desc_contains) |d| {\n   103→        filters.desc_contains = d;\n   104→    }\n   105→\n   106→    if (list_args.notes_contains) |n| {\n   107→        filters.notes_contains = n;\n   108→    }\n   109→\n   110→    if (list_args.limit) |n| {\n   111→        filters.limit = n;\n   112→    }\n   113→\n   114→    // Apply sort options\n   115→    filters.order_by = switch (list_args.sort) {\n   116→        .created_at => .created_at,\n   117→        .updated_at => .updated_at,\n   118→        .priority => .priority,\n   119→    };\n   120→    filters.order_desc = list_args.sort_desc;\n   121→\n   122→    const issues = try ctx.store.list(filters);\n   123→    defer {\n   124→        for (issues) |*issue| {\n   125→            var i = issue.*;\n   126→            i.deinit(allocator);\n   127→        }\n   128→        allocator.free(issues);\n   129→    }\n   130→\n   131→    if (global.isStructuredOutput()) {\n   132→        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n   133→        defer allocator.free(compact_issues);\n   134→\n   135→        for (issues, 0..) |issue, i| {\n   136→            compact_issues[i] = .{\n   137→                .id = issue.id,\n   138→                .title = issue.title,\n   139→                .status = issue.status.toString(),\n   140→                .priority = issue.priority.value,\n   141→                .issue_type = issue.issue_type.toString(),\n   142→                .assignee = issue.assignee,\n   143→            };\n   144→        }\n   145→\n   146→        try ctx.output.printJson(ListResult{\n   147→            .success = true,\n   148→            .issues = compact_issues,\n   149→            .count = issues.len,\n   150→        });\n   151→    } else {\n   152→        try ctx.output.printIssueList(issues);\n   153→        if (!global.quiet and issues.len == 0) {\n   154→            try ctx.output.info(\"No issues found\", .{});\n   155→        }\n   156→    }\n   157→}\n   158→\n   159→fn outputError(output: *common.Output, structured_mode: bool, message: []const u8) !void {\n   160→    if (structured_mode) {\n   161→        try output.printJson(ListResult{\n   162→            .success = false,\n   163→            .message = message,\n   164→        });\n   165→    } else {\n   166→        try output.err(\"{s}\", .{message});\n   167→    }\n   168→}\n   169→\n   170→// --- Tests ---\n   171→\n   172→test \"ListError enum exists\" {\n   173→    const err: ListError = ListError.WorkspaceNotInitialized;\n   174→    try std.testing.expect(err == ListError.WorkspaceNotInitialized);\n   175→}\n   176→\n   177→test \"ListResult struct works\" {\n   178→    const result = ListResult{\n   179→        .success = true,\n   180→        .count = 5,\n   181→    };\n   182→    try std.testing.expect(result.success);\n   183→    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n   184→}\n   185→\n   186→test \"run detects uninitialized workspace\" {\n   187→    const allocator = std.testing.allocator;\n   188→\n   189→    const list_args = args.ListArgs{};\n   190→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   191→\n   192→    const result = run(list_args, global, allocator);\n   193→    try std.testing.expectError(ListError.WorkspaceNotInitialized, result);\n   194→}\n   195→\n   196→test \"run lists issues successfully\" {\n   197→    const allocator = std.testing.allocator;\n   198→\n   199→    const tmp_dir_path = try test_util.createTestDir(allocator, \"list_success\");\n   200→    defer allocator.free(tmp_dir_path);\n   201→    defer test_util.cleanupTestDir(tmp_dir_path);\n   202→\n   203→    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   204→    defer allocator.free(data_path);\n   205→\n   206→    try std.fs.cwd().makeDir(data_path);\n   207→\n   208→    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   209→    defer allocator.free(issues_path);\n   210→\n   211→    const f = try std.fs.cwd().createFile(issues_path, .{});\n   212→    defer f.close();\n   213→\n   214→    const list_args = args.ListArgs{ .all = true };\n   215→    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   216→\n   217→    try run(list_args, global, allocator);\n   218→}\n   219→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"3645569d-aebf-44a8-ab7c-c12b431b7559","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/list.zig","content":"//! List command for beads_zig.\n//!\n//! `bz list [--status X] [--priority X] [--type X] [--assignee X] [--label X] [-n LIMIT] [--all]`\n//!\n//! Lists issues with optional filters.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Status = models.Status;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const ListError = error{\n    WorkspaceNotInitialized,\n    InvalidFilter,\n    StorageError,\n    OutOfMemory,\n};\n\npub const ListResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        status: []const u8,\n        priority: u3,\n        issue_type: []const u8,\n        assignee: ?[]const u8 = null,\n    };\n};\n\npub fn run(\n    list_args: args.ListArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ListError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var filters = IssueStore.ListFilters{};\n\n    if (list_args.status) |s| {\n        filters.status = Status.fromString(s);\n    } else if (!list_args.all) {\n        filters.status = .open;\n    }\n\n    if (list_args.priority) |p| {\n        filters.priority = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.priority_min) |p| {\n        filters.priority_min = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-min value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.priority_max) |p| {\n        filters.priority_max = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-max value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.issue_type) |t| {\n        filters.issue_type = IssueType.fromString(t);\n    }\n\n    if (list_args.assignee) |a| {\n        filters.assignee = a;\n    }\n\n    if (list_args.label) |l| {\n        filters.label = l;\n    }\n\n    if (list_args.label_any.len > 0) {\n        filters.label_any = list_args.label_any;\n    }\n\n    if (list_args.title_contains) |t| {\n        filters.title_contains = t;\n    }\n\n    if (list_args.desc_contains) |d| {\n        filters.desc_contains = d;\n    }\n\n    if (list_args.notes_contains) |n| {\n        filters.notes_contains = n;\n    }\n\n    if (list_args.limit) |n| {\n        filters.limit = n;\n    }\n\n    // Apply sort options\n    filters.order_by = switch (list_args.sort) {\n        .created_at => .created_at,\n        .updated_at => .updated_at,\n        .priority => .priority,\n    };\n    filters.order_desc = list_args.sort_desc;\n\n    const issues = try ctx.store.list(filters);\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n        defer allocator.free(compact_issues);\n\n        for (issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .status = issue.status.toString(),\n                .priority = issue.priority.value,\n                .issue_type = issue.issue_type.toString(),\n                .assignee = issue.assignee,\n            };\n        }\n\n        try ctx.output.printJson(ListResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(issues);\n        if (!global.quiet and issues.len == 0) {\n            try ctx.output.info(\"No issues found\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, structured_mode: bool, message: []const u8) !void {\n    if (structured_mode) {\n        try output.printJson(ListResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"ListError enum exists\" {\n    const err: ListError = ListError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ListError.WorkspaceNotInitialized);\n}\n\ntest \"ListResult struct works\" {\n    const result = ListResult{\n        .success = true,\n        .count = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const list_args = args.ListArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(list_args, global, allocator);\n    try std.testing.expectError(ListError.WorkspaceNotInitialized, result);\n}\n\ntest \"run lists issues successfully\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"list_success\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    defer f.close();\n\n    const list_args = args.ListArgs{ .all = true };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(list_args, global, allocator);\n}\n","numLines":219,"startLine":1,"totalLines":219}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DzoCLebrqdWJWF2YgBhSwZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018Ej9Fw7TsxqLbLMJrNrZp8","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/ready.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3389,"cache_read_input_tokens":38909,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3389},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"b7a166f0-919e-4bb7-a7e8-6e33256333f7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018Ej9Fw7TsxqLbLMJrNrZp8","type":"tool_result","content":"     1→//! Ready and blocked commands for beads_zig.\n     2→//!\n     3→//! `bz ready [-n LIMIT]` - Show issues ready to work on (no blockers)\n     4→//! `bz blocked [-n LIMIT]` - Show blocked issues\n     5→//!\n     6→//! Workflow queries for finding actionable work.\n     7→\n     8→const std = @import(\"std\");\n     9→const models = @import(\"../models/mod.zig\");\n    10→const store = @import(\"../storage/store.zig\");\n    11→const common = @import(\"common.zig\");\n    12→const args = @import(\"args.zig\");\n    13→const test_util = @import(\"../test_util.zig\");\n    14→\n    15→const Issue = models.Issue;\n    16→const Priority = models.Priority;\n    17→const CommandContext = common.CommandContext;\n    18→const DependencyGraph = common.DependencyGraph;\n    19→const containsIgnoreCase = store.containsIgnoreCase;\n    20→\n    21→pub const ReadyError = error{\n    22→    WorkspaceNotInitialized,\n    23→    StorageError,\n    24→    OutOfMemory,\n    25→    InvalidFilter,\n    26→};\n    27→\n    28→pub const ReadyResult = struct {\n    29→    success: bool,\n    30→    issues: ?[]const IssueCompact = null,\n    31→    count: ?usize = null,\n    32→    message: ?[]const u8 = null,\n    33→\n    34→    const IssueCompact = struct {\n    35→        id: []const u8,\n    36→        title: []const u8,\n    37→        priority: u3,\n    38→    };\n    39→};\n    40→\n    41→pub const BlockedResult = struct {\n    42→    success: bool,\n    43→    issues: ?[]const BlockedIssue = null,\n    44→    count: ?usize = null,\n    45→    message: ?[]const u8 = null,\n    46→\n    47→    const BlockedIssue = struct {\n    48→        id: []const u8,\n    49→        title: []const u8,\n    50→        priority: u3,\n    51→        blocked_by: []const []const u8,\n    52→    };\n    53→};\n    54→\n    55→pub fn run(\n    56→    ready_args: args.ReadyArgs,\n    57→    global: args.GlobalOptions,\n    58→    allocator: std.mem.Allocator,\n    59→) !void {\n    60→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    61→        return ReadyError.WorkspaceNotInitialized;\n    62→    };\n    63→    defer ctx.deinit();\n    64→\n    65→    // Parse priority filters\n    66→    var priority_min: ?Priority = null;\n    67→    var priority_max: ?Priority = null;\n    68→    if (ready_args.priority_min) |p| {\n    69→        priority_min = Priority.fromString(p) catch {\n    70→            try ctx.output.err(\"invalid priority-min value\", .{});\n    71→            return ReadyError.InvalidFilter;\n    72→        };\n    73→    }\n    74→    if (ready_args.priority_max) |p| {\n    75→        priority_max = Priority.fromString(p) catch {\n    76→            try ctx.output.err(\"invalid priority-max value\", .{});\n    77→            return ReadyError.InvalidFilter;\n    78→        };\n    79→    }\n    80→\n    81→    var graph = ctx.createGraph();\n    82→    const issues = try graph.getReadyIssues();\n    83→    defer graph.freeIssues(issues);\n    84→\n    85→    // Apply filters\n    86→    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains);\n    87→    defer allocator.free(filtered);\n    88→\n    89→    const display_issues = applyLimit(filtered, ready_args.limit);\n    90→\n    91→    if (global.isStructuredOutput()) {\n    92→        var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);\n    93→        defer allocator.free(compact_issues);\n    94→\n    95→        for (display_issues, 0..) |issue, i| {\n    96→            compact_issues[i] = .{\n    97→                .id = issue.id,\n    98→                .title = issue.title,\n    99→                .priority = issue.priority.value,\n   100→            };\n   101→        }\n   102→\n   103→        try ctx.output.printJson(ReadyResult{\n   104→            .success = true,\n   105→            .issues = compact_issues,\n   106→            .count = display_issues.len,\n   107→        });\n   108→    } else {\n   109→        try ctx.output.printIssueList(display_issues);\n   110→        if (!global.quiet and display_issues.len == 0) {\n   111→            try ctx.output.info(\"No ready issues\", .{});\n   112→        }\n   113→    }\n   114→}\n   115→\n   116→pub fn runBlocked(\n   117→    blocked_args: args.BlockedArgs,\n   118→    global: args.GlobalOptions,\n   119→    allocator: std.mem.Allocator,\n   120→) !void {\n   121→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   122→        return ReadyError.WorkspaceNotInitialized;\n   123→    };\n   124→    defer ctx.deinit();\n   125→\n   126→    // Parse priority filters\n   127→    var priority_min: ?Priority = null;\n   128→    var priority_max: ?Priority = null;\n   129→    if (blocked_args.priority_min) |p| {\n   130→        priority_min = Priority.fromString(p) catch {\n   131→            try ctx.output.err(\"invalid priority-min value\", .{});\n   132→            return ReadyError.InvalidFilter;\n   133→        };\n   134→    }\n   135→    if (blocked_args.priority_max) |p| {\n   136→        priority_max = Priority.fromString(p) catch {\n   137→            try ctx.output.err(\"invalid priority-max value\", .{});\n   138→            return ReadyError.InvalidFilter;\n   139→        };\n   140→    }\n   141→\n   142→    var graph = ctx.createGraph();\n   143→    const issues = try graph.getBlockedIssues();\n   144→    defer graph.freeIssues(issues);\n   145→\n   146→    // Apply filters\n   147→    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains);\n   148→    defer allocator.free(filtered);\n   149→\n   150→    const display_issues = applyLimit(filtered, blocked_args.limit);\n   151→\n   152→    if (global.isStructuredOutput()) {\n   153→        var blocked_issues = try allocator.alloc(BlockedResult.BlockedIssue, display_issues.len);\n   154→        defer {\n   155→            for (blocked_issues) |bi| {\n   156→                allocator.free(bi.blocked_by);\n   157→            }\n   158→            allocator.free(blocked_issues);\n   159→        }\n   160→\n   161→        for (display_issues, 0..) |issue, i| {\n   162→            const blockers = try graph.getBlockers(issue.id);\n   163→            defer graph.freeIssues(blockers);\n   164→\n   165→            var blocker_ids = try allocator.alloc([]const u8, blockers.len);\n   166→            for (blockers, 0..) |blocker, j| {\n   167→                blocker_ids[j] = blocker.id;\n   168→            }\n   169→\n   170→            blocked_issues[i] = .{\n   171→                .id = issue.id,\n   172→                .title = issue.title,\n   173→                .priority = issue.priority.value,\n   174→                .blocked_by = blocker_ids,\n   175→            };\n   176→        }\n   177→\n   178→        try ctx.output.printJson(BlockedResult{\n   179→            .success = true,\n   180→            .issues = blocked_issues,\n   181→            .count = display_issues.len,\n   182→        });\n   183→    } else {\n   184→        for (display_issues) |issue| {\n   185→            const blockers = try graph.getBlockers(issue.id);\n   186→            defer graph.freeIssues(blockers);\n   187→\n   188→            try ctx.output.print(\"{s}  {s}\\n\", .{ issue.id, issue.title });\n   189→\n   190→            if (blockers.len > 0) {\n   191→                try ctx.output.print(\"  blocked by: \", .{});\n   192→                for (blockers, 0..) |blocker, j| {\n   193→                    if (j > 0) try ctx.output.print(\", \", .{});\n   194→                    try ctx.output.print(\"{s}\", .{blocker.id});\n   195→                }\n   196→                try ctx.output.print(\"\\n\", .{});\n   197→            }\n   198→        }\n   199→\n   200→        if (!global.quiet and display_issues.len == 0) {\n   201→            try ctx.output.info(\"No blocked issues\", .{});\n   202→        }\n   203→    }\n   204→}\n   205→\n   206→fn applyLimit(issues: []Issue, limit: ?u32) []Issue {\n   207→    if (limit) |n| {\n   208→        if (n < issues.len) {\n   209→            return issues[0..n];\n   210→        }\n   211→    }\n   212→    return issues;\n   213→}\n   214→\n   215→fn applyFilters(\n   216→    allocator: std.mem.Allocator,\n   217→    issues: []Issue,\n   218→    priority_min: ?Priority,\n   219→    priority_max: ?Priority,\n   220→    title_contains: ?[]const u8,\n   221→    desc_contains: ?[]const u8,\n   222→    notes_contains: ?[]const u8,\n   223→) ![]Issue {\n   224→    // No filters - return original slice\n   225→    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null) {\n   226→        return try allocator.dupe(Issue, issues);\n   227→    }\n   228→\n   229→    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n   230→    errdefer filtered.deinit(allocator);\n   231→\n   232→    for (issues) |issue| {\n   233→        // Priority range filters (lower value = higher priority)\n   234→        if (priority_min) |min_p| {\n   235→            if (issue.priority.value < min_p.value) continue;\n   236→        }\n   237→        if (priority_max) |max_p| {\n   238→            if (issue.priority.value > max_p.value) continue;\n   239→        }\n   240→\n   241→        // Substring filters (case-insensitive)\n   242→        if (title_contains) |query| {\n   243→            if (!containsIgnoreCase(issue.title, query)) continue;\n   244→        }\n   245→        if (desc_contains) |query| {\n   246→            if (issue.description) |desc| {\n   247→                if (!containsIgnoreCase(desc, query)) continue;\n   248→            } else continue;\n   249→        }\n   250→        if (notes_contains) |query| {\n   251→            if (issue.notes) |notes| {\n   252→                if (!containsIgnoreCase(notes, query)) continue;\n   253→            } else continue;\n   254→        }\n   255→\n   256→        try filtered.append(allocator, issue);\n   257→    }\n   258→\n   259→    return filtered.toOwnedSlice(allocator);\n   260→}\n   261→\n   262→// --- Tests ---\n   263→\n   264→test \"ReadyError enum exists\" {\n   265→    const err: ReadyError = ReadyError.WorkspaceNotInitialized;\n   266→    try std.testing.expect(err == ReadyError.WorkspaceNotInitialized);\n   267→}\n   268→\n   269→test \"ReadyResult struct works\" {\n   270→    const result = ReadyResult{\n   271→        .success = true,\n   272→        .count = 3,\n   273→    };\n   274→    try std.testing.expect(result.success);\n   275→    try std.testing.expectEqual(@as(usize, 3), result.count.?);\n   276→}\n   277→\n   278→test \"BlockedResult struct works\" {\n   279→    const result = BlockedResult{\n   280→        .success = true,\n   281→        .count = 2,\n   282→    };\n   283→    try std.testing.expect(result.success);\n   284→    try std.testing.expectEqual(@as(usize, 2), result.count.?);\n   285→}\n   286→\n   287→test \"run detects uninitialized workspace\" {\n   288→    const allocator = std.testing.allocator;\n   289→\n   290→    const ready_args = args.ReadyArgs{};\n   291→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   292→\n   293→    const result = run(ready_args, global, allocator);\n   294→    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n   295→}\n   296→\n   297→test \"runBlocked detects uninitialized workspace\" {\n   298→    const allocator = std.testing.allocator;\n   299→\n   300→    const blocked_args = args.BlockedArgs{};\n   301→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   302→\n   303→    const result = runBlocked(blocked_args, global, allocator);\n   304→    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n   305→}\n   306→\n   307→test \"run returns empty list for empty workspace\" {\n   308→    const allocator = std.testing.allocator;\n   309→\n   310→    const tmp_dir_path = try test_util.createTestDir(allocator, \"ready_empty\");\n   311→    defer allocator.free(tmp_dir_path);\n   312→    defer test_util.cleanupTestDir(tmp_dir_path);\n   313→\n   314→    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   315→    defer allocator.free(data_path);\n   316→\n   317→    try std.fs.cwd().makeDir(data_path);\n   318→\n   319→    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   320→    defer allocator.free(issues_path);\n   321→\n   322→    const f = try std.fs.cwd().createFile(issues_path, .{});\n   323→    f.close();\n   324→\n   325→    const ready_args = args.ReadyArgs{};\n   326→    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   327→\n   328→    try run(ready_args, global, allocator);\n   329→}\n   330→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"37540ad2-8575-4cf7-8729-79ecc90e44e3","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/ready.zig","content":"//! Ready and blocked commands for beads_zig.\n//!\n//! `bz ready [-n LIMIT]` - Show issues ready to work on (no blockers)\n//! `bz blocked [-n LIMIT]` - Show blocked issues\n//!\n//! Workflow queries for finding actionable work.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst store = @import(\"../storage/store.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Priority = models.Priority;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst containsIgnoreCase = store.containsIgnoreCase;\n\npub const ReadyError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidFilter,\n};\n\npub const ReadyResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n    };\n};\n\npub const BlockedResult = struct {\n    success: bool,\n    issues: ?[]const BlockedIssue = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const BlockedIssue = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n        blocked_by: []const []const u8,\n    };\n};\n\npub fn run(\n    ready_args: args.ReadyArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (ready_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (ready_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, ready_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);\n        defer allocator.free(compact_issues);\n\n        for (display_issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n            };\n        }\n\n        try ctx.output.printJson(ReadyResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(display_issues);\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No ready issues\", .{});\n        }\n    }\n}\n\npub fn runBlocked(\n    blocked_args: args.BlockedArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (blocked_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (blocked_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getBlockedIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, blocked_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var blocked_issues = try allocator.alloc(BlockedResult.BlockedIssue, display_issues.len);\n        defer {\n            for (blocked_issues) |bi| {\n                allocator.free(bi.blocked_by);\n            }\n            allocator.free(blocked_issues);\n        }\n\n        for (display_issues, 0..) |issue, i| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            var blocker_ids = try allocator.alloc([]const u8, blockers.len);\n            for (blockers, 0..) |blocker, j| {\n                blocker_ids[j] = blocker.id;\n            }\n\n            blocked_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n                .blocked_by = blocker_ids,\n            };\n        }\n\n        try ctx.output.printJson(BlockedResult{\n            .success = true,\n            .issues = blocked_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        for (display_issues) |issue| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            try ctx.output.print(\"{s}  {s}\\n\", .{ issue.id, issue.title });\n\n            if (blockers.len > 0) {\n                try ctx.output.print(\"  blocked by: \", .{});\n                for (blockers, 0..) |blocker, j| {\n                    if (j > 0) try ctx.output.print(\", \", .{});\n                    try ctx.output.print(\"{s}\", .{blocker.id});\n                }\n                try ctx.output.print(\"\\n\", .{});\n            }\n        }\n\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No blocked issues\", .{});\n        }\n    }\n}\n\nfn applyLimit(issues: []Issue, limit: ?u32) []Issue {\n    if (limit) |n| {\n        if (n < issues.len) {\n            return issues[0..n];\n        }\n    }\n    return issues;\n}\n\nfn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n) ![]Issue {\n    // No filters - return original slice\n    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null) {\n        return try allocator.dupe(Issue, issues);\n    }\n\n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    errdefer filtered.deinit(allocator);\n\n    for (issues) |issue| {\n        // Priority range filters (lower value = higher priority)\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        if (priority_max) |max_p| {\n            if (issue.priority.value > max_p.value) continue;\n        }\n\n        // Substring filters (case-insensitive)\n        if (title_contains) |query| {\n            if (!containsIgnoreCase(issue.title, query)) continue;\n        }\n        if (desc_contains) |query| {\n            if (issue.description) |desc| {\n                if (!containsIgnoreCase(desc, query)) continue;\n            } else continue;\n        }\n        if (notes_contains) |query| {\n            if (issue.notes) |notes| {\n                if (!containsIgnoreCase(notes, query)) continue;\n            } else continue;\n        }\n\n        try filtered.append(allocator, issue);\n    }\n\n    return filtered.toOwnedSlice(allocator);\n}\n\n// --- Tests ---\n\ntest \"ReadyError enum exists\" {\n    const err: ReadyError = ReadyError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ReadyError.WorkspaceNotInitialized);\n}\n\ntest \"ReadyResult struct works\" {\n    const result = ReadyResult{\n        .success = true,\n        .count = 3,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 3), result.count.?);\n}\n\ntest \"BlockedResult struct works\" {\n    const result = BlockedResult{\n        .success = true,\n        .count = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 2), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(ready_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"runBlocked detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const blocked_args = args.BlockedArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = runBlocked(blocked_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"run returns empty list for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"ready_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(ready_args, global, allocator);\n}\n","numLines":330,"startLine":1,"totalLines":330}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018RmPLgjk9AUyRoFRqmyGHz","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to read the store.zig to understand the ListFilters structure and how to add the new filters."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":8642,"cache_read_input_tokens":42298,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8642},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"e71aebd1-7c84-4570-9ce9-9e971dd8a24a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018RmPLgjk9AUyRoFRqmyGHz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EUybGh9xWSZTShxb7DrX21","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","offset":325,"limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":8642,"cache_read_input_tokens":42298,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8642},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"9d8dd95b-4aef-4135-bf5a-c1e38caba5bb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EUybGh9xWSZTShxb7DrX21","type":"tool_result","content":"   325→    /// Soft delete an issue by setting its status to tombstone.\n   326→    pub fn delete(self: *Self, id: []const u8, now: i64) !void {\n   327→        try self.update(id, .{ .status = .tombstone }, now);\n   328→    }\n   329→\n   330→    /// Filters for listing issues.\n   331→    pub const ListFilters = struct {\n   332→        status: ?Status = null,\n   333→        priority: ?Priority = null,\n   334→        priority_min: ?Priority = null,\n   335→        priority_max: ?Priority = null,\n   336→        issue_type: ?IssueType = null,\n   337→        assignee: ?[]const u8 = null,\n   338→        label: ?[]const u8 = null,\n   339→        label_any: []const []const u8 = &[_][]const u8{},\n   340→        title_contains: ?[]const u8 = null,\n   341→        desc_contains: ?[]const u8 = null,\n   342→        notes_contains: ?[]const u8 = null,\n   343→        include_tombstones: bool = false,\n   344→        limit: ?u32 = null,\n   345→        offset: ?u32 = null,\n   346→        order_by: OrderBy = .created_at,\n   347→        order_desc: bool = true,\n   348→\n   349→        pub const OrderBy = enum {\n   350→            created_at,\n   351→            updated_at,\n   352→            priority,\n   353→        };\n   354→    };\n   355→\n   356→    /// List issues with optional filters.\n   357→    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n   358→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   359→        errdefer {\n   360→            for (results.items) |*issue| {\n   361→                issue.deinit(self.allocator);\n   362→            }\n   363→            results.deinit(self.allocator);\n   364→        }\n   365→\n   366→        for (self.issues.items) |issue| {\n   367→            // Filter tombstones\n   368→            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n   369→                continue;\n   370→            }\n   371→\n   372→            // Apply filters\n   373→            if (filters.status) |s| {\n   374→                if (!statusEql(issue.status, s)) continue;\n   375→            }\n   376→            if (filters.priority) |p| {\n   377→                if (issue.priority.value != p.value) continue;\n   378→            }\n   379→            if (filters.issue_type) |t| {\n   380→                if (!issueTypeEql(issue.issue_type, t)) continue;\n   381→            }\n   382→            if (filters.assignee) |a| {\n   383→                if (issue.assignee == null) continue;\n   384→                if (!std.mem.eql(u8, issue.assignee.?, a)) continue;\n   385→            }\n   386→            if (filters.label) |lbl| {\n   387→                var found = false;\n   388→                for (issue.labels) |label| {\n   389→                    if (std.mem.eql(u8, label, lbl)) {\n   390→                        found = true;\n   391→                        break;\n   392→                    }\n   393→                }\n   394→                if (!found) continue;\n   395→            }\n   396→\n   397→            // label_any: OR logic - issue must have at least ONE of the specified labels\n   398→            if (filters.label_any.len > 0) {\n   399→                var found_any = false;\n   400→                for (filters.label_any) |any_label| {\n   401→                    for (issue.labels) |issue_label| {\n   402→                        if (std.mem.eql(u8, issue_label, any_label)) {\n   403→                            found_any = true;\n   404→                            break;\n   405→                        }\n   406→                    }\n   407→                    if (found_any) break;\n   408→                }\n   409→                if (!found_any) continue;\n   410→            }\n   411→\n   412→            // Priority range filters (lower value = higher priority)\n   413→            if (filters.priority_min) |min_p| {\n   414→                if (issue.priority.value < min_p.value) continue;\n   415→            }\n   416→            if (filters.priority_max) |max_p| {\n   417→                if (issue.priority.value > max_p.value) continue;\n   418→            }\n   419→\n   420→            // Substring filters (case-insensitive)\n   421→            if (filters.title_contains) |query| {\n   422→                if (!containsIgnoreCase(issue.title, query)) continue;\n   423→            }\n   424→            if (filters.desc_contains) |query| {\n   425→                if (issue.description) |desc| {\n   426→                    if (!containsIgnoreCase(desc, query)) continue;\n   427→                } else continue;\n   428→            }\n   429→            if (filters.notes_contains) |query| {\n   430→                if (issue.notes) |notes| {\n   431→                    if (!containsIgnoreCase(notes, query)) continue;\n   432→                } else continue;\n   433→            }\n   434→\n   435→            try results.append(self.allocator, try issue.clone(self.allocator));\n   436→        }\n   437→\n   438→        // Sort\n   439→        const SortContext = struct {\n   440→            order_by: ListFilters.OrderBy,\n   441→            order_desc: bool,\n   442→        };\n   443→        const ctx = SortContext{ .order_by = filters.order_by, .order_desc = filters.order_desc };\n   444→\n   445→        std.mem.sortUnstable(Issue, results.items, ctx, struct {\n   446→            fn lessThan(c: SortContext, a: Issue, b: Issue) bool {\n   447→                const cmp: i64 = switch (c.order_by) {\n   448→                    .created_at => a.created_at.value - b.created_at.value,\n   449→                    .updated_at => a.updated_at.value - b.updated_at.value,\n   450→                    .priority => @as(i64, a.priority.value) - @as(i64, b.priority.value),\n   451→                };\n   452→                return if (c.order_desc) cmp > 0 else cmp < 0;\n   453→            }\n   454→        }.lessThan);\n   455→\n   456→        // Apply offset and limit\n   457→        var start: usize = 0;\n   458→        if (filters.offset) |off| {\n   459→            start = @min(off, results.items.len);\n   460→        }\n   461→\n   462→        var end: usize = results.items.len;\n   463→        if (filters.limit) |lim| {\n   464→            end = @min(start + lim, results.items.len);\n   465→        }\n   466→\n   467→        // Free items outside the range\n   468→        for (results.items[0..start]) |*issue| {\n   469→            issue.deinit(self.allocator);\n   470→        }\n   471→        for (results.items[end..]) |*issue| {\n   472→            issue.deinit(self.allocator);\n   473→        }\n   474→\n   475→        // Return slice\n   476→        const slice = try self.allocator.dupe(Issue, results.items[start..end]);\n   477→        results.deinit(self.allocator);\n   478→        return slice;\n   479→    }\n   480→\n   481→    /// Result from counting issues.\n   482→    pub const CountResult = struct {\n   483→        key: []const u8,\n   484→        count: u64,\n   485→    };\n   486→\n   487→    /// Count issues, optionally grouped by a field.\n   488→    pub fn count(self: *Self, group_by: ?GroupBy) ![]CountResult {\n   489→        var counts: std.StringHashMapUnmanaged(u64) = .{};\n   490→        defer counts.deinit(self.allocator);\n   491→\n   492→        for (self.issues.items) |issue| {\n   493→            if (statusEql(issue.status, .tombstone)) continue;\n   494→\n   495→            const key_str: []const u8 = if (group_by) |g| switch (g) {\n   496→                .status => issue.status.toString(),\n   497→                .priority => switch (issue.priority.value) {\n   498→                    0 => \"0\",\n   499→                    1 => \"1\",\n   500→                    2 => \"2\",\n   501→                    3 => \"3\",\n   502→                    4 => \"4\",\n   503→                    else => unreachable,\n   504→                },\n   505→                .issue_type => issue.issue_type.toString(),\n   506→                .assignee => issue.assignee orelse \"(unassigned)\",\n   507→            } else \"total\";\n   508→\n   509→            const entry = counts.getOrPutValue(self.allocator, key_str, 0) catch continue;\n   510→            entry.value_ptr.* += 1;\n   511→        }\n   512→\n   513→        var results: std.ArrayListUnmanaged(CountResult) = .{};\n   514→        errdefer {\n   515→            for (results.items) |r| {\n   516→                self.allocator.free(r.key);\n   517→            }\n   518→            results.deinit(self.allocator);\n   519→        }\n   520→\n   521→        var it = counts.iterator();\n   522→        while (it.next()) |entry| {\n   523→            const key = try self.allocator.dupe(u8, entry.key_ptr.*);\n   524→            try results.append(self.allocator, .{ .key = key, .count = entry.value_ptr.* });\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"bc69917a-daed-4a16-9e36-93bb63f7e539","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/storage/store.zig","content":"    /// Soft delete an issue by setting its status to tombstone.\n    pub fn delete(self: *Self, id: []const u8, now: i64) !void {\n        try self.update(id, .{ .status = .tombstone }, now);\n    }\n\n    /// Filters for listing issues.\n    pub const ListFilters = struct {\n        status: ?Status = null,\n        priority: ?Priority = null,\n        priority_min: ?Priority = null,\n        priority_max: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        label_any: []const []const u8 = &[_][]const u8{},\n        title_contains: ?[]const u8 = null,\n        desc_contains: ?[]const u8 = null,\n        notes_contains: ?[]const u8 = null,\n        include_tombstones: bool = false,\n        limit: ?u32 = null,\n        offset: ?u32 = null,\n        order_by: OrderBy = .created_at,\n        order_desc: bool = true,\n\n        pub const OrderBy = enum {\n            created_at,\n            updated_at,\n            priority,\n        };\n    };\n\n    /// List issues with optional filters.\n    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.issues.items) |issue| {\n            // Filter tombstones\n            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n                continue;\n            }\n\n            // Apply filters\n            if (filters.status) |s| {\n                if (!statusEql(issue.status, s)) continue;\n            }\n            if (filters.priority) |p| {\n                if (issue.priority.value != p.value) continue;\n            }\n            if (filters.issue_type) |t| {\n                if (!issueTypeEql(issue.issue_type, t)) continue;\n            }\n            if (filters.assignee) |a| {\n                if (issue.assignee == null) continue;\n                if (!std.mem.eql(u8, issue.assignee.?, a)) continue;\n            }\n            if (filters.label) |lbl| {\n                var found = false;\n                for (issue.labels) |label| {\n                    if (std.mem.eql(u8, label, lbl)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) continue;\n            }\n\n            // label_any: OR logic - issue must have at least ONE of the specified labels\n            if (filters.label_any.len > 0) {\n                var found_any = false;\n                for (filters.label_any) |any_label| {\n                    for (issue.labels) |issue_label| {\n                        if (std.mem.eql(u8, issue_label, any_label)) {\n                            found_any = true;\n                            break;\n                        }\n                    }\n                    if (found_any) break;\n                }\n                if (!found_any) continue;\n            }\n\n            // Priority range filters (lower value = higher priority)\n            if (filters.priority_min) |min_p| {\n                if (issue.priority.value < min_p.value) continue;\n            }\n            if (filters.priority_max) |max_p| {\n                if (issue.priority.value > max_p.value) continue;\n            }\n\n            // Substring filters (case-insensitive)\n            if (filters.title_contains) |query| {\n                if (!containsIgnoreCase(issue.title, query)) continue;\n            }\n            if (filters.desc_contains) |query| {\n                if (issue.description) |desc| {\n                    if (!containsIgnoreCase(desc, query)) continue;\n                } else continue;\n            }\n            if (filters.notes_contains) |query| {\n                if (issue.notes) |notes| {\n                    if (!containsIgnoreCase(notes, query)) continue;\n                } else continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort\n        const SortContext = struct {\n            order_by: ListFilters.OrderBy,\n            order_desc: bool,\n        };\n        const ctx = SortContext{ .order_by = filters.order_by, .order_desc = filters.order_desc };\n\n        std.mem.sortUnstable(Issue, results.items, ctx, struct {\n            fn lessThan(c: SortContext, a: Issue, b: Issue) bool {\n                const cmp: i64 = switch (c.order_by) {\n                    .created_at => a.created_at.value - b.created_at.value,\n                    .updated_at => a.updated_at.value - b.updated_at.value,\n                    .priority => @as(i64, a.priority.value) - @as(i64, b.priority.value),\n                };\n                return if (c.order_desc) cmp > 0 else cmp < 0;\n            }\n        }.lessThan);\n\n        // Apply offset and limit\n        var start: usize = 0;\n        if (filters.offset) |off| {\n            start = @min(off, results.items.len);\n        }\n\n        var end: usize = results.items.len;\n        if (filters.limit) |lim| {\n            end = @min(start + lim, results.items.len);\n        }\n\n        // Free items outside the range\n        for (results.items[0..start]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        for (results.items[end..]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n\n        // Return slice\n        const slice = try self.allocator.dupe(Issue, results.items[start..end]);\n        results.deinit(self.allocator);\n        return slice;\n    }\n\n    /// Result from counting issues.\n    pub const CountResult = struct {\n        key: []const u8,\n        count: u64,\n    };\n\n    /// Count issues, optionally grouped by a field.\n    pub fn count(self: *Self, group_by: ?GroupBy) ![]CountResult {\n        var counts: std.StringHashMapUnmanaged(u64) = .{};\n        defer counts.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const key_str: []const u8 = if (group_by) |g| switch (g) {\n                .status => issue.status.toString(),\n                .priority => switch (issue.priority.value) {\n                    0 => \"0\",\n                    1 => \"1\",\n                    2 => \"2\",\n                    3 => \"3\",\n                    4 => \"4\",\n                    else => unreachable,\n                },\n                .issue_type => issue.issue_type.toString(),\n                .assignee => issue.assignee orelse \"(unassigned)\",\n            } else \"total\";\n\n            const entry = counts.getOrPutValue(self.allocator, key_str, 0) catch continue;\n            entry.value_ptr.* += 1;\n        }\n\n        var results: std.ArrayListUnmanaged(CountResult) = .{};\n        errdefer {\n            for (results.items) |r| {\n                self.allocator.free(r.key);\n            }\n            results.deinit(self.allocator);\n        }\n\n        var it = counts.iterator();\n        while (it.next()) |entry| {\n            const key = try self.allocator.dupe(u8, entry.key_ptr.*);\n            try results.append(self.allocator, .{ .key = key, .count = entry.value_ptr.* });","numLines":200,"startLine":325,"totalLines":1256}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018RmPLgjk9AUyRoFRqmyGHz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PcX1mt6uvgaeS5hvafCuYH","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/graph.zig","offset":275,"limit":120}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":8642,"cache_read_input_tokens":42298,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8642},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"0eb3c9ec-900c-459c-989e-71bd6547a617"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PcX1mt6uvgaeS5hvafCuYH","type":"tool_result","content":"   275→\n   276→        _ = rec_stack.remove(node);\n   277→        _ = path.pop();\n   278→        return false;\n   279→    }\n   280→\n   281→    /// Get all issues that are ready (open, not blocked by open issues, not deferred).\n   282→    pub fn getReadyIssues(self: *Self) ![]Issue {\n   283→        const now = std.time.timestamp();\n   284→\n   285→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   286→        errdefer {\n   287→            for (results.items) |*issue| {\n   288→                issue.deinit(self.allocator);\n   289→            }\n   290→            results.deinit(self.allocator);\n   291→        }\n   292→\n   293→        for (self.store.getAllRef()) |issue| {\n   294→            // Must be open\n   295→            if (!statusEql(issue.status, .open)) continue;\n   296→\n   297→            // Must not be deferred to future\n   298→            if (issue.defer_until.value) |defer_time| {\n   299→                if (defer_time > now) continue;\n   300→            }\n   301→\n   302→            // Must not have any open blockers\n   303→            var has_open_blocker = false;\n   304→            for (issue.dependencies) |dep| {\n   305→                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   306→                    if (!statusEql(blocker.status, .closed) and\n   307→                        !statusEql(blocker.status, .tombstone))\n   308→                    {\n   309→                        has_open_blocker = true;\n   310→                        break;\n   311→                    }\n   312→                }\n   313→            }\n   314→            if (has_open_blocker) continue;\n   315→\n   316→            try results.append(self.allocator, try issue.clone(self.allocator));\n   317→        }\n   318→\n   319→        // Sort by priority then created_at\n   320→        std.mem.sortUnstable(Issue, results.items, {}, struct {\n   321→            fn lessThan(_: void, a: Issue, b: Issue) bool {\n   322→                if (a.priority.value != b.priority.value) {\n   323→                    return a.priority.value < b.priority.value;\n   324→                }\n   325→                return a.created_at.value < b.created_at.value;\n   326→            }\n   327→        }.lessThan);\n   328→\n   329→        return results.toOwnedSlice(self.allocator);\n   330→    }\n   331→\n   332→    /// Get all blocked issues (open issues with unresolved dependencies).\n   333→    pub fn getBlockedIssues(self: *Self) ![]Issue {\n   334→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   335→        errdefer {\n   336→            for (results.items) |*issue| {\n   337→                issue.deinit(self.allocator);\n   338→            }\n   339→            results.deinit(self.allocator);\n   340→        }\n   341→\n   342→        for (self.store.getAllRef()) |issue| {\n   343→            // Must be open\n   344→            if (!statusEql(issue.status, .open)) continue;\n   345→\n   346→            // Must have at least one open blocker\n   347→            var has_open_blocker = false;\n   348→            for (issue.dependencies) |dep| {\n   349→                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   350→                    if (!statusEql(blocker.status, .closed) and\n   351→                        !statusEql(blocker.status, .tombstone))\n   352→                    {\n   353→                        has_open_blocker = true;\n   354→                        break;\n   355→                    }\n   356→                }\n   357→            }\n   358→            if (!has_open_blocker) continue;\n   359→\n   360→            try results.append(self.allocator, try issue.clone(self.allocator));\n   361→        }\n   362→\n   363→        // Sort by priority then created_at\n   364→        std.mem.sortUnstable(Issue, results.items, {}, struct {\n   365→            fn lessThan(_: void, a: Issue, b: Issue) bool {\n   366→                if (a.priority.value != b.priority.value) {\n   367→                    return a.priority.value < b.priority.value;\n   368→                }\n   369→                return a.created_at.value < b.created_at.value;\n   370→            }\n   371→        }.lessThan);\n   372→\n   373→        return results.toOwnedSlice(self.allocator);\n   374→    }\n   375→\n   376→    /// Get blockers for an issue (open issues that this issue depends on).\n   377→    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue {\n   378→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   379→        errdefer {\n   380→            for (results.items) |*issue| {\n   381→                issue.deinit(self.allocator);\n   382→            }\n   383→            results.deinit(self.allocator);\n   384→        }\n   385→\n   386→        const issue = self.store.getRef(issue_id) orelse return results.toOwnedSlice(self.allocator);\n   387→\n   388→        for (issue.dependencies) |dep| {\n   389→            if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   390→                if (!statusEql(blocker.status, .closed) and\n   391→                    !statusEql(blocker.status, .tombstone))\n   392→                {\n   393→                    try results.append(self.allocator, try blocker.clone(self.allocator));\n   394→                }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"a380afcd-8dce-4a38-a397-d3f535c7d1c9","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/storage/graph.zig","content":"\n        _ = rec_stack.remove(node);\n        _ = path.pop();\n        return false;\n    }\n\n    /// Get all issues that are ready (open, not blocked by open issues, not deferred).\n    pub fn getReadyIssues(self: *Self) ![]Issue {\n        const now = std.time.timestamp();\n\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open\n            if (!statusEql(issue.status, .open)) continue;\n\n            // Must not be deferred to future\n            if (issue.defer_until.value) |defer_time| {\n                if (defer_time > now) continue;\n            }\n\n            // Must not have any open blockers\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get all blocked issues (open issues with unresolved dependencies).\n    pub fn getBlockedIssues(self: *Self) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open\n            if (!statusEql(issue.status, .open)) continue;\n\n            // Must have at least one open blocker\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (!has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get blockers for an issue (open issues that this issue depends on).\n    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        const issue = self.store.getRef(issue_id) orelse return results.toOwnedSlice(self.allocator);\n\n        for (issue.dependencies) |dep| {\n            if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                if (!statusEql(blocker.status, .closed) and\n                    !statusEql(blocker.status, .tombstone))\n                {\n                    try results.append(self.allocator, try blocker.clone(self.allocator));\n                }","numLines":120,"startLine":275,"totalLines":659}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RRVowj1mfWsNSbBpdFwtPQ","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me see the args parsing code for list and ready commands."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":4734,"cache_read_input_tokens":50940,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4734},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"c132be49-f55f-41df-8b03-f67d6e7a0ef9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RRVowj1mfWsNSbBpdFwtPQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014HFYVH9ZioffAgaXLkYPVe","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1020,"limit":120}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":4734,"cache_read_input_tokens":50940,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4734},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"8792bcac-47f2-4127-b2cd-18cf79bf0c7f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014HFYVH9ZioffAgaXLkYPVe","type":"tool_result","content":"  1020→        if (!file_set) return error.MissingRequiredArgument;\n  1021→        return result;\n  1022→    }\n  1023→\n  1024→    fn parseListArgs(self: *Self) ParseError!ListArgs {\n  1025→        var result = ListArgs{};\n  1026→        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n  1027→\n  1028→        while (self.hasNext()) {\n  1029→            if (self.consumeFlag(\"-s\", \"--status\")) {\n  1030→                result.status = self.next() orelse return error.MissingFlagValue;\n  1031→            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n  1032→                result.priority = self.next() orelse return error.MissingFlagValue;\n  1033→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1034→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1035→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1036→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1037→            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n  1038→                result.issue_type = self.next() orelse return error.MissingFlagValue;\n  1039→            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n  1040→                result.assignee = self.next() orelse return error.MissingFlagValue;\n  1041→            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n  1042→                result.label = self.next() orelse return error.MissingFlagValue;\n  1043→            } else if (self.consumeFlag(null, \"--label-any\")) {\n  1044→                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n  1045→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1046→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1047→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1048→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1049→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1050→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1051→            } else if (try self.parseLimitFlag()) |limit| {\n  1052→                result.limit = limit;\n  1053→            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n  1054→                result.all = true;\n  1055→            } else if (self.consumeFlag(null, \"--sort\")) {\n  1056→                const sort_str = self.next() orelse return error.MissingFlagValue;\n  1057→                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n  1058→            } else if (self.consumeFlag(null, \"--asc\")) {\n  1059→                result.sort_desc = false;\n  1060→            } else if (self.consumeFlag(null, \"--desc\")) {\n  1061→                result.sort_desc = true;\n  1062→            } else break;\n  1063→        }\n  1064→\n  1065→        if (label_any_list.items.len > 0) {\n  1066→            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n  1067→        }\n  1068→\n  1069→        return result;\n  1070→    }\n  1071→\n  1072→    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n  1073→        var result = ReadyArgs{};\n  1074→        while (self.hasNext()) {\n  1075→            if (try self.parseLimitFlag()) |limit| {\n  1076→                result.limit = limit;\n  1077→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1078→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1079→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1080→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1081→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1082→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1083→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1084→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1085→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1086→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1087→            } else break;\n  1088→        }\n  1089→        return result;\n  1090→    }\n  1091→\n  1092→    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n  1093→        var result = BlockedArgs{};\n  1094→        while (self.hasNext()) {\n  1095→            if (try self.parseLimitFlag()) |limit| {\n  1096→                result.limit = limit;\n  1097→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1098→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1099→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1100→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1101→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1102→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1103→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1104→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1105→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1106→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1107→            } else break;\n  1108→        }\n  1109→        return result;\n  1110→    }\n  1111→\n  1112→    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n  1113→        var result = SearchArgs{ .query = undefined };\n  1114→        var query_set = false;\n  1115→\n  1116→        while (self.hasNext()) {\n  1117→            if (try self.parseLimitFlag()) |limit| {\n  1118→                result.limit = limit;\n  1119→            } else if (self.peekPositional()) |_| {\n  1120→                if (!query_set) {\n  1121→                    result.query = self.next().?;\n  1122→                    query_set = true;\n  1123→                } else break;\n  1124→            } else break;\n  1125→        }\n  1126→\n  1127→        if (!query_set) return error.MissingRequiredArgument;\n  1128→        return result;\n  1129→    }\n  1130→\n  1131→    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n  1132→        var result = StaleArgs{};\n  1133→        while (self.hasNext()) {\n  1134→            if (self.consumeFlag(\"-d\", \"--days\")) {\n  1135→                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n  1136→            } else if (try self.parseLimitFlag()) |limit| {\n  1137→                result.limit = limit;\n  1138→            } else break;\n  1139→        }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"ed444eb8-33c5-4171-8f5b-9f5852d26e42","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }","numLines":120,"startLine":1020,"totalLines":2372}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013kkVXzgE86dWvdboGHneak","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XdHV2DRF9WTgCUiT8NR6rc","name":"TodoWrite","input":{"todos":[{"content":"Add --overdue filter for list and ready commands","status":"in_progress","activeForm":"Adding --overdue filter for list and ready commands"},{"content":"Add --deferred flag to include deferred issues in list","status":"pending","activeForm":"Adding --deferred flag to include deferred issues in list"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Commit all changes","status":"pending","activeForm":"Committing all changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2508,"cache_read_input_tokens":55674,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2508},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"da297e28-3d4e-47c5-bf14-b8be80c2cbe2"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XdHV2DRF9WTgCUiT8NR6rc","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"9b9ac251-be5a-48d5-b6d8-f184a0f75178","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Add --overdue filter for list and ready commands","status":"in_progress","activeForm":"Adding --overdue filter for list and ready commands"},{"content":"Add --deferred flag to include deferred issues in list","status":"pending","activeForm":"Adding --deferred flag to include deferred issues in list"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Commit all changes","status":"pending","activeForm":"Committing all changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NJCygqW1Qpgmv7vPp8cfB3","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a clear understanding of the codebase. Let me implement Task 1: Add --overdue filter.\n\n## Task 1: Add --overdue filter\n\nI need to:\n1. Add `overdue: bool = false` to `ListArgs` and `ReadyArgs` in args.zig\n2. Add parsing for `--overdue` flag in `parseListArgs()` and `parseReadyArgs()`\n3. Add `overdue: bool = false` to `ListFilters` in store.zig\n4. Add filtering logic in the `list()` function in store.zig\n5. Pass the overdue flag from list.zig to filters\n6. Add filtering in ready.zig's `applyFilters()` function"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":232,"cache_read_input_tokens":58182,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":232},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"c6c0dc2c-181e-4fbf-9d6e-56f7a057c31f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NJCygqW1Qpgmv7vPp8cfB3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SRRsoDvLqhFg9KYkR4vvxG","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};","new_string":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":232,"cache_read_input_tokens":58182,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":232},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"25b3bb18-0581-40a2-9fba-2beee8cd4058"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SRRsoDvLqhFg9KYkR4vvxG","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"65e30c16-c6d4-4d95-a569-5251298eb860","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};","newString":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":228,"oldLines":6,"newStart":228,"newLines":8,"lines":["     notes_contains: ?[]const u8 = null,","     limit: ?u32 = null,","     all: bool = false,","+    overdue: bool = false,","+    include_deferred: bool = false,","     sort: SortField = .created_at,","     sort_desc: bool = true,"," };"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NJCygqW1Qpgmv7vPp8cfB3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JVAUfLPtvmw3T23YUhnfQF","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};","new_string":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":232,"cache_read_input_tokens":58182,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":232},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"a990e198-16d8-4afd-87ab-6d5fec5f877a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JVAUfLPtvmw3T23YUhnfQF","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"2d11d802-b217-47b3-9e5f-d340724ce321","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};","newString":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":242,"oldLines":6,"newStart":242,"newLines":8,"lines":["     title_contains: ?[]const u8 = null,","     desc_contains: ?[]const u8 = null,","     notes_contains: ?[]const u8 = null,","+    overdue: bool = false,","+    include_deferred: bool = false,"," };"," "," /// Blocked command arguments."]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01X8TPYzKqkLyocwCLwFCm8A","type":"message","role":"assistant","content":[{"type":"text","text":"Now add the parsing logic for these flags."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1220,"cache_read_input_tokens":58414,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1220},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"803ebfb3-a845-4a11-a050-b37f4a801af9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01X8TPYzKqkLyocwCLwFCm8A","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SippxU1r6G1nqnkBN7yk4X","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {","new_string":"            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1220,"cache_read_input_tokens":58414,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1220},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"42306d13-26d5-47fb-b3f2-2c949e0459ca"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SippxU1r6G1nqnkBN7yk4X","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"35e8ad33-9f55-4998-942b-2d18f8270521","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {","newString":"            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1056,"oldLines":6,"newStart":1056,"newLines":10,"lines":["                 result.limit = limit;","             } else if (self.consumeFlag(\"-A\", \"--all\")) {","                 result.all = true;","+            } else if (self.consumeFlag(null, \"--overdue\")) {","+                result.overdue = true;","+            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {","+                result.include_deferred = true;","             } else if (self.consumeFlag(null, \"--sort\")) {","                 const sort_str = self.next() orelse return error.MissingFlagValue;","                 result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01X8TPYzKqkLyocwCLwFCm8A","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01455hTvMK17aFXHCoeqCqKo","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {","new_string":"            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1220,"cache_read_input_tokens":58414,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1220},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"d21e2011-1c2c-42f1-a52d-81c4a96e6f9d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01455hTvMK17aFXHCoeqCqKo","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"801dbd04-8428-463d-afc3-2c48dc481bbc","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {","newString":"            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1092,"oldLines":6,"newStart":1092,"newLines":10,"lines":["                 result.desc_contains = self.next() orelse return error.MissingFlagValue;","             } else if (self.consumeFlag(null, \"--notes-contains\")) {","                 result.notes_contains = self.next() orelse return error.MissingFlagValue;","+            } else if (self.consumeFlag(null, \"--overdue\")) {","+                result.overdue = true;","+            } else if (self.consumeFlag(null, \"--include-deferred\")) {","+                result.include_deferred = true;","             } else break;","         }","         return result;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01D8Z1qNuaEu4yGpWhqPLDSY","type":"message","role":"assistant","content":[{"type":"text","text":"Now add the filter fields to `ListFilters` in store.zig."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":745,"cache_read_input_tokens":59634,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":745},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"55121077-4c23-4070-9f12-4ec7984e622f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01D8Z1qNuaEu4yGpWhqPLDSY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UWtTgP78xvcym4uQ6rrw2a","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","old_string":"    /// Filters for listing issues.\n    pub const ListFilters = struct {\n        status: ?Status = null,\n        priority: ?Priority = null,\n        priority_min: ?Priority = null,\n        priority_max: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        label_any: []const []const u8 = &[_][]const u8{},\n        title_contains: ?[]const u8 = null,\n        desc_contains: ?[]const u8 = null,\n        notes_contains: ?[]const u8 = null,\n        include_tombstones: bool = false,\n        limit: ?u32 = null,\n        offset: ?u32 = null,\n        order_by: OrderBy = .created_at,\n        order_desc: bool = true,\n\n        pub const OrderBy = enum {\n            created_at,\n            updated_at,\n            priority,\n        };\n    };","new_string":"    /// Filters for listing issues.\n    pub const ListFilters = struct {\n        status: ?Status = null,\n        priority: ?Priority = null,\n        priority_min: ?Priority = null,\n        priority_max: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        label_any: []const []const u8 = &[_][]const u8{},\n        title_contains: ?[]const u8 = null,\n        desc_contains: ?[]const u8 = null,\n        notes_contains: ?[]const u8 = null,\n        include_tombstones: bool = false,\n        overdue: bool = false,\n        include_deferred: bool = false,\n        limit: ?u32 = null,\n        offset: ?u32 = null,\n        order_by: OrderBy = .created_at,\n        order_desc: bool = true,\n\n        pub const OrderBy = enum {\n            created_at,\n            updated_at,\n            priority,\n        };\n    };"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":745,"cache_read_input_tokens":59634,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":745},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"a7ef86c6-c7f1-48a7-b737-01073252b75b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UWtTgP78xvcym4uQ6rrw2a","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/storage/store.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"286b0246-943e-48dc-9080-dda4e4e4612a","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/storage/store.zig","oldString":"    /// Filters for listing issues.\n    pub const ListFilters = struct {\n        status: ?Status = null,\n        priority: ?Priority = null,\n        priority_min: ?Priority = null,\n        priority_max: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        label_any: []const []const u8 = &[_][]const u8{},\n        title_contains: ?[]const u8 = null,\n        desc_contains: ?[]const u8 = null,\n        notes_contains: ?[]const u8 = null,\n        include_tombstones: bool = false,\n        limit: ?u32 = null,\n        offset: ?u32 = null,\n        order_by: OrderBy = .created_at,\n        order_desc: bool = true,\n\n        pub const OrderBy = enum {\n            created_at,\n            updated_at,\n            priority,\n        };\n    };","newString":"    /// Filters for listing issues.\n    pub const ListFilters = struct {\n        status: ?Status = null,\n        priority: ?Priority = null,\n        priority_min: ?Priority = null,\n        priority_max: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        label_any: []const []const u8 = &[_][]const u8{},\n        title_contains: ?[]const u8 = null,\n        desc_contains: ?[]const u8 = null,\n        notes_contains: ?[]const u8 = null,\n        include_tombstones: bool = false,\n        overdue: bool = false,\n        include_deferred: bool = false,\n        limit: ?u32 = null,\n        offset: ?u32 = null,\n        order_by: OrderBy = .created_at,\n        order_desc: bool = true,\n\n        pub const OrderBy = enum {\n            created_at,\n            updated_at,\n            priority,\n        };\n    };","originalFile":"//! In-memory issue store for beads_zig.\n//!\n//! Provides CRUD operations for issues using in-memory storage with:\n//! - Arena allocator for issue memory management\n//! - ArrayList + StringHashMap for fast ID lookup\n//! - Dirty tracking for sync operations\n//! - JSONL persistence via JsonlFile\n\nconst std = @import(\"std\");\nconst JsonlFile = @import(\"jsonl.zig\").JsonlFile;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Rfc3339Timestamp = @import(\"../models/issue.zig\").Rfc3339Timestamp;\nconst OptionalRfc3339Timestamp = @import(\"../models/issue.zig\").OptionalRfc3339Timestamp;\nconst Status = @import(\"../models/status.zig\").Status;\nconst Priority = @import(\"../models/priority.zig\").Priority;\nconst IssueType = @import(\"../models/issue_type.zig\").IssueType;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Comment = @import(\"../models/comment.zig\").Comment;\n\npub const IssueStoreError = error{\n    IssueNotFound,\n    DuplicateId,\n    InvalidIssue,\n    VersionMismatch,\n};\n\n/// Result of loading the store with corruption tracking.\npub const StoreLoadResult = struct {\n    /// Number of corrupt JSONL entries skipped.\n    jsonl_corruption_count: usize = 0,\n    /// Line numbers of corrupt JSONL entries (1-indexed).\n    jsonl_corrupt_lines: []const usize = &.{},\n\n    pub fn hasCorruption(self: StoreLoadResult) bool {\n        return self.jsonl_corruption_count > 0;\n    }\n\n    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n        if (self.jsonl_corrupt_lines.len > 0) {\n            allocator.free(self.jsonl_corrupt_lines);\n        }\n    }\n};\n\npub const IssueStore = struct {\n    allocator: std.mem.Allocator,\n    issues: std.ArrayListUnmanaged(Issue),\n    id_index: std.StringHashMapUnmanaged(usize),\n    dirty_ids: std.StringHashMapUnmanaged(i64),\n    dirty: bool,\n    jsonl_path: []const u8,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, jsonl_path: []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .issues = .{},\n            .id_index = .{},\n            .dirty_ids = .{},\n            .dirty = false,\n            .jsonl_path = jsonl_path,\n        };\n    }\n\n    pub fn deinit(self: *Self) void {\n        for (self.issues.items) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        self.issues.deinit(self.allocator);\n\n        var id_it = self.id_index.keyIterator();\n        while (id_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.id_index.deinit(self.allocator);\n\n        var dirty_it = self.dirty_ids.keyIterator();\n        while (dirty_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.dirty_ids.deinit(self.allocator);\n    }\n\n    /// Load issues from the JSONL file into memory.\n    pub fn loadFromFile(self: *Self) !void {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        const loaded_issues = try jsonl.readAll();\n        defer self.allocator.free(loaded_issues);\n\n        for (loaded_issues) |issue| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n\n            const idx = self.issues.items.len;\n            try self.issues.append(self.allocator, issue);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n\n        self.dirty = false;\n    }\n\n    /// Load issues from the JSONL file with graceful corruption recovery.\n    /// Logs and skips corrupt entries instead of failing.\n    /// Returns statistics about the load including corruption count.\n    pub fn loadFromFileWithRecovery(self: *Self) !StoreLoadResult {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        var load_result = try jsonl.readAllWithRecovery();\n        // Take ownership of corrupt_lines before freeing issues slice\n        const corrupt_lines = load_result.corrupt_lines;\n        load_result.corrupt_lines = &.{}; // Prevent double-free\n        errdefer if (corrupt_lines.len > 0) self.allocator.free(corrupt_lines);\n\n        const loaded_issues = load_result.issues;\n        defer self.allocator.free(loaded_issues);\n\n        for (loaded_issues) |issue| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n\n            const idx = self.issues.items.len;\n            try self.issues.append(self.allocator, issue);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n\n        self.dirty = false;\n\n        return StoreLoadResult{\n            .jsonl_corruption_count = load_result.corruption_count,\n            .jsonl_corrupt_lines = corrupt_lines,\n        };\n    }\n\n    /// Save all issues to the JSONL file.\n    pub fn saveToFile(self: *Self) !void {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        try jsonl.writeAll(self.issues.items);\n        self.dirty = false;\n\n        // Clear dirty tracking\n        var dirty_it = self.dirty_ids.keyIterator();\n        while (dirty_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.dirty_ids.clearRetainingCapacity();\n    }\n\n    /// Insert a new issue into the store.\n    pub fn insert(self: *Self, issue: Issue) !void {\n        if (self.id_index.contains(issue.id)) {\n            return IssueStoreError.DuplicateId;\n        }\n\n        const cloned = try issue.clone(self.allocator);\n        errdefer {\n            var c = cloned;\n            c.deinit(self.allocator);\n        }\n\n        const id_copy = try self.allocator.dupe(u8, cloned.id);\n        errdefer self.allocator.free(id_copy);\n\n        const idx = self.issues.items.len;\n        try self.issues.append(self.allocator, cloned);\n        try self.id_index.put(self.allocator, id_copy, idx);\n\n        try self.markDirty(issue.id);\n    }\n\n    /// Get an issue by ID (without embedded relations).\n    pub fn get(self: *Self, id: []const u8) !?Issue {\n        const idx = self.id_index.get(id) orelse return null;\n        if (idx >= self.issues.items.len) return null;\n\n        return try self.issues.items[idx].clone(self.allocator);\n    }\n\n    /// Get an issue with all embedded relations (labels, deps, comments).\n    /// Since we store everything in-memory, this just returns the issue as-is.\n    pub fn getWithRelations(self: *Self, id: []const u8) !?Issue {\n        return try self.get(id);\n    }\n\n    /// Get a reference to the stored issue (no clone).\n    /// Caller must NOT free or modify the returned issue.\n    pub fn getRef(self: *Self, id: []const u8) ?*Issue {\n        const idx = self.id_index.get(id) orelse return null;\n        if (idx >= self.issues.items.len) return null;\n        return &self.issues.items[idx];\n    }\n\n    /// Fields that can be updated on an issue.\n    pub const IssueUpdate = struct {\n        title: ?[]const u8 = null,\n        description: ?[]const u8 = null,\n        design: ?[]const u8 = null,\n        acceptance_criteria: ?[]const u8 = null,\n        notes: ?[]const u8 = null,\n        status: ?Status = null,\n        priority: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        owner: ?[]const u8 = null,\n        estimated_minutes: ?i32 = null,\n        closed_at: ?i64 = null,\n        close_reason: ?[]const u8 = null,\n        closed_by_session: ?[]const u8 = null,\n        due_at: ?i64 = null,\n        defer_until: ?i64 = null,\n        external_ref: ?[]const u8 = null,\n        source_system: ?[]const u8 = null,\n        pinned: ?bool = null,\n        is_template: ?bool = null,\n        content_hash: ?[]const u8 = null,\n\n        /// Expected version for optimistic locking.\n        /// If set, update will fail with VersionMismatch if issue.version != expected_version.\n        expected_version: ?u64 = null,\n    };\n\n    /// Update an issue with the given fields.\n    /// If updates.expected_version is set, performs optimistic locking check.\n    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {\n        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        // Optimistic locking check\n        if (updates.expected_version) |expected| {\n            if (issue.version != expected) {\n                return IssueStoreError.VersionMismatch;\n            }\n        }\n\n        // Increment version on every update\n        issue.version += 1;\n\n        // Update timestamp\n        issue.updated_at = Rfc3339Timestamp{ .value = now };\n\n        // Apply updates\n        if (updates.title) |v| {\n            self.allocator.free(issue.title);\n            issue.title = try self.allocator.dupe(u8, v);\n        }\n        if (updates.description) |v| {\n            if (issue.description) |d| self.allocator.free(d);\n            issue.description = try self.allocator.dupe(u8, v);\n        }\n        if (updates.design) |v| {\n            if (issue.design) |d| self.allocator.free(d);\n            issue.design = try self.allocator.dupe(u8, v);\n        }\n        if (updates.acceptance_criteria) |v| {\n            if (issue.acceptance_criteria) |a| self.allocator.free(a);\n            issue.acceptance_criteria = try self.allocator.dupe(u8, v);\n        }\n        if (updates.notes) |v| {\n            if (issue.notes) |n| self.allocator.free(n);\n            issue.notes = try self.allocator.dupe(u8, v);\n        }\n        if (updates.status) |v| {\n            freeStatus(issue.status, self.allocator);\n            issue.status = try cloneStatus(v, self.allocator);\n        }\n        if (updates.priority) |v| {\n            issue.priority = v;\n        }\n        if (updates.issue_type) |v| {\n            freeIssueType(issue.issue_type, self.allocator);\n            issue.issue_type = try cloneIssueType(v, self.allocator);\n        }\n        if (updates.assignee) |v| {\n            if (issue.assignee) |a| self.allocator.free(a);\n            issue.assignee = try self.allocator.dupe(u8, v);\n        }\n        if (updates.owner) |v| {\n            if (issue.owner) |o| self.allocator.free(o);\n            issue.owner = try self.allocator.dupe(u8, v);\n        }\n        if (updates.estimated_minutes) |v| {\n            issue.estimated_minutes = v;\n        }\n        if (updates.closed_at) |v| {\n            issue.closed_at = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.close_reason) |v| {\n            if (issue.close_reason) |r| self.allocator.free(r);\n            issue.close_reason = try self.allocator.dupe(u8, v);\n        }\n        if (updates.closed_by_session) |v| {\n            if (issue.closed_by_session) |s| self.allocator.free(s);\n            issue.closed_by_session = try self.allocator.dupe(u8, v);\n        }\n        if (updates.due_at) |v| {\n            issue.due_at = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.defer_until) |v| {\n            issue.defer_until = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.external_ref) |v| {\n            if (issue.external_ref) |e| self.allocator.free(e);\n            issue.external_ref = try self.allocator.dupe(u8, v);\n        }\n        if (updates.source_system) |v| {\n            if (issue.source_system) |s| self.allocator.free(s);\n            issue.source_system = try self.allocator.dupe(u8, v);\n        }\n        if (updates.pinned) |v| {\n            issue.pinned = v;\n        }\n        if (updates.is_template) |v| {\n            issue.is_template = v;\n        }\n        if (updates.content_hash) |v| {\n            if (issue.content_hash) |h| self.allocator.free(h);\n            issue.content_hash = try self.allocator.dupe(u8, v);\n        }\n\n        try self.markDirty(id);\n    }\n\n    /// Soft delete an issue by setting its status to tombstone.\n    pub fn delete(self: *Self, id: []const u8, now: i64) !void {\n        try self.update(id, .{ .status = .tombstone }, now);\n    }\n\n    /// Filters for listing issues.\n    pub const ListFilters = struct {\n        status: ?Status = null,\n        priority: ?Priority = null,\n        priority_min: ?Priority = null,\n        priority_max: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        label_any: []const []const u8 = &[_][]const u8{},\n        title_contains: ?[]const u8 = null,\n        desc_contains: ?[]const u8 = null,\n        notes_contains: ?[]const u8 = null,\n        include_tombstones: bool = false,\n        limit: ?u32 = null,\n        offset: ?u32 = null,\n        order_by: OrderBy = .created_at,\n        order_desc: bool = true,\n\n        pub const OrderBy = enum {\n            created_at,\n            updated_at,\n            priority,\n        };\n    };\n\n    /// List issues with optional filters.\n    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.issues.items) |issue| {\n            // Filter tombstones\n            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n                continue;\n            }\n\n            // Apply filters\n            if (filters.status) |s| {\n                if (!statusEql(issue.status, s)) continue;\n            }\n            if (filters.priority) |p| {\n                if (issue.priority.value != p.value) continue;\n            }\n            if (filters.issue_type) |t| {\n                if (!issueTypeEql(issue.issue_type, t)) continue;\n            }\n            if (filters.assignee) |a| {\n                if (issue.assignee == null) continue;\n                if (!std.mem.eql(u8, issue.assignee.?, a)) continue;\n            }\n            if (filters.label) |lbl| {\n                var found = false;\n                for (issue.labels) |label| {\n                    if (std.mem.eql(u8, label, lbl)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) continue;\n            }\n\n            // label_any: OR logic - issue must have at least ONE of the specified labels\n            if (filters.label_any.len > 0) {\n                var found_any = false;\n                for (filters.label_any) |any_label| {\n                    for (issue.labels) |issue_label| {\n                        if (std.mem.eql(u8, issue_label, any_label)) {\n                            found_any = true;\n                            break;\n                        }\n                    }\n                    if (found_any) break;\n                }\n                if (!found_any) continue;\n            }\n\n            // Priority range filters (lower value = higher priority)\n            if (filters.priority_min) |min_p| {\n                if (issue.priority.value < min_p.value) continue;\n            }\n            if (filters.priority_max) |max_p| {\n                if (issue.priority.value > max_p.value) continue;\n            }\n\n            // Substring filters (case-insensitive)\n            if (filters.title_contains) |query| {\n                if (!containsIgnoreCase(issue.title, query)) continue;\n            }\n            if (filters.desc_contains) |query| {\n                if (issue.description) |desc| {\n                    if (!containsIgnoreCase(desc, query)) continue;\n                } else continue;\n            }\n            if (filters.notes_contains) |query| {\n                if (issue.notes) |notes| {\n                    if (!containsIgnoreCase(notes, query)) continue;\n                } else continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort\n        const SortContext = struct {\n            order_by: ListFilters.OrderBy,\n            order_desc: bool,\n        };\n        const ctx = SortContext{ .order_by = filters.order_by, .order_desc = filters.order_desc };\n\n        std.mem.sortUnstable(Issue, results.items, ctx, struct {\n            fn lessThan(c: SortContext, a: Issue, b: Issue) bool {\n                const cmp: i64 = switch (c.order_by) {\n                    .created_at => a.created_at.value - b.created_at.value,\n                    .updated_at => a.updated_at.value - b.updated_at.value,\n                    .priority => @as(i64, a.priority.value) - @as(i64, b.priority.value),\n                };\n                return if (c.order_desc) cmp > 0 else cmp < 0;\n            }\n        }.lessThan);\n\n        // Apply offset and limit\n        var start: usize = 0;\n        if (filters.offset) |off| {\n            start = @min(off, results.items.len);\n        }\n\n        var end: usize = results.items.len;\n        if (filters.limit) |lim| {\n            end = @min(start + lim, results.items.len);\n        }\n\n        // Free items outside the range\n        for (results.items[0..start]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        for (results.items[end..]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n\n        // Return slice\n        const slice = try self.allocator.dupe(Issue, results.items[start..end]);\n        results.deinit(self.allocator);\n        return slice;\n    }\n\n    /// Result from counting issues.\n    pub const CountResult = struct {\n        key: []const u8,\n        count: u64,\n    };\n\n    /// Count issues, optionally grouped by a field.\n    pub fn count(self: *Self, group_by: ?GroupBy) ![]CountResult {\n        var counts: std.StringHashMapUnmanaged(u64) = .{};\n        defer counts.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const key_str: []const u8 = if (group_by) |g| switch (g) {\n                .status => issue.status.toString(),\n                .priority => switch (issue.priority.value) {\n                    0 => \"0\",\n                    1 => \"1\",\n                    2 => \"2\",\n                    3 => \"3\",\n                    4 => \"4\",\n                    else => unreachable,\n                },\n                .issue_type => issue.issue_type.toString(),\n                .assignee => issue.assignee orelse \"(unassigned)\",\n            } else \"total\";\n\n            const entry = counts.getOrPutValue(self.allocator, key_str, 0) catch continue;\n            entry.value_ptr.* += 1;\n        }\n\n        var results: std.ArrayListUnmanaged(CountResult) = .{};\n        errdefer {\n            for (results.items) |r| {\n                self.allocator.free(r.key);\n            }\n            results.deinit(self.allocator);\n        }\n\n        var it = counts.iterator();\n        while (it.next()) |entry| {\n            const key = try self.allocator.dupe(u8, entry.key_ptr.*);\n            try results.append(self.allocator, .{ .key = key, .count = entry.value_ptr.* });\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    pub const GroupBy = enum {\n        status,\n        priority,\n        issue_type,\n        assignee,\n    };\n\n    /// Check if an issue exists.\n    pub fn exists(self: *Self, id: []const u8) !bool {\n        return self.id_index.contains(id);\n    }\n\n    /// Get labels for an issue.\n    pub fn getLabels(self: *Self, issue_id: []const u8) ![]const []const u8 {\n        const idx = self.id_index.get(issue_id) orelse return &[_][]const u8{};\n        if (idx >= self.issues.items.len) return &[_][]const u8{};\n\n        const issue = self.issues.items[idx];\n        if (issue.labels.len == 0) return &[_][]const u8{};\n\n        const labels = try self.allocator.alloc([]const u8, issue.labels.len);\n        errdefer self.allocator.free(labels);\n\n        for (issue.labels, 0..) |label, i| {\n            labels[i] = try self.allocator.dupe(u8, label);\n        }\n        return labels;\n    }\n\n    /// Add a label to an issue.\n    pub fn addLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        // Check if already exists\n        for (issue.labels) |existing| {\n            if (std.mem.eql(u8, existing, label)) return;\n        }\n\n        // Add new label\n        const label_copy = try self.allocator.dupe(u8, label);\n        errdefer self.allocator.free(label_copy);\n\n        const new_labels = try self.allocator.alloc([]const u8, issue.labels.len + 1);\n        @memcpy(new_labels[0..issue.labels.len], issue.labels);\n        new_labels[issue.labels.len] = label_copy;\n\n        if (issue.labels.len > 0) {\n            self.allocator.free(issue.labels);\n        }\n        issue.labels = new_labels;\n\n        try self.markDirty(issue_id);\n    }\n\n    /// Remove a label from an issue.\n    pub fn removeLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        var found_idx: ?usize = null;\n        for (issue.labels, 0..) |existing, i| {\n            if (std.mem.eql(u8, existing, label)) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx) |fi| {\n            self.allocator.free(issue.labels[fi]);\n\n            if (issue.labels.len == 1) {\n                self.allocator.free(issue.labels);\n                issue.labels = &[_][]const u8{};\n            } else {\n                const new_labels = try self.allocator.alloc([]const u8, issue.labels.len - 1);\n                var j: usize = 0;\n                for (issue.labels, 0..) |lbl, i| {\n                    if (i != fi) {\n                        new_labels[j] = lbl;\n                        j += 1;\n                    }\n                }\n                self.allocator.free(issue.labels);\n                issue.labels = new_labels;\n            }\n\n            try self.markDirty(issue_id);\n        }\n    }\n\n    /// Get dependencies for an issue.\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]const Dependency {\n        const idx = self.id_index.get(issue_id) orelse return &[_]Dependency{};\n        if (idx >= self.issues.items.len) return &[_]Dependency{};\n\n        const issue = self.issues.items[idx];\n        if (issue.dependencies.len == 0) return &[_]Dependency{};\n\n        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n        errdefer self.allocator.free(deps);\n\n        for (issue.dependencies, 0..) |dep, i| {\n            deps[i] = try cloneDependency(dep, self.allocator);\n        }\n        return deps;\n    }\n\n    /// Get comments for an issue.\n    pub fn getComments(self: *Self, issue_id: []const u8) ![]const Comment {\n        const idx = self.id_index.get(issue_id) orelse return &[_]Comment{};\n        if (idx >= self.issues.items.len) return &[_]Comment{};\n\n        const issue = self.issues.items[idx];\n        if (issue.comments.len == 0) return &[_]Comment{};\n\n        const comments = try self.allocator.alloc(Comment, issue.comments.len);\n        errdefer self.allocator.free(comments);\n\n        for (issue.comments, 0..) |c, i| {\n            comments[i] = try cloneComment(c, self.allocator);\n        }\n        return comments;\n    }\n\n    /// Add a comment to an issue.\n    pub fn addComment(self: *Self, issue_id: []const u8, comment: Comment) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        const cloned = try cloneComment(comment, self.allocator);\n        errdefer freeComment(@constCast(&cloned), self.allocator);\n\n        const new_comments = try self.allocator.alloc(Comment, issue.comments.len + 1);\n        @memcpy(new_comments[0..issue.comments.len], issue.comments);\n        new_comments[issue.comments.len] = cloned;\n\n        if (issue.comments.len > 0) {\n            self.allocator.free(issue.comments);\n        }\n        issue.comments = new_comments;\n\n        try self.markDirty(issue_id);\n    }\n\n    /// Mark an issue as dirty for sync.\n    pub fn markDirty(self: *Self, id: []const u8) !void {\n        self.dirty = true;\n        const now = std.time.timestamp();\n\n        if (!self.dirty_ids.contains(id)) {\n            const id_copy = try self.allocator.dupe(u8, id);\n            try self.dirty_ids.put(self.allocator, id_copy, now);\n        } else {\n            self.dirty_ids.getPtr(id).?.* = now;\n        }\n    }\n\n    /// Clear dirty flag for an issue.\n    pub fn clearDirty(self: *Self, id: []const u8) !void {\n        if (self.dirty_ids.fetchRemove(id)) |kv| {\n            self.allocator.free(kv.key);\n        }\n    }\n\n    /// Get all dirty issue IDs.\n    pub fn getDirtyIds(self: *Self) ![][]const u8 {\n        var ids: std.ArrayListUnmanaged([]const u8) = .{};\n        errdefer {\n            for (ids.items) |id| {\n                self.allocator.free(id);\n            }\n            ids.deinit(self.allocator);\n        }\n\n        var it = self.dirty_ids.keyIterator();\n        while (it.next()) |key| {\n            const id = try self.allocator.dupe(u8, key.*);\n            try ids.append(self.allocator, id);\n        }\n\n        return ids.toOwnedSlice(self.allocator);\n    }\n\n    /// Check if the store has unsaved changes.\n    pub fn isDirty(self: *Self) bool {\n        return self.dirty;\n    }\n\n    /// Get total number of issues (excluding tombstones).\n    pub fn countTotal(self: *Self) usize {\n        var total: usize = 0;\n        for (self.issues.items) |issue| {\n            if (!statusEql(issue.status, .tombstone)) {\n                total += 1;\n            }\n        }\n        return total;\n    }\n\n    /// Get all issues as a slice (no clone, read-only).\n    pub fn getAllRef(self: *Self) []const Issue {\n        return self.issues.items;\n    }\n\n    /// Suggestion for similar ID lookup.\n    pub const IdSuggestion = struct {\n        id: []const u8,\n        title: []const u8,\n    };\n\n    /// Find similar IDs when a lookup fails (for \"did you mean\" suggestions).\n    /// Uses prefix matching and Levenshtein-like scoring.\n    /// Returns up to `max_count` suggestions, caller must free.\n    pub fn findSimilarIds(self: *Self, target: []const u8, max_count: usize) ![]IdSuggestion {\n        if (self.issues.items.len == 0) return &[_]IdSuggestion{};\n\n        const Scored = struct {\n            id: []const u8,\n            title: []const u8,\n            score: i32,\n        };\n\n        var candidates: std.ArrayListUnmanaged(Scored) = .{};\n        defer candidates.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const score = computeSimilarity(target, issue.id);\n            if (score > 0) {\n                try candidates.append(self.allocator, .{\n                    .id = issue.id,\n                    .title = issue.title,\n                    .score = score,\n                });\n            }\n        }\n\n        if (candidates.items.len == 0) return &[_]IdSuggestion{};\n\n        // Sort by score descending\n        std.mem.sortUnstable(Scored, candidates.items, {}, struct {\n            fn lessThan(_: void, a: Scored, b: Scored) bool {\n                return a.score > b.score;\n            }\n        }.lessThan);\n\n        const result_count = @min(max_count, candidates.items.len);\n        var suggestions = try self.allocator.alloc(IdSuggestion, result_count);\n        errdefer self.allocator.free(suggestions);\n\n        for (0..result_count) |i| {\n            suggestions[i] = .{\n                .id = try self.allocator.dupe(u8, candidates.items[i].id),\n                .title = try self.allocator.dupe(u8, candidates.items[i].title),\n            };\n        }\n\n        return suggestions;\n    }\n\n    /// Free suggestions returned by findSimilarIds.\n    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n        for (suggestions) |s| {\n            self.allocator.free(s.id);\n            self.allocator.free(s.title);\n        }\n        self.allocator.free(suggestions);\n    }\n};\n\n/// Compute similarity score between target and candidate ID.\n/// Higher score = more similar.\nfn computeSimilarity(target: []const u8, candidate: []const u8) i32 {\n    var score: i32 = 0;\n\n    // Exact prefix match (bd-abc matches bd-abc123)\n    if (std.mem.startsWith(u8, candidate, target)) {\n        score += 100;\n    }\n    // Candidate is prefix of target (bd-abc123 starts with bd-abc)\n    else if (std.mem.startsWith(u8, target, candidate)) {\n        score += 80;\n    }\n\n    // Common prefix length\n    var common_prefix: usize = 0;\n    const min_len = @min(target.len, candidate.len);\n    for (0..min_len) |i| {\n        if (target[i] == candidate[i]) {\n            common_prefix += 1;\n        } else {\n            break;\n        }\n    }\n    score += @intCast(common_prefix * 5);\n\n    // Contains target as substring\n    if (std.mem.indexOf(u8, candidate, target) != null) {\n        score += 30;\n    }\n\n    // Similar length bonus\n    const len_diff: i32 = @intCast(@abs(@as(i64, @intCast(target.len)) - @as(i64, @intCast(candidate.len))));\n    if (len_diff <= 2) {\n        score += 10;\n    }\n\n    return score;\n}\n\n// Helper functions\nfn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn issueTypeEql(a: IssueType, b: IssueType) bool {\n    const Tag = std.meta.Tag(IssueType);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\npub fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {\n    if (needle.len == 0) return true;\n    if (needle.len > haystack.len) return false;\n\n    const end = haystack.len - needle.len + 1;\n    var i: usize = 0;\n    while (i < end) : (i += 1) {\n        var match = true;\n        for (needle, 0..) |nc, j| {\n            const hc = haystack[i + j];\n            if (std.ascii.toLower(hc) != std.ascii.toLower(nc)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n\nfn cloneStatus(status: Status, allocator: std.mem.Allocator) !Status {\n    return switch (status) {\n        .custom => |s| Status{ .custom = try allocator.dupe(u8, s) },\n        else => status,\n    };\n}\n\nfn freeStatus(status: Status, allocator: std.mem.Allocator) void {\n    switch (status) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n}\n\nfn cloneIssueType(issue_type: IssueType, allocator: std.mem.Allocator) !IssueType {\n    return switch (issue_type) {\n        .custom => |s| IssueType{ .custom = try allocator.dupe(u8, s) },\n        else => issue_type,\n    };\n}\n\nfn freeIssueType(issue_type: IssueType, allocator: std.mem.Allocator) void {\n    switch (issue_type) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n}\n\nfn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n    var result: Dependency = undefined;\n\n    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n    errdefer allocator.free(result.issue_id);\n\n    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n    errdefer allocator.free(result.depends_on_id);\n\n    result.dep_type = switch (dep.dep_type) {\n        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n        else => dep.dep_type,\n    };\n\n    result.created_at = dep.created_at;\n    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n\n    return result;\n}\n\nfn cloneComment(comment: Comment, allocator: std.mem.Allocator) !Comment {\n    return Comment{\n        .id = comment.id,\n        .issue_id = try allocator.dupe(u8, comment.issue_id),\n        .author = try allocator.dupe(u8, comment.author),\n        .body = try allocator.dupe(u8, comment.body),\n        .created_at = comment.created_at,\n    };\n}\n\nfn freeComment(comment: *Comment, allocator: std.mem.Allocator) void {\n    allocator.free(comment.issue_id);\n    allocator.free(comment.author);\n    allocator.free(comment.body);\n}\n\n// --- Tests ---\n\ntest \"IssueStore insert and get\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-test1\", \"Test Issue\", 1706540000);\n    try store.insert(issue);\n\n    try std.testing.expect(try store.exists(\"bd-test1\"));\n\n    var retrieved = (try store.get(\"bd-test1\")).?;\n    defer retrieved.deinit(allocator);\n\n    try std.testing.expectEqualStrings(\"bd-test1\", retrieved.id);\n    try std.testing.expectEqualStrings(\"Test Issue\", retrieved.title);\n}\n\ntest \"IssueStore get returns null for missing\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const result = try store.get(\"bd-nonexistent\");\n    try std.testing.expect(result == null);\n}\n\ntest \"IssueStore update modifies fields\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-update\", \"Original Title\", 1706540000);\n    try store.insert(issue);\n\n    try store.update(\"bd-update\", .{\n        .title = \"Updated Title\",\n        .status = .in_progress,\n        .priority = Priority.HIGH,\n    }, 1706550000);\n\n    var updated = (try store.get(\"bd-update\")).?;\n    defer updated.deinit(allocator);\n\n    try std.testing.expectEqualStrings(\"Updated Title\", updated.title);\n    try std.testing.expect(statusEql(updated.status, .in_progress));\n    try std.testing.expectEqual(Priority.HIGH, updated.priority);\n}\n\ntest \"IssueStore update increments version\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-version\", \"Version Test\", 1706540000);\n    try store.insert(issue);\n\n    // Initial version should be 1\n    var v1 = (try store.get(\"bd-version\")).?;\n    defer v1.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 1), v1.version);\n\n    // Update should increment version\n    try store.update(\"bd-version\", .{ .title = \"Updated\" }, 1706550000);\n\n    var v2 = (try store.get(\"bd-version\")).?;\n    defer v2.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 2), v2.version);\n\n    // Another update should increment again\n    try store.update(\"bd-version\", .{ .title = \"Updated Again\" }, 1706560000);\n\n    var v3 = (try store.get(\"bd-version\")).?;\n    defer v3.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 3), v3.version);\n}\n\ntest \"IssueStore update with expected_version succeeds on match\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-optlock\", \"Optimistic Lock Test\", 1706540000);\n    try store.insert(issue);\n\n    // Get current version (1)\n    var current = (try store.get(\"bd-optlock\")).?;\n    const current_version = current.version;\n    current.deinit(allocator);\n\n    // Update with correct expected version should succeed\n    try store.update(\"bd-optlock\", .{\n        .title = \"Updated with lock\",\n        .expected_version = current_version,\n    }, 1706550000);\n\n    var updated = (try store.get(\"bd-optlock\")).?;\n    defer updated.deinit(allocator);\n    try std.testing.expectEqualStrings(\"Updated with lock\", updated.title);\n    try std.testing.expectEqual(@as(u64, 2), updated.version);\n}\n\ntest \"IssueStore update with expected_version fails on mismatch\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-conflict\", \"Conflict Test\", 1706540000);\n    try store.insert(issue);\n\n    // Update once to increment version to 2\n    try store.update(\"bd-conflict\", .{ .title = \"First Update\" }, 1706550000);\n\n    // Try to update with stale expected_version (1 instead of 2)\n    const result = store.update(\"bd-conflict\", .{\n        .title = \"Conflicting Update\",\n        .expected_version = 1, // Stale version\n    }, 1706560000);\n\n    try std.testing.expectError(IssueStoreError.VersionMismatch, result);\n\n    // Verify original update is preserved\n    var preserved = (try store.get(\"bd-conflict\")).?;\n    defer preserved.deinit(allocator);\n    try std.testing.expectEqualStrings(\"First Update\", preserved.title);\n    try std.testing.expectEqual(@as(u64, 2), preserved.version);\n}\n\ntest \"IssueStore delete sets tombstone\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-delete\", \"To Delete\", 1706540000);\n    try store.insert(issue);\n\n    try store.delete(\"bd-delete\", 1706550000);\n\n    var deleted = (try store.get(\"bd-delete\")).?;\n    defer deleted.deinit(allocator);\n\n    try std.testing.expect(statusEql(deleted.status, .tombstone));\n}\n\ntest \"IssueStore list returns issues\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-list1\", \"Issue 1\", 1706540000));\n    try store.insert(Issue.init(\"bd-list2\", \"Issue 2\", 1706550000));\n    try store.insert(Issue.init(\"bd-list3\", \"Issue 3\", 1706560000));\n\n    const issues = try store.list(.{});\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    try std.testing.expectEqual(@as(usize, 3), issues.len);\n}\n\ntest \"IssueStore list excludes tombstones\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-active\", \"Active\", 1706540000));\n    try store.insert(Issue.init(\"bd-deleted\", \"Deleted\", 1706550000));\n    try store.delete(\"bd-deleted\", 1706560000);\n\n    const issues = try store.list(.{});\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), issues.len);\n    try std.testing.expectEqualStrings(\"bd-active\", issues[0].id);\n}\n\ntest \"IssueStore dirty tracking\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-dirty\", \"Dirty Test\", 1706540000);\n    try store.insert(issue);\n\n    try std.testing.expect(store.isDirty());\n\n    const dirty_ids = try store.getDirtyIds();\n    defer {\n        for (dirty_ids) |id| {\n            allocator.free(id);\n        }\n        allocator.free(dirty_ids);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), dirty_ids.len);\n    try std.testing.expectEqualStrings(\"bd-dirty\", dirty_ids[0]);\n\n    try store.clearDirty(\"bd-dirty\");\n\n    const after_clear = try store.getDirtyIds();\n    defer allocator.free(after_clear);\n\n    try std.testing.expectEqual(@as(usize, 0), after_clear.len);\n}\n\ntest \"IssueStore addLabel and removeLabel\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-labels\", \"Label Test\", 1706540000));\n\n    try store.addLabel(\"bd-labels\", \"bug\");\n    try store.addLabel(\"bd-labels\", \"urgent\");\n\n    const labels = try store.getLabels(\"bd-labels\");\n    defer {\n        for (labels) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(labels);\n    }\n\n    try std.testing.expectEqual(@as(usize, 2), labels.len);\n\n    try store.removeLabel(\"bd-labels\", \"bug\");\n\n    const after_remove = try store.getLabels(\"bd-labels\");\n    defer {\n        for (after_remove) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(after_remove);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), after_remove.len);\n}\n\ntest \"StoreLoadResult.hasCorruption\" {\n    var result = StoreLoadResult{\n        .jsonl_corruption_count = 0,\n    };\n    try std.testing.expect(!result.hasCorruption());\n\n    result.jsonl_corruption_count = 3;\n    try std.testing.expect(result.hasCorruption());\n}\n\ntest \"IssueStore loadFromFileWithRecovery handles corrupt entries\" {\n    const allocator = std.testing.allocator;\n    const test_util = @import(\"../test_util.zig\");\n    const test_dir = try test_util.createTestDir(allocator, \"store_recovery\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"issues.jsonl\" });\n    defer allocator.free(test_path);\n\n    // Write a file with mixed valid and corrupt entries\n    // Use full Issue JSON format (all fields required by parser)\n    {\n        const file = try std.fs.cwd().createFile(test_path, .{});\n        defer file.close();\n\n        // Valid issue\n        const valid1 = \"{\\\"id\\\":\\\"bd-valid1\\\",\\\"content_hash\\\":null,\\\"title\\\":\\\"Valid Issue\\\",\\\"description\\\":null,\\\"design\\\":null,\\\"acceptance_criteria\\\":null,\\\"notes\\\":null,\\\"status\\\":\\\"open\\\",\\\"priority\\\":2,\\\"issue_type\\\":\\\"task\\\",\\\"assignee\\\":null,\\\"owner\\\":null,\\\"created_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"created_by\\\":null,\\\"updated_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"closed_at\\\":null,\\\"close_reason\\\":null,\\\"due_at\\\":null,\\\"defer_until\\\":null,\\\"estimated_minutes\\\":null,\\\"external_ref\\\":null,\\\"source_system\\\":null,\\\"pinned\\\":false,\\\"is_template\\\":false,\\\"labels\\\":[],\\\"dependencies\\\":[],\\\"comments\\\":[]}\\n\";\n        try file.writeAll(valid1);\n\n        // Corrupt entry\n        try file.writeAll(\"{invalid json here}\\n\");\n\n        // Another valid issue\n        const valid2 = \"{\\\"id\\\":\\\"bd-valid2\\\",\\\"content_hash\\\":null,\\\"title\\\":\\\"Another Valid Issue\\\",\\\"description\\\":null,\\\"design\\\":null,\\\"acceptance_criteria\\\":null,\\\"notes\\\":null,\\\"status\\\":\\\"open\\\",\\\"priority\\\":2,\\\"issue_type\\\":\\\"task\\\",\\\"assignee\\\":null,\\\"owner\\\":null,\\\"created_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"created_by\\\":null,\\\"updated_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"closed_at\\\":null,\\\"close_reason\\\":null,\\\"due_at\\\":null,\\\"defer_until\\\":null,\\\"estimated_minutes\\\":null,\\\"external_ref\\\":null,\\\"source_system\\\":null,\\\"pinned\\\":false,\\\"is_template\\\":false,\\\"labels\\\":[],\\\"dependencies\\\":[],\\\"comments\\\":[]}\\n\";\n        try file.writeAll(valid2);\n    }\n\n    var store = IssueStore.init(allocator, test_path);\n    defer store.deinit();\n\n    var result = try store.loadFromFileWithRecovery();\n    defer result.deinit(allocator);\n\n    // Should have loaded 2 valid issues\n    try std.testing.expectEqual(@as(usize, 2), store.issues.items.len);\n\n    // Should have tracked 1 corrupt entry\n    try std.testing.expectEqual(@as(usize, 1), result.jsonl_corruption_count);\n    try std.testing.expect(result.hasCorruption());\n\n    // Verify the correct issues were loaded\n    try std.testing.expect(try store.exists(\"bd-valid1\"));\n    try std.testing.expect(try store.exists(\"bd-valid2\"));\n}\n","structuredPatch":[{"oldStart":341,"oldLines":6,"newStart":341,"newLines":8,"lines":["         desc_contains: ?[]const u8 = null,","         notes_contains: ?[]const u8 = null,","         include_tombstones: bool = false,","+        overdue: bool = false,","+        include_deferred: bool = false,","         limit: ?u32 = null,","         offset: ?u32 = null,","         order_by: OrderBy = .created_at,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XGhQxNPMieXHkPnipxtmv4","type":"message","role":"assistant","content":[{"type":"text","text":"Now add the filtering logic in the `list()` function. Let me read the exact location for adding the filter logic."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":721,"cache_read_input_tokens":60379,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":721},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"8133cd69-6bd8-4b7b-bf80-cc0acb1a5027"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XGhQxNPMieXHkPnipxtmv4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BUgpdJDGSwPgFiEopGUgrD","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","offset":1,"limit":40}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":721,"cache_read_input_tokens":60379,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":721},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"ec1e8eb8-0a10-4d81-8807-37917a0f0d0b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BUgpdJDGSwPgFiEopGUgrD","type":"tool_result","content":"     1→//! In-memory issue store for beads_zig.\n     2→//!\n     3→//! Provides CRUD operations for issues using in-memory storage with:\n     4→//! - Arena allocator for issue memory management\n     5→//! - ArrayList + StringHashMap for fast ID lookup\n     6→//! - Dirty tracking for sync operations\n     7→//! - JSONL persistence via JsonlFile\n     8→\n     9→const std = @import(\"std\");\n    10→const JsonlFile = @import(\"jsonl.zig\").JsonlFile;\n    11→const Issue = @import(\"../models/issue.zig\").Issue;\n    12→const Rfc3339Timestamp = @import(\"../models/issue.zig\").Rfc3339Timestamp;\n    13→const OptionalRfc3339Timestamp = @import(\"../models/issue.zig\").OptionalRfc3339Timestamp;\n    14→const Status = @import(\"../models/status.zig\").Status;\n    15→const Priority = @import(\"../models/priority.zig\").Priority;\n    16→const IssueType = @import(\"../models/issue_type.zig\").IssueType;\n    17→const Dependency = @import(\"../models/dependency.zig\").Dependency;\n    18→const DependencyType = @import(\"../models/dependency.zig\").DependencyType;\n    19→const Comment = @import(\"../models/comment.zig\").Comment;\n    20→\n    21→pub const IssueStoreError = error{\n    22→    IssueNotFound,\n    23→    DuplicateId,\n    24→    InvalidIssue,\n    25→    VersionMismatch,\n    26→};\n    27→\n    28→/// Result of loading the store with corruption tracking.\n    29→pub const StoreLoadResult = struct {\n    30→    /// Number of corrupt JSONL entries skipped.\n    31→    jsonl_corruption_count: usize = 0,\n    32→    /// Line numbers of corrupt JSONL entries (1-indexed).\n    33→    jsonl_corrupt_lines: []const usize = &.{},\n    34→\n    35→    pub fn hasCorruption(self: StoreLoadResult) bool {\n    36→        return self.jsonl_corruption_count > 0;\n    37→    }\n    38→\n    39→    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n    40→        if (self.jsonl_corrupt_lines.len > 0) {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"7e2499f5-8dd4-425f-87ae-c32944fa594e","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/storage/store.zig","content":"//! In-memory issue store for beads_zig.\n//!\n//! Provides CRUD operations for issues using in-memory storage with:\n//! - Arena allocator for issue memory management\n//! - ArrayList + StringHashMap for fast ID lookup\n//! - Dirty tracking for sync operations\n//! - JSONL persistence via JsonlFile\n\nconst std = @import(\"std\");\nconst JsonlFile = @import(\"jsonl.zig\").JsonlFile;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Rfc3339Timestamp = @import(\"../models/issue.zig\").Rfc3339Timestamp;\nconst OptionalRfc3339Timestamp = @import(\"../models/issue.zig\").OptionalRfc3339Timestamp;\nconst Status = @import(\"../models/status.zig\").Status;\nconst Priority = @import(\"../models/priority.zig\").Priority;\nconst IssueType = @import(\"../models/issue_type.zig\").IssueType;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Comment = @import(\"../models/comment.zig\").Comment;\n\npub const IssueStoreError = error{\n    IssueNotFound,\n    DuplicateId,\n    InvalidIssue,\n    VersionMismatch,\n};\n\n/// Result of loading the store with corruption tracking.\npub const StoreLoadResult = struct {\n    /// Number of corrupt JSONL entries skipped.\n    jsonl_corruption_count: usize = 0,\n    /// Line numbers of corrupt JSONL entries (1-indexed).\n    jsonl_corrupt_lines: []const usize = &.{},\n\n    pub fn hasCorruption(self: StoreLoadResult) bool {\n        return self.jsonl_corruption_count > 0;\n    }\n\n    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n        if (self.jsonl_corrupt_lines.len > 0) {","numLines":40,"startLine":1,"totalLines":1258}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VZQDN18tipXxQbC1kTTjuF","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the filtering logic after the existing substring filters. Let me add the overdue and include_deferred filter logic."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1037,"cache_read_input_tokens":61100,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1037},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"116cbf74-059f-4404-9cbf-23684c6cda31"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VZQDN18tipXxQbC1kTTjuF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0157pWCzCwaUK7SDZLYpontD","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","old_string":"            // Substring filters (case-insensitive)\n            if (filters.title_contains) |query| {\n                if (!containsIgnoreCase(issue.title, query)) continue;\n            }\n            if (filters.desc_contains) |query| {\n                if (issue.description) |desc| {\n                    if (!containsIgnoreCase(desc, query)) continue;\n                } else continue;\n            }\n            if (filters.notes_contains) |query| {\n                if (issue.notes) |notes| {\n                    if (!containsIgnoreCase(notes, query)) continue;\n                } else continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));","new_string":"            // Substring filters (case-insensitive)\n            if (filters.title_contains) |query| {\n                if (!containsIgnoreCase(issue.title, query)) continue;\n            }\n            if (filters.desc_contains) |query| {\n                if (issue.description) |desc| {\n                    if (!containsIgnoreCase(desc, query)) continue;\n                } else continue;\n            }\n            if (filters.notes_contains) |query| {\n                if (issue.notes) |notes| {\n                    if (!containsIgnoreCase(notes, query)) continue;\n                } else continue;\n            }\n\n            // Overdue filter: only include issues past their due date\n            if (filters.overdue) {\n                const now = std.time.timestamp();\n                if (issue.due_at.value) |due_time| {\n                    if (due_time >= now) continue;\n                } else continue;\n            }\n\n            // Deferred filter: skip deferred issues unless explicitly included\n            if (!filters.include_deferred and statusEql(issue.status, .deferred)) {\n                continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1037,"cache_read_input_tokens":61100,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1037},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"74e2b0b1-5111-4fb5-8f06-30f6adda2e7a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0157pWCzCwaUK7SDZLYpontD","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/storage/store.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"7b15ad1d-63ba-4e09-b470-5cae5f7f3699","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/storage/store.zig","oldString":"            // Substring filters (case-insensitive)\n            if (filters.title_contains) |query| {\n                if (!containsIgnoreCase(issue.title, query)) continue;\n            }\n            if (filters.desc_contains) |query| {\n                if (issue.description) |desc| {\n                    if (!containsIgnoreCase(desc, query)) continue;\n                } else continue;\n            }\n            if (filters.notes_contains) |query| {\n                if (issue.notes) |notes| {\n                    if (!containsIgnoreCase(notes, query)) continue;\n                } else continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));","newString":"            // Substring filters (case-insensitive)\n            if (filters.title_contains) |query| {\n                if (!containsIgnoreCase(issue.title, query)) continue;\n            }\n            if (filters.desc_contains) |query| {\n                if (issue.description) |desc| {\n                    if (!containsIgnoreCase(desc, query)) continue;\n                } else continue;\n            }\n            if (filters.notes_contains) |query| {\n                if (issue.notes) |notes| {\n                    if (!containsIgnoreCase(notes, query)) continue;\n                } else continue;\n            }\n\n            // Overdue filter: only include issues past their due date\n            if (filters.overdue) {\n                const now = std.time.timestamp();\n                if (issue.due_at.value) |due_time| {\n                    if (due_time >= now) continue;\n                } else continue;\n            }\n\n            // Deferred filter: skip deferred issues unless explicitly included\n            if (!filters.include_deferred and statusEql(issue.status, .deferred)) {\n                continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));","originalFile":"//! In-memory issue store for beads_zig.\n//!\n//! Provides CRUD operations for issues using in-memory storage with:\n//! - Arena allocator for issue memory management\n//! - ArrayList + StringHashMap for fast ID lookup\n//! - Dirty tracking for sync operations\n//! - JSONL persistence via JsonlFile\n\nconst std = @import(\"std\");\nconst JsonlFile = @import(\"jsonl.zig\").JsonlFile;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Rfc3339Timestamp = @import(\"../models/issue.zig\").Rfc3339Timestamp;\nconst OptionalRfc3339Timestamp = @import(\"../models/issue.zig\").OptionalRfc3339Timestamp;\nconst Status = @import(\"../models/status.zig\").Status;\nconst Priority = @import(\"../models/priority.zig\").Priority;\nconst IssueType = @import(\"../models/issue_type.zig\").IssueType;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Comment = @import(\"../models/comment.zig\").Comment;\n\npub const IssueStoreError = error{\n    IssueNotFound,\n    DuplicateId,\n    InvalidIssue,\n    VersionMismatch,\n};\n\n/// Result of loading the store with corruption tracking.\npub const StoreLoadResult = struct {\n    /// Number of corrupt JSONL entries skipped.\n    jsonl_corruption_count: usize = 0,\n    /// Line numbers of corrupt JSONL entries (1-indexed).\n    jsonl_corrupt_lines: []const usize = &.{},\n\n    pub fn hasCorruption(self: StoreLoadResult) bool {\n        return self.jsonl_corruption_count > 0;\n    }\n\n    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n        if (self.jsonl_corrupt_lines.len > 0) {\n            allocator.free(self.jsonl_corrupt_lines);\n        }\n    }\n};\n\npub const IssueStore = struct {\n    allocator: std.mem.Allocator,\n    issues: std.ArrayListUnmanaged(Issue),\n    id_index: std.StringHashMapUnmanaged(usize),\n    dirty_ids: std.StringHashMapUnmanaged(i64),\n    dirty: bool,\n    jsonl_path: []const u8,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, jsonl_path: []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .issues = .{},\n            .id_index = .{},\n            .dirty_ids = .{},\n            .dirty = false,\n            .jsonl_path = jsonl_path,\n        };\n    }\n\n    pub fn deinit(self: *Self) void {\n        for (self.issues.items) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        self.issues.deinit(self.allocator);\n\n        var id_it = self.id_index.keyIterator();\n        while (id_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.id_index.deinit(self.allocator);\n\n        var dirty_it = self.dirty_ids.keyIterator();\n        while (dirty_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.dirty_ids.deinit(self.allocator);\n    }\n\n    /// Load issues from the JSONL file into memory.\n    pub fn loadFromFile(self: *Self) !void {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        const loaded_issues = try jsonl.readAll();\n        defer self.allocator.free(loaded_issues);\n\n        for (loaded_issues) |issue| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n\n            const idx = self.issues.items.len;\n            try self.issues.append(self.allocator, issue);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n\n        self.dirty = false;\n    }\n\n    /// Load issues from the JSONL file with graceful corruption recovery.\n    /// Logs and skips corrupt entries instead of failing.\n    /// Returns statistics about the load including corruption count.\n    pub fn loadFromFileWithRecovery(self: *Self) !StoreLoadResult {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        var load_result = try jsonl.readAllWithRecovery();\n        // Take ownership of corrupt_lines before freeing issues slice\n        const corrupt_lines = load_result.corrupt_lines;\n        load_result.corrupt_lines = &.{}; // Prevent double-free\n        errdefer if (corrupt_lines.len > 0) self.allocator.free(corrupt_lines);\n\n        const loaded_issues = load_result.issues;\n        defer self.allocator.free(loaded_issues);\n\n        for (loaded_issues) |issue| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n\n            const idx = self.issues.items.len;\n            try self.issues.append(self.allocator, issue);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n\n        self.dirty = false;\n\n        return StoreLoadResult{\n            .jsonl_corruption_count = load_result.corruption_count,\n            .jsonl_corrupt_lines = corrupt_lines,\n        };\n    }\n\n    /// Save all issues to the JSONL file.\n    pub fn saveToFile(self: *Self) !void {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        try jsonl.writeAll(self.issues.items);\n        self.dirty = false;\n\n        // Clear dirty tracking\n        var dirty_it = self.dirty_ids.keyIterator();\n        while (dirty_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.dirty_ids.clearRetainingCapacity();\n    }\n\n    /// Insert a new issue into the store.\n    pub fn insert(self: *Self, issue: Issue) !void {\n        if (self.id_index.contains(issue.id)) {\n            return IssueStoreError.DuplicateId;\n        }\n\n        const cloned = try issue.clone(self.allocator);\n        errdefer {\n            var c = cloned;\n            c.deinit(self.allocator);\n        }\n\n        const id_copy = try self.allocator.dupe(u8, cloned.id);\n        errdefer self.allocator.free(id_copy);\n\n        const idx = self.issues.items.len;\n        try self.issues.append(self.allocator, cloned);\n        try self.id_index.put(self.allocator, id_copy, idx);\n\n        try self.markDirty(issue.id);\n    }\n\n    /// Get an issue by ID (without embedded relations).\n    pub fn get(self: *Self, id: []const u8) !?Issue {\n        const idx = self.id_index.get(id) orelse return null;\n        if (idx >= self.issues.items.len) return null;\n\n        return try self.issues.items[idx].clone(self.allocator);\n    }\n\n    /// Get an issue with all embedded relations (labels, deps, comments).\n    /// Since we store everything in-memory, this just returns the issue as-is.\n    pub fn getWithRelations(self: *Self, id: []const u8) !?Issue {\n        return try self.get(id);\n    }\n\n    /// Get a reference to the stored issue (no clone).\n    /// Caller must NOT free or modify the returned issue.\n    pub fn getRef(self: *Self, id: []const u8) ?*Issue {\n        const idx = self.id_index.get(id) orelse return null;\n        if (idx >= self.issues.items.len) return null;\n        return &self.issues.items[idx];\n    }\n\n    /// Fields that can be updated on an issue.\n    pub const IssueUpdate = struct {\n        title: ?[]const u8 = null,\n        description: ?[]const u8 = null,\n        design: ?[]const u8 = null,\n        acceptance_criteria: ?[]const u8 = null,\n        notes: ?[]const u8 = null,\n        status: ?Status = null,\n        priority: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        owner: ?[]const u8 = null,\n        estimated_minutes: ?i32 = null,\n        closed_at: ?i64 = null,\n        close_reason: ?[]const u8 = null,\n        closed_by_session: ?[]const u8 = null,\n        due_at: ?i64 = null,\n        defer_until: ?i64 = null,\n        external_ref: ?[]const u8 = null,\n        source_system: ?[]const u8 = null,\n        pinned: ?bool = null,\n        is_template: ?bool = null,\n        content_hash: ?[]const u8 = null,\n\n        /// Expected version for optimistic locking.\n        /// If set, update will fail with VersionMismatch if issue.version != expected_version.\n        expected_version: ?u64 = null,\n    };\n\n    /// Update an issue with the given fields.\n    /// If updates.expected_version is set, performs optimistic locking check.\n    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {\n        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        // Optimistic locking check\n        if (updates.expected_version) |expected| {\n            if (issue.version != expected) {\n                return IssueStoreError.VersionMismatch;\n            }\n        }\n\n        // Increment version on every update\n        issue.version += 1;\n\n        // Update timestamp\n        issue.updated_at = Rfc3339Timestamp{ .value = now };\n\n        // Apply updates\n        if (updates.title) |v| {\n            self.allocator.free(issue.title);\n            issue.title = try self.allocator.dupe(u8, v);\n        }\n        if (updates.description) |v| {\n            if (issue.description) |d| self.allocator.free(d);\n            issue.description = try self.allocator.dupe(u8, v);\n        }\n        if (updates.design) |v| {\n            if (issue.design) |d| self.allocator.free(d);\n            issue.design = try self.allocator.dupe(u8, v);\n        }\n        if (updates.acceptance_criteria) |v| {\n            if (issue.acceptance_criteria) |a| self.allocator.free(a);\n            issue.acceptance_criteria = try self.allocator.dupe(u8, v);\n        }\n        if (updates.notes) |v| {\n            if (issue.notes) |n| self.allocator.free(n);\n            issue.notes = try self.allocator.dupe(u8, v);\n        }\n        if (updates.status) |v| {\n            freeStatus(issue.status, self.allocator);\n            issue.status = try cloneStatus(v, self.allocator);\n        }\n        if (updates.priority) |v| {\n            issue.priority = v;\n        }\n        if (updates.issue_type) |v| {\n            freeIssueType(issue.issue_type, self.allocator);\n            issue.issue_type = try cloneIssueType(v, self.allocator);\n        }\n        if (updates.assignee) |v| {\n            if (issue.assignee) |a| self.allocator.free(a);\n            issue.assignee = try self.allocator.dupe(u8, v);\n        }\n        if (updates.owner) |v| {\n            if (issue.owner) |o| self.allocator.free(o);\n            issue.owner = try self.allocator.dupe(u8, v);\n        }\n        if (updates.estimated_minutes) |v| {\n            issue.estimated_minutes = v;\n        }\n        if (updates.closed_at) |v| {\n            issue.closed_at = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.close_reason) |v| {\n            if (issue.close_reason) |r| self.allocator.free(r);\n            issue.close_reason = try self.allocator.dupe(u8, v);\n        }\n        if (updates.closed_by_session) |v| {\n            if (issue.closed_by_session) |s| self.allocator.free(s);\n            issue.closed_by_session = try self.allocator.dupe(u8, v);\n        }\n        if (updates.due_at) |v| {\n            issue.due_at = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.defer_until) |v| {\n            issue.defer_until = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.external_ref) |v| {\n            if (issue.external_ref) |e| self.allocator.free(e);\n            issue.external_ref = try self.allocator.dupe(u8, v);\n        }\n        if (updates.source_system) |v| {\n            if (issue.source_system) |s| self.allocator.free(s);\n            issue.source_system = try self.allocator.dupe(u8, v);\n        }\n        if (updates.pinned) |v| {\n            issue.pinned = v;\n        }\n        if (updates.is_template) |v| {\n            issue.is_template = v;\n        }\n        if (updates.content_hash) |v| {\n            if (issue.content_hash) |h| self.allocator.free(h);\n            issue.content_hash = try self.allocator.dupe(u8, v);\n        }\n\n        try self.markDirty(id);\n    }\n\n    /// Soft delete an issue by setting its status to tombstone.\n    pub fn delete(self: *Self, id: []const u8, now: i64) !void {\n        try self.update(id, .{ .status = .tombstone }, now);\n    }\n\n    /// Filters for listing issues.\n    pub const ListFilters = struct {\n        status: ?Status = null,\n        priority: ?Priority = null,\n        priority_min: ?Priority = null,\n        priority_max: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        label_any: []const []const u8 = &[_][]const u8{},\n        title_contains: ?[]const u8 = null,\n        desc_contains: ?[]const u8 = null,\n        notes_contains: ?[]const u8 = null,\n        include_tombstones: bool = false,\n        overdue: bool = false,\n        include_deferred: bool = false,\n        limit: ?u32 = null,\n        offset: ?u32 = null,\n        order_by: OrderBy = .created_at,\n        order_desc: bool = true,\n\n        pub const OrderBy = enum {\n            created_at,\n            updated_at,\n            priority,\n        };\n    };\n\n    /// List issues with optional filters.\n    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.issues.items) |issue| {\n            // Filter tombstones\n            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n                continue;\n            }\n\n            // Apply filters\n            if (filters.status) |s| {\n                if (!statusEql(issue.status, s)) continue;\n            }\n            if (filters.priority) |p| {\n                if (issue.priority.value != p.value) continue;\n            }\n            if (filters.issue_type) |t| {\n                if (!issueTypeEql(issue.issue_type, t)) continue;\n            }\n            if (filters.assignee) |a| {\n                if (issue.assignee == null) continue;\n                if (!std.mem.eql(u8, issue.assignee.?, a)) continue;\n            }\n            if (filters.label) |lbl| {\n                var found = false;\n                for (issue.labels) |label| {\n                    if (std.mem.eql(u8, label, lbl)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) continue;\n            }\n\n            // label_any: OR logic - issue must have at least ONE of the specified labels\n            if (filters.label_any.len > 0) {\n                var found_any = false;\n                for (filters.label_any) |any_label| {\n                    for (issue.labels) |issue_label| {\n                        if (std.mem.eql(u8, issue_label, any_label)) {\n                            found_any = true;\n                            break;\n                        }\n                    }\n                    if (found_any) break;\n                }\n                if (!found_any) continue;\n            }\n\n            // Priority range filters (lower value = higher priority)\n            if (filters.priority_min) |min_p| {\n                if (issue.priority.value < min_p.value) continue;\n            }\n            if (filters.priority_max) |max_p| {\n                if (issue.priority.value > max_p.value) continue;\n            }\n\n            // Substring filters (case-insensitive)\n            if (filters.title_contains) |query| {\n                if (!containsIgnoreCase(issue.title, query)) continue;\n            }\n            if (filters.desc_contains) |query| {\n                if (issue.description) |desc| {\n                    if (!containsIgnoreCase(desc, query)) continue;\n                } else continue;\n            }\n            if (filters.notes_contains) |query| {\n                if (issue.notes) |notes| {\n                    if (!containsIgnoreCase(notes, query)) continue;\n                } else continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort\n        const SortContext = struct {\n            order_by: ListFilters.OrderBy,\n            order_desc: bool,\n        };\n        const ctx = SortContext{ .order_by = filters.order_by, .order_desc = filters.order_desc };\n\n        std.mem.sortUnstable(Issue, results.items, ctx, struct {\n            fn lessThan(c: SortContext, a: Issue, b: Issue) bool {\n                const cmp: i64 = switch (c.order_by) {\n                    .created_at => a.created_at.value - b.created_at.value,\n                    .updated_at => a.updated_at.value - b.updated_at.value,\n                    .priority => @as(i64, a.priority.value) - @as(i64, b.priority.value),\n                };\n                return if (c.order_desc) cmp > 0 else cmp < 0;\n            }\n        }.lessThan);\n\n        // Apply offset and limit\n        var start: usize = 0;\n        if (filters.offset) |off| {\n            start = @min(off, results.items.len);\n        }\n\n        var end: usize = results.items.len;\n        if (filters.limit) |lim| {\n            end = @min(start + lim, results.items.len);\n        }\n\n        // Free items outside the range\n        for (results.items[0..start]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        for (results.items[end..]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n\n        // Return slice\n        const slice = try self.allocator.dupe(Issue, results.items[start..end]);\n        results.deinit(self.allocator);\n        return slice;\n    }\n\n    /// Result from counting issues.\n    pub const CountResult = struct {\n        key: []const u8,\n        count: u64,\n    };\n\n    /// Count issues, optionally grouped by a field.\n    pub fn count(self: *Self, group_by: ?GroupBy) ![]CountResult {\n        var counts: std.StringHashMapUnmanaged(u64) = .{};\n        defer counts.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const key_str: []const u8 = if (group_by) |g| switch (g) {\n                .status => issue.status.toString(),\n                .priority => switch (issue.priority.value) {\n                    0 => \"0\",\n                    1 => \"1\",\n                    2 => \"2\",\n                    3 => \"3\",\n                    4 => \"4\",\n                    else => unreachable,\n                },\n                .issue_type => issue.issue_type.toString(),\n                .assignee => issue.assignee orelse \"(unassigned)\",\n            } else \"total\";\n\n            const entry = counts.getOrPutValue(self.allocator, key_str, 0) catch continue;\n            entry.value_ptr.* += 1;\n        }\n\n        var results: std.ArrayListUnmanaged(CountResult) = .{};\n        errdefer {\n            for (results.items) |r| {\n                self.allocator.free(r.key);\n            }\n            results.deinit(self.allocator);\n        }\n\n        var it = counts.iterator();\n        while (it.next()) |entry| {\n            const key = try self.allocator.dupe(u8, entry.key_ptr.*);\n            try results.append(self.allocator, .{ .key = key, .count = entry.value_ptr.* });\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    pub const GroupBy = enum {\n        status,\n        priority,\n        issue_type,\n        assignee,\n    };\n\n    /// Check if an issue exists.\n    pub fn exists(self: *Self, id: []const u8) !bool {\n        return self.id_index.contains(id);\n    }\n\n    /// Get labels for an issue.\n    pub fn getLabels(self: *Self, issue_id: []const u8) ![]const []const u8 {\n        const idx = self.id_index.get(issue_id) orelse return &[_][]const u8{};\n        if (idx >= self.issues.items.len) return &[_][]const u8{};\n\n        const issue = self.issues.items[idx];\n        if (issue.labels.len == 0) return &[_][]const u8{};\n\n        const labels = try self.allocator.alloc([]const u8, issue.labels.len);\n        errdefer self.allocator.free(labels);\n\n        for (issue.labels, 0..) |label, i| {\n            labels[i] = try self.allocator.dupe(u8, label);\n        }\n        return labels;\n    }\n\n    /// Add a label to an issue.\n    pub fn addLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        // Check if already exists\n        for (issue.labels) |existing| {\n            if (std.mem.eql(u8, existing, label)) return;\n        }\n\n        // Add new label\n        const label_copy = try self.allocator.dupe(u8, label);\n        errdefer self.allocator.free(label_copy);\n\n        const new_labels = try self.allocator.alloc([]const u8, issue.labels.len + 1);\n        @memcpy(new_labels[0..issue.labels.len], issue.labels);\n        new_labels[issue.labels.len] = label_copy;\n\n        if (issue.labels.len > 0) {\n            self.allocator.free(issue.labels);\n        }\n        issue.labels = new_labels;\n\n        try self.markDirty(issue_id);\n    }\n\n    /// Remove a label from an issue.\n    pub fn removeLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        var found_idx: ?usize = null;\n        for (issue.labels, 0..) |existing, i| {\n            if (std.mem.eql(u8, existing, label)) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx) |fi| {\n            self.allocator.free(issue.labels[fi]);\n\n            if (issue.labels.len == 1) {\n                self.allocator.free(issue.labels);\n                issue.labels = &[_][]const u8{};\n            } else {\n                const new_labels = try self.allocator.alloc([]const u8, issue.labels.len - 1);\n                var j: usize = 0;\n                for (issue.labels, 0..) |lbl, i| {\n                    if (i != fi) {\n                        new_labels[j] = lbl;\n                        j += 1;\n                    }\n                }\n                self.allocator.free(issue.labels);\n                issue.labels = new_labels;\n            }\n\n            try self.markDirty(issue_id);\n        }\n    }\n\n    /// Get dependencies for an issue.\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]const Dependency {\n        const idx = self.id_index.get(issue_id) orelse return &[_]Dependency{};\n        if (idx >= self.issues.items.len) return &[_]Dependency{};\n\n        const issue = self.issues.items[idx];\n        if (issue.dependencies.len == 0) return &[_]Dependency{};\n\n        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n        errdefer self.allocator.free(deps);\n\n        for (issue.dependencies, 0..) |dep, i| {\n            deps[i] = try cloneDependency(dep, self.allocator);\n        }\n        return deps;\n    }\n\n    /// Get comments for an issue.\n    pub fn getComments(self: *Self, issue_id: []const u8) ![]const Comment {\n        const idx = self.id_index.get(issue_id) orelse return &[_]Comment{};\n        if (idx >= self.issues.items.len) return &[_]Comment{};\n\n        const issue = self.issues.items[idx];\n        if (issue.comments.len == 0) return &[_]Comment{};\n\n        const comments = try self.allocator.alloc(Comment, issue.comments.len);\n        errdefer self.allocator.free(comments);\n\n        for (issue.comments, 0..) |c, i| {\n            comments[i] = try cloneComment(c, self.allocator);\n        }\n        return comments;\n    }\n\n    /// Add a comment to an issue.\n    pub fn addComment(self: *Self, issue_id: []const u8, comment: Comment) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        const cloned = try cloneComment(comment, self.allocator);\n        errdefer freeComment(@constCast(&cloned), self.allocator);\n\n        const new_comments = try self.allocator.alloc(Comment, issue.comments.len + 1);\n        @memcpy(new_comments[0..issue.comments.len], issue.comments);\n        new_comments[issue.comments.len] = cloned;\n\n        if (issue.comments.len > 0) {\n            self.allocator.free(issue.comments);\n        }\n        issue.comments = new_comments;\n\n        try self.markDirty(issue_id);\n    }\n\n    /// Mark an issue as dirty for sync.\n    pub fn markDirty(self: *Self, id: []const u8) !void {\n        self.dirty = true;\n        const now = std.time.timestamp();\n\n        if (!self.dirty_ids.contains(id)) {\n            const id_copy = try self.allocator.dupe(u8, id);\n            try self.dirty_ids.put(self.allocator, id_copy, now);\n        } else {\n            self.dirty_ids.getPtr(id).?.* = now;\n        }\n    }\n\n    /// Clear dirty flag for an issue.\n    pub fn clearDirty(self: *Self, id: []const u8) !void {\n        if (self.dirty_ids.fetchRemove(id)) |kv| {\n            self.allocator.free(kv.key);\n        }\n    }\n\n    /// Get all dirty issue IDs.\n    pub fn getDirtyIds(self: *Self) ![][]const u8 {\n        var ids: std.ArrayListUnmanaged([]const u8) = .{};\n        errdefer {\n            for (ids.items) |id| {\n                self.allocator.free(id);\n            }\n            ids.deinit(self.allocator);\n        }\n\n        var it = self.dirty_ids.keyIterator();\n        while (it.next()) |key| {\n            const id = try self.allocator.dupe(u8, key.*);\n            try ids.append(self.allocator, id);\n        }\n\n        return ids.toOwnedSlice(self.allocator);\n    }\n\n    /// Check if the store has unsaved changes.\n    pub fn isDirty(self: *Self) bool {\n        return self.dirty;\n    }\n\n    /// Get total number of issues (excluding tombstones).\n    pub fn countTotal(self: *Self) usize {\n        var total: usize = 0;\n        for (self.issues.items) |issue| {\n            if (!statusEql(issue.status, .tombstone)) {\n                total += 1;\n            }\n        }\n        return total;\n    }\n\n    /// Get all issues as a slice (no clone, read-only).\n    pub fn getAllRef(self: *Self) []const Issue {\n        return self.issues.items;\n    }\n\n    /// Suggestion for similar ID lookup.\n    pub const IdSuggestion = struct {\n        id: []const u8,\n        title: []const u8,\n    };\n\n    /// Find similar IDs when a lookup fails (for \"did you mean\" suggestions).\n    /// Uses prefix matching and Levenshtein-like scoring.\n    /// Returns up to `max_count` suggestions, caller must free.\n    pub fn findSimilarIds(self: *Self, target: []const u8, max_count: usize) ![]IdSuggestion {\n        if (self.issues.items.len == 0) return &[_]IdSuggestion{};\n\n        const Scored = struct {\n            id: []const u8,\n            title: []const u8,\n            score: i32,\n        };\n\n        var candidates: std.ArrayListUnmanaged(Scored) = .{};\n        defer candidates.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const score = computeSimilarity(target, issue.id);\n            if (score > 0) {\n                try candidates.append(self.allocator, .{\n                    .id = issue.id,\n                    .title = issue.title,\n                    .score = score,\n                });\n            }\n        }\n\n        if (candidates.items.len == 0) return &[_]IdSuggestion{};\n\n        // Sort by score descending\n        std.mem.sortUnstable(Scored, candidates.items, {}, struct {\n            fn lessThan(_: void, a: Scored, b: Scored) bool {\n                return a.score > b.score;\n            }\n        }.lessThan);\n\n        const result_count = @min(max_count, candidates.items.len);\n        var suggestions = try self.allocator.alloc(IdSuggestion, result_count);\n        errdefer self.allocator.free(suggestions);\n\n        for (0..result_count) |i| {\n            suggestions[i] = .{\n                .id = try self.allocator.dupe(u8, candidates.items[i].id),\n                .title = try self.allocator.dupe(u8, candidates.items[i].title),\n            };\n        }\n\n        return suggestions;\n    }\n\n    /// Free suggestions returned by findSimilarIds.\n    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n        for (suggestions) |s| {\n            self.allocator.free(s.id);\n            self.allocator.free(s.title);\n        }\n        self.allocator.free(suggestions);\n    }\n};\n\n/// Compute similarity score between target and candidate ID.\n/// Higher score = more similar.\nfn computeSimilarity(target: []const u8, candidate: []const u8) i32 {\n    var score: i32 = 0;\n\n    // Exact prefix match (bd-abc matches bd-abc123)\n    if (std.mem.startsWith(u8, candidate, target)) {\n        score += 100;\n    }\n    // Candidate is prefix of target (bd-abc123 starts with bd-abc)\n    else if (std.mem.startsWith(u8, target, candidate)) {\n        score += 80;\n    }\n\n    // Common prefix length\n    var common_prefix: usize = 0;\n    const min_len = @min(target.len, candidate.len);\n    for (0..min_len) |i| {\n        if (target[i] == candidate[i]) {\n            common_prefix += 1;\n        } else {\n            break;\n        }\n    }\n    score += @intCast(common_prefix * 5);\n\n    // Contains target as substring\n    if (std.mem.indexOf(u8, candidate, target) != null) {\n        score += 30;\n    }\n\n    // Similar length bonus\n    const len_diff: i32 = @intCast(@abs(@as(i64, @intCast(target.len)) - @as(i64, @intCast(candidate.len))));\n    if (len_diff <= 2) {\n        score += 10;\n    }\n\n    return score;\n}\n\n// Helper functions\nfn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn issueTypeEql(a: IssueType, b: IssueType) bool {\n    const Tag = std.meta.Tag(IssueType);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\npub fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {\n    if (needle.len == 0) return true;\n    if (needle.len > haystack.len) return false;\n\n    const end = haystack.len - needle.len + 1;\n    var i: usize = 0;\n    while (i < end) : (i += 1) {\n        var match = true;\n        for (needle, 0..) |nc, j| {\n            const hc = haystack[i + j];\n            if (std.ascii.toLower(hc) != std.ascii.toLower(nc)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n\nfn cloneStatus(status: Status, allocator: std.mem.Allocator) !Status {\n    return switch (status) {\n        .custom => |s| Status{ .custom = try allocator.dupe(u8, s) },\n        else => status,\n    };\n}\n\nfn freeStatus(status: Status, allocator: std.mem.Allocator) void {\n    switch (status) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n}\n\nfn cloneIssueType(issue_type: IssueType, allocator: std.mem.Allocator) !IssueType {\n    return switch (issue_type) {\n        .custom => |s| IssueType{ .custom = try allocator.dupe(u8, s) },\n        else => issue_type,\n    };\n}\n\nfn freeIssueType(issue_type: IssueType, allocator: std.mem.Allocator) void {\n    switch (issue_type) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n}\n\nfn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n    var result: Dependency = undefined;\n\n    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n    errdefer allocator.free(result.issue_id);\n\n    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n    errdefer allocator.free(result.depends_on_id);\n\n    result.dep_type = switch (dep.dep_type) {\n        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n        else => dep.dep_type,\n    };\n\n    result.created_at = dep.created_at;\n    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n\n    return result;\n}\n\nfn cloneComment(comment: Comment, allocator: std.mem.Allocator) !Comment {\n    return Comment{\n        .id = comment.id,\n        .issue_id = try allocator.dupe(u8, comment.issue_id),\n        .author = try allocator.dupe(u8, comment.author),\n        .body = try allocator.dupe(u8, comment.body),\n        .created_at = comment.created_at,\n    };\n}\n\nfn freeComment(comment: *Comment, allocator: std.mem.Allocator) void {\n    allocator.free(comment.issue_id);\n    allocator.free(comment.author);\n    allocator.free(comment.body);\n}\n\n// --- Tests ---\n\ntest \"IssueStore insert and get\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-test1\", \"Test Issue\", 1706540000);\n    try store.insert(issue);\n\n    try std.testing.expect(try store.exists(\"bd-test1\"));\n\n    var retrieved = (try store.get(\"bd-test1\")).?;\n    defer retrieved.deinit(allocator);\n\n    try std.testing.expectEqualStrings(\"bd-test1\", retrieved.id);\n    try std.testing.expectEqualStrings(\"Test Issue\", retrieved.title);\n}\n\ntest \"IssueStore get returns null for missing\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const result = try store.get(\"bd-nonexistent\");\n    try std.testing.expect(result == null);\n}\n\ntest \"IssueStore update modifies fields\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-update\", \"Original Title\", 1706540000);\n    try store.insert(issue);\n\n    try store.update(\"bd-update\", .{\n        .title = \"Updated Title\",\n        .status = .in_progress,\n        .priority = Priority.HIGH,\n    }, 1706550000);\n\n    var updated = (try store.get(\"bd-update\")).?;\n    defer updated.deinit(allocator);\n\n    try std.testing.expectEqualStrings(\"Updated Title\", updated.title);\n    try std.testing.expect(statusEql(updated.status, .in_progress));\n    try std.testing.expectEqual(Priority.HIGH, updated.priority);\n}\n\ntest \"IssueStore update increments version\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-version\", \"Version Test\", 1706540000);\n    try store.insert(issue);\n\n    // Initial version should be 1\n    var v1 = (try store.get(\"bd-version\")).?;\n    defer v1.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 1), v1.version);\n\n    // Update should increment version\n    try store.update(\"bd-version\", .{ .title = \"Updated\" }, 1706550000);\n\n    var v2 = (try store.get(\"bd-version\")).?;\n    defer v2.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 2), v2.version);\n\n    // Another update should increment again\n    try store.update(\"bd-version\", .{ .title = \"Updated Again\" }, 1706560000);\n\n    var v3 = (try store.get(\"bd-version\")).?;\n    defer v3.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 3), v3.version);\n}\n\ntest \"IssueStore update with expected_version succeeds on match\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-optlock\", \"Optimistic Lock Test\", 1706540000);\n    try store.insert(issue);\n\n    // Get current version (1)\n    var current = (try store.get(\"bd-optlock\")).?;\n    const current_version = current.version;\n    current.deinit(allocator);\n\n    // Update with correct expected version should succeed\n    try store.update(\"bd-optlock\", .{\n        .title = \"Updated with lock\",\n        .expected_version = current_version,\n    }, 1706550000);\n\n    var updated = (try store.get(\"bd-optlock\")).?;\n    defer updated.deinit(allocator);\n    try std.testing.expectEqualStrings(\"Updated with lock\", updated.title);\n    try std.testing.expectEqual(@as(u64, 2), updated.version);\n}\n\ntest \"IssueStore update with expected_version fails on mismatch\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-conflict\", \"Conflict Test\", 1706540000);\n    try store.insert(issue);\n\n    // Update once to increment version to 2\n    try store.update(\"bd-conflict\", .{ .title = \"First Update\" }, 1706550000);\n\n    // Try to update with stale expected_version (1 instead of 2)\n    const result = store.update(\"bd-conflict\", .{\n        .title = \"Conflicting Update\",\n        .expected_version = 1, // Stale version\n    }, 1706560000);\n\n    try std.testing.expectError(IssueStoreError.VersionMismatch, result);\n\n    // Verify original update is preserved\n    var preserved = (try store.get(\"bd-conflict\")).?;\n    defer preserved.deinit(allocator);\n    try std.testing.expectEqualStrings(\"First Update\", preserved.title);\n    try std.testing.expectEqual(@as(u64, 2), preserved.version);\n}\n\ntest \"IssueStore delete sets tombstone\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-delete\", \"To Delete\", 1706540000);\n    try store.insert(issue);\n\n    try store.delete(\"bd-delete\", 1706550000);\n\n    var deleted = (try store.get(\"bd-delete\")).?;\n    defer deleted.deinit(allocator);\n\n    try std.testing.expect(statusEql(deleted.status, .tombstone));\n}\n\ntest \"IssueStore list returns issues\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-list1\", \"Issue 1\", 1706540000));\n    try store.insert(Issue.init(\"bd-list2\", \"Issue 2\", 1706550000));\n    try store.insert(Issue.init(\"bd-list3\", \"Issue 3\", 1706560000));\n\n    const issues = try store.list(.{});\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    try std.testing.expectEqual(@as(usize, 3), issues.len);\n}\n\ntest \"IssueStore list excludes tombstones\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-active\", \"Active\", 1706540000));\n    try store.insert(Issue.init(\"bd-deleted\", \"Deleted\", 1706550000));\n    try store.delete(\"bd-deleted\", 1706560000);\n\n    const issues = try store.list(.{});\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), issues.len);\n    try std.testing.expectEqualStrings(\"bd-active\", issues[0].id);\n}\n\ntest \"IssueStore dirty tracking\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-dirty\", \"Dirty Test\", 1706540000);\n    try store.insert(issue);\n\n    try std.testing.expect(store.isDirty());\n\n    const dirty_ids = try store.getDirtyIds();\n    defer {\n        for (dirty_ids) |id| {\n            allocator.free(id);\n        }\n        allocator.free(dirty_ids);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), dirty_ids.len);\n    try std.testing.expectEqualStrings(\"bd-dirty\", dirty_ids[0]);\n\n    try store.clearDirty(\"bd-dirty\");\n\n    const after_clear = try store.getDirtyIds();\n    defer allocator.free(after_clear);\n\n    try std.testing.expectEqual(@as(usize, 0), after_clear.len);\n}\n\ntest \"IssueStore addLabel and removeLabel\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-labels\", \"Label Test\", 1706540000));\n\n    try store.addLabel(\"bd-labels\", \"bug\");\n    try store.addLabel(\"bd-labels\", \"urgent\");\n\n    const labels = try store.getLabels(\"bd-labels\");\n    defer {\n        for (labels) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(labels);\n    }\n\n    try std.testing.expectEqual(@as(usize, 2), labels.len);\n\n    try store.removeLabel(\"bd-labels\", \"bug\");\n\n    const after_remove = try store.getLabels(\"bd-labels\");\n    defer {\n        for (after_remove) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(after_remove);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), after_remove.len);\n}\n\ntest \"StoreLoadResult.hasCorruption\" {\n    var result = StoreLoadResult{\n        .jsonl_corruption_count = 0,\n    };\n    try std.testing.expect(!result.hasCorruption());\n\n    result.jsonl_corruption_count = 3;\n    try std.testing.expect(result.hasCorruption());\n}\n\ntest \"IssueStore loadFromFileWithRecovery handles corrupt entries\" {\n    const allocator = std.testing.allocator;\n    const test_util = @import(\"../test_util.zig\");\n    const test_dir = try test_util.createTestDir(allocator, \"store_recovery\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"issues.jsonl\" });\n    defer allocator.free(test_path);\n\n    // Write a file with mixed valid and corrupt entries\n    // Use full Issue JSON format (all fields required by parser)\n    {\n        const file = try std.fs.cwd().createFile(test_path, .{});\n        defer file.close();\n\n        // Valid issue\n        const valid1 = \"{\\\"id\\\":\\\"bd-valid1\\\",\\\"content_hash\\\":null,\\\"title\\\":\\\"Valid Issue\\\",\\\"description\\\":null,\\\"design\\\":null,\\\"acceptance_criteria\\\":null,\\\"notes\\\":null,\\\"status\\\":\\\"open\\\",\\\"priority\\\":2,\\\"issue_type\\\":\\\"task\\\",\\\"assignee\\\":null,\\\"owner\\\":null,\\\"created_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"created_by\\\":null,\\\"updated_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"closed_at\\\":null,\\\"close_reason\\\":null,\\\"due_at\\\":null,\\\"defer_until\\\":null,\\\"estimated_minutes\\\":null,\\\"external_ref\\\":null,\\\"source_system\\\":null,\\\"pinned\\\":false,\\\"is_template\\\":false,\\\"labels\\\":[],\\\"dependencies\\\":[],\\\"comments\\\":[]}\\n\";\n        try file.writeAll(valid1);\n\n        // Corrupt entry\n        try file.writeAll(\"{invalid json here}\\n\");\n\n        // Another valid issue\n        const valid2 = \"{\\\"id\\\":\\\"bd-valid2\\\",\\\"content_hash\\\":null,\\\"title\\\":\\\"Another Valid Issue\\\",\\\"description\\\":null,\\\"design\\\":null,\\\"acceptance_criteria\\\":null,\\\"notes\\\":null,\\\"status\\\":\\\"open\\\",\\\"priority\\\":2,\\\"issue_type\\\":\\\"task\\\",\\\"assignee\\\":null,\\\"owner\\\":null,\\\"created_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"created_by\\\":null,\\\"updated_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"closed_at\\\":null,\\\"close_reason\\\":null,\\\"due_at\\\":null,\\\"defer_until\\\":null,\\\"estimated_minutes\\\":null,\\\"external_ref\\\":null,\\\"source_system\\\":null,\\\"pinned\\\":false,\\\"is_template\\\":false,\\\"labels\\\":[],\\\"dependencies\\\":[],\\\"comments\\\":[]}\\n\";\n        try file.writeAll(valid2);\n    }\n\n    var store = IssueStore.init(allocator, test_path);\n    defer store.deinit();\n\n    var result = try store.loadFromFileWithRecovery();\n    defer result.deinit(allocator);\n\n    // Should have loaded 2 valid issues\n    try std.testing.expectEqual(@as(usize, 2), store.issues.items.len);\n\n    // Should have tracked 1 corrupt entry\n    try std.testing.expectEqual(@as(usize, 1), result.jsonl_corruption_count);\n    try std.testing.expect(result.hasCorruption());\n\n    // Verify the correct issues were loaded\n    try std.testing.expect(try store.exists(\"bd-valid1\"));\n    try std.testing.expect(try store.exists(\"bd-valid2\"));\n}\n","structuredPatch":[{"oldStart":434,"oldLines":6,"newStart":434,"newLines":19,"lines":["                 } else continue;","             }"," ","+            // Overdue filter: only include issues past their due date","+            if (filters.overdue) {","+                const now = std.time.timestamp();","+                if (issue.due_at.value) |due_time| {","+                    if (due_time >= now) continue;","+                } else continue;","+            }","+","+            // Deferred filter: skip deferred issues unless explicitly included","+            if (!filters.include_deferred and statusEql(issue.status, .deferred)) {","+                continue;","+            }","+","             try results.append(self.allocator, try issue.clone(self.allocator));","         }"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013FLJRQkqbFrApxW3nqEYFG","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the list.zig to pass these filters."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":666,"cache_read_input_tokens":62137,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":666},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"16a8c2bf-a0ec-458b-a5a7-4735d88c8e9c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013FLJRQkqbFrApxW3nqEYFG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012XexcqQ49beq7CQbkkAmjU","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/list.zig","old_string":"    if (list_args.limit) |n| {\n        filters.limit = n;\n    }\n\n    // Apply sort options","new_string":"    if (list_args.limit) |n| {\n        filters.limit = n;\n    }\n\n    // Apply overdue filter\n    filters.overdue = list_args.overdue;\n\n    // Apply include_deferred filter\n    filters.include_deferred = list_args.include_deferred;\n\n    // Apply sort options"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":666,"cache_read_input_tokens":62137,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":666},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"d7597c87-1021-45c4-bc7b-237936ad28c1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012XexcqQ49beq7CQbkkAmjU","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/list.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"279151e2-3738-4a4d-93c9-8adb172b907d","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/list.zig","oldString":"    if (list_args.limit) |n| {\n        filters.limit = n;\n    }\n\n    // Apply sort options","newString":"    if (list_args.limit) |n| {\n        filters.limit = n;\n    }\n\n    // Apply overdue filter\n    filters.overdue = list_args.overdue;\n\n    // Apply include_deferred filter\n    filters.include_deferred = list_args.include_deferred;\n\n    // Apply sort options","originalFile":"//! List command for beads_zig.\n//!\n//! `bz list [--status X] [--priority X] [--type X] [--assignee X] [--label X] [-n LIMIT] [--all]`\n//!\n//! Lists issues with optional filters.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Status = models.Status;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const ListError = error{\n    WorkspaceNotInitialized,\n    InvalidFilter,\n    StorageError,\n    OutOfMemory,\n};\n\npub const ListResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        status: []const u8,\n        priority: u3,\n        issue_type: []const u8,\n        assignee: ?[]const u8 = null,\n    };\n};\n\npub fn run(\n    list_args: args.ListArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ListError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var filters = IssueStore.ListFilters{};\n\n    if (list_args.status) |s| {\n        filters.status = Status.fromString(s);\n    } else if (!list_args.all) {\n        filters.status = .open;\n    }\n\n    if (list_args.priority) |p| {\n        filters.priority = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.priority_min) |p| {\n        filters.priority_min = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-min value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.priority_max) |p| {\n        filters.priority_max = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-max value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.issue_type) |t| {\n        filters.issue_type = IssueType.fromString(t);\n    }\n\n    if (list_args.assignee) |a| {\n        filters.assignee = a;\n    }\n\n    if (list_args.label) |l| {\n        filters.label = l;\n    }\n\n    if (list_args.label_any.len > 0) {\n        filters.label_any = list_args.label_any;\n    }\n\n    if (list_args.title_contains) |t| {\n        filters.title_contains = t;\n    }\n\n    if (list_args.desc_contains) |d| {\n        filters.desc_contains = d;\n    }\n\n    if (list_args.notes_contains) |n| {\n        filters.notes_contains = n;\n    }\n\n    if (list_args.limit) |n| {\n        filters.limit = n;\n    }\n\n    // Apply sort options\n    filters.order_by = switch (list_args.sort) {\n        .created_at => .created_at,\n        .updated_at => .updated_at,\n        .priority => .priority,\n    };\n    filters.order_desc = list_args.sort_desc;\n\n    const issues = try ctx.store.list(filters);\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n        defer allocator.free(compact_issues);\n\n        for (issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .status = issue.status.toString(),\n                .priority = issue.priority.value,\n                .issue_type = issue.issue_type.toString(),\n                .assignee = issue.assignee,\n            };\n        }\n\n        try ctx.output.printJson(ListResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(issues);\n        if (!global.quiet and issues.len == 0) {\n            try ctx.output.info(\"No issues found\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, structured_mode: bool, message: []const u8) !void {\n    if (structured_mode) {\n        try output.printJson(ListResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"ListError enum exists\" {\n    const err: ListError = ListError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ListError.WorkspaceNotInitialized);\n}\n\ntest \"ListResult struct works\" {\n    const result = ListResult{\n        .success = true,\n        .count = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const list_args = args.ListArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(list_args, global, allocator);\n    try std.testing.expectError(ListError.WorkspaceNotInitialized, result);\n}\n\ntest \"run lists issues successfully\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"list_success\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    defer f.close();\n\n    const list_args = args.ListArgs{ .all = true };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(list_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":111,"oldLines":6,"newStart":111,"newLines":12,"lines":["         filters.limit = n;","     }"," ","+    // Apply overdue filter","+    filters.overdue = list_args.overdue;","+","+    // Apply include_deferred filter","+    filters.include_deferred = list_args.include_deferred;","+","     // Apply sort options","     filters.order_by = switch (list_args.sort) {","         .created_at => .created_at,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ETCNXyW3RCq4wby3cwg9fh","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the ready.zig to support --overdue and --include-deferred. Let me read the graph.zig getReadyIssues function more closely and update the ready command filtering."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":290,"cache_read_input_tokens":62803,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":290},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f9458c74-261c-4ef1-9990-024f674ee6ad"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ETCNXyW3RCq4wby3cwg9fh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01H1J9CpDTCFTDeqBobV2Z3f","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/ready.zig","old_string":"fn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n) ![]Issue {\n    // No filters - return original slice\n    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null) {\n        return try allocator.dupe(Issue, issues);\n    }\n\n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    errdefer filtered.deinit(allocator);\n\n    for (issues) |issue| {\n        // Priority range filters (lower value = higher priority)\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        if (priority_max) |max_p| {\n            if (issue.priority.value > max_p.value) continue;\n        }\n\n        // Substring filters (case-insensitive)\n        if (title_contains) |query| {\n            if (!containsIgnoreCase(issue.title, query)) continue;\n        }\n        if (desc_contains) |query| {\n            if (issue.description) |desc| {\n                if (!containsIgnoreCase(desc, query)) continue;\n            } else continue;\n        }\n        if (notes_contains) |query| {\n            if (issue.notes) |notes| {\n                if (!containsIgnoreCase(notes, query)) continue;\n            } else continue;\n        }\n\n        try filtered.append(allocator, issue);\n    }\n\n    return filtered.toOwnedSlice(allocator);\n}","new_string":"fn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n    overdue_only: bool,\n) ![]Issue {\n    // No filters - return original slice\n    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null and !overdue_only) {\n        return try allocator.dupe(Issue, issues);\n    }\n\n    const now = std.time.timestamp();\n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    errdefer filtered.deinit(allocator);\n\n    for (issues) |issue| {\n        // Priority range filters (lower value = higher priority)\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        if (priority_max) |max_p| {\n            if (issue.priority.value > max_p.value) continue;\n        }\n\n        // Substring filters (case-insensitive)\n        if (title_contains) |query| {\n            if (!containsIgnoreCase(issue.title, query)) continue;\n        }\n        if (desc_contains) |query| {\n            if (issue.description) |desc| {\n                if (!containsIgnoreCase(desc, query)) continue;\n            } else continue;\n        }\n        if (notes_contains) |query| {\n            if (issue.notes) |notes| {\n                if (!containsIgnoreCase(notes, query)) continue;\n            } else continue;\n        }\n\n        // Overdue filter: only include issues past their due date\n        if (overdue_only) {\n            if (issue.due_at.value) |due_time| {\n                if (due_time >= now) continue;\n            } else continue;\n        }\n\n        try filtered.append(allocator, issue);\n    }\n\n    return filtered.toOwnedSlice(allocator);\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":290,"cache_read_input_tokens":62803,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":290},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f809f13b-db71-4a09-9742-79229e4eb3d3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01H1J9CpDTCFTDeqBobV2Z3f","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/ready.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"414f9d6d-08da-4605-8022-adb11eb9d17f","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/ready.zig","oldString":"fn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n) ![]Issue {\n    // No filters - return original slice\n    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null) {\n        return try allocator.dupe(Issue, issues);\n    }\n\n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    errdefer filtered.deinit(allocator);\n\n    for (issues) |issue| {\n        // Priority range filters (lower value = higher priority)\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        if (priority_max) |max_p| {\n            if (issue.priority.value > max_p.value) continue;\n        }\n\n        // Substring filters (case-insensitive)\n        if (title_contains) |query| {\n            if (!containsIgnoreCase(issue.title, query)) continue;\n        }\n        if (desc_contains) |query| {\n            if (issue.description) |desc| {\n                if (!containsIgnoreCase(desc, query)) continue;\n            } else continue;\n        }\n        if (notes_contains) |query| {\n            if (issue.notes) |notes| {\n                if (!containsIgnoreCase(notes, query)) continue;\n            } else continue;\n        }\n\n        try filtered.append(allocator, issue);\n    }\n\n    return filtered.toOwnedSlice(allocator);\n}","newString":"fn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n    overdue_only: bool,\n) ![]Issue {\n    // No filters - return original slice\n    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null and !overdue_only) {\n        return try allocator.dupe(Issue, issues);\n    }\n\n    const now = std.time.timestamp();\n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    errdefer filtered.deinit(allocator);\n\n    for (issues) |issue| {\n        // Priority range filters (lower value = higher priority)\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        if (priority_max) |max_p| {\n            if (issue.priority.value > max_p.value) continue;\n        }\n\n        // Substring filters (case-insensitive)\n        if (title_contains) |query| {\n            if (!containsIgnoreCase(issue.title, query)) continue;\n        }\n        if (desc_contains) |query| {\n            if (issue.description) |desc| {\n                if (!containsIgnoreCase(desc, query)) continue;\n            } else continue;\n        }\n        if (notes_contains) |query| {\n            if (issue.notes) |notes| {\n                if (!containsIgnoreCase(notes, query)) continue;\n            } else continue;\n        }\n\n        // Overdue filter: only include issues past their due date\n        if (overdue_only) {\n            if (issue.due_at.value) |due_time| {\n                if (due_time >= now) continue;\n            } else continue;\n        }\n\n        try filtered.append(allocator, issue);\n    }\n\n    return filtered.toOwnedSlice(allocator);\n}","originalFile":"//! Ready and blocked commands for beads_zig.\n//!\n//! `bz ready [-n LIMIT]` - Show issues ready to work on (no blockers)\n//! `bz blocked [-n LIMIT]` - Show blocked issues\n//!\n//! Workflow queries for finding actionable work.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst store = @import(\"../storage/store.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Priority = models.Priority;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst containsIgnoreCase = store.containsIgnoreCase;\n\npub const ReadyError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidFilter,\n};\n\npub const ReadyResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n    };\n};\n\npub const BlockedResult = struct {\n    success: bool,\n    issues: ?[]const BlockedIssue = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const BlockedIssue = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n        blocked_by: []const []const u8,\n    };\n};\n\npub fn run(\n    ready_args: args.ReadyArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (ready_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (ready_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, ready_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);\n        defer allocator.free(compact_issues);\n\n        for (display_issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n            };\n        }\n\n        try ctx.output.printJson(ReadyResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(display_issues);\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No ready issues\", .{});\n        }\n    }\n}\n\npub fn runBlocked(\n    blocked_args: args.BlockedArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (blocked_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (blocked_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getBlockedIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, blocked_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var blocked_issues = try allocator.alloc(BlockedResult.BlockedIssue, display_issues.len);\n        defer {\n            for (blocked_issues) |bi| {\n                allocator.free(bi.blocked_by);\n            }\n            allocator.free(blocked_issues);\n        }\n\n        for (display_issues, 0..) |issue, i| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            var blocker_ids = try allocator.alloc([]const u8, blockers.len);\n            for (blockers, 0..) |blocker, j| {\n                blocker_ids[j] = blocker.id;\n            }\n\n            blocked_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n                .blocked_by = blocker_ids,\n            };\n        }\n\n        try ctx.output.printJson(BlockedResult{\n            .success = true,\n            .issues = blocked_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        for (display_issues) |issue| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            try ctx.output.print(\"{s}  {s}\\n\", .{ issue.id, issue.title });\n\n            if (blockers.len > 0) {\n                try ctx.output.print(\"  blocked by: \", .{});\n                for (blockers, 0..) |blocker, j| {\n                    if (j > 0) try ctx.output.print(\", \", .{});\n                    try ctx.output.print(\"{s}\", .{blocker.id});\n                }\n                try ctx.output.print(\"\\n\", .{});\n            }\n        }\n\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No blocked issues\", .{});\n        }\n    }\n}\n\nfn applyLimit(issues: []Issue, limit: ?u32) []Issue {\n    if (limit) |n| {\n        if (n < issues.len) {\n            return issues[0..n];\n        }\n    }\n    return issues;\n}\n\nfn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n) ![]Issue {\n    // No filters - return original slice\n    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null) {\n        return try allocator.dupe(Issue, issues);\n    }\n\n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    errdefer filtered.deinit(allocator);\n\n    for (issues) |issue| {\n        // Priority range filters (lower value = higher priority)\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        if (priority_max) |max_p| {\n            if (issue.priority.value > max_p.value) continue;\n        }\n\n        // Substring filters (case-insensitive)\n        if (title_contains) |query| {\n            if (!containsIgnoreCase(issue.title, query)) continue;\n        }\n        if (desc_contains) |query| {\n            if (issue.description) |desc| {\n                if (!containsIgnoreCase(desc, query)) continue;\n            } else continue;\n        }\n        if (notes_contains) |query| {\n            if (issue.notes) |notes| {\n                if (!containsIgnoreCase(notes, query)) continue;\n            } else continue;\n        }\n\n        try filtered.append(allocator, issue);\n    }\n\n    return filtered.toOwnedSlice(allocator);\n}\n\n// --- Tests ---\n\ntest \"ReadyError enum exists\" {\n    const err: ReadyError = ReadyError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ReadyError.WorkspaceNotInitialized);\n}\n\ntest \"ReadyResult struct works\" {\n    const result = ReadyResult{\n        .success = true,\n        .count = 3,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 3), result.count.?);\n}\n\ntest \"BlockedResult struct works\" {\n    const result = BlockedResult{\n        .success = true,\n        .count = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 2), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(ready_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"runBlocked detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const blocked_args = args.BlockedArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = runBlocked(blocked_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"run returns empty list for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"ready_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(ready_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":220,"oldLines":12,"newStart":220,"newLines":14,"lines":["     title_contains: ?[]const u8,","     desc_contains: ?[]const u8,","     notes_contains: ?[]const u8,","+    overdue_only: bool,"," ) ![]Issue {","     // No filters - return original slice","-    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null) {","+    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null and !overdue_only) {","         return try allocator.dupe(Issue, issues);","     }"," ","+    const now = std.time.timestamp();","     var filtered: std.ArrayListUnmanaged(Issue) = .{};","     errdefer filtered.deinit(allocator);"," "]},{"oldStart":253,"oldLines":6,"newStart":255,"newLines":13,"lines":["             } else continue;","         }"," ","+        // Overdue filter: only include issues past their due date","+        if (overdue_only) {","+            if (issue.due_at.value) |due_time| {","+                if (due_time >= now) continue;","+            } else continue;","+        }","+","         try filtered.append(allocator, issue);","     }"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016kQhgEJUZbBHys5t5GVFXj","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the call sites in ready.zig to pass the overdue parameter."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1202,"cache_read_input_tokens":63093,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1202},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"3c35febd-1256-4ad8-9143-f45a27c53c67"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016kQhgEJUZbBHys5t5GVFXj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VL3uxoMpjU4ts5x6sEVQ2c","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/ready.zig","old_string":"    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains);\n    defer allocator.free(filtered);","new_string":"    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues(ready_args.include_deferred);\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    defer allocator.free(filtered);"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1202,"cache_read_input_tokens":63093,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1202},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"101ca5ef-ac56-4a8c-af1b-79f4d16aa33a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VL3uxoMpjU4ts5x6sEVQ2c","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/ready.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"4e35de8d-158a-429e-8d35-d018e05cd1c2","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/ready.zig","oldString":"    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains);\n    defer allocator.free(filtered);","newString":"    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues(ready_args.include_deferred);\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    defer allocator.free(filtered);","originalFile":"//! Ready and blocked commands for beads_zig.\n//!\n//! `bz ready [-n LIMIT]` - Show issues ready to work on (no blockers)\n//! `bz blocked [-n LIMIT]` - Show blocked issues\n//!\n//! Workflow queries for finding actionable work.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst store = @import(\"../storage/store.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Priority = models.Priority;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst containsIgnoreCase = store.containsIgnoreCase;\n\npub const ReadyError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidFilter,\n};\n\npub const ReadyResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n    };\n};\n\npub const BlockedResult = struct {\n    success: bool,\n    issues: ?[]const BlockedIssue = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const BlockedIssue = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n        blocked_by: []const []const u8,\n    };\n};\n\npub fn run(\n    ready_args: args.ReadyArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (ready_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (ready_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, ready_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);\n        defer allocator.free(compact_issues);\n\n        for (display_issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n            };\n        }\n\n        try ctx.output.printJson(ReadyResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(display_issues);\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No ready issues\", .{});\n        }\n    }\n}\n\npub fn runBlocked(\n    blocked_args: args.BlockedArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (blocked_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (blocked_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getBlockedIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, blocked_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var blocked_issues = try allocator.alloc(BlockedResult.BlockedIssue, display_issues.len);\n        defer {\n            for (blocked_issues) |bi| {\n                allocator.free(bi.blocked_by);\n            }\n            allocator.free(blocked_issues);\n        }\n\n        for (display_issues, 0..) |issue, i| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            var blocker_ids = try allocator.alloc([]const u8, blockers.len);\n            for (blockers, 0..) |blocker, j| {\n                blocker_ids[j] = blocker.id;\n            }\n\n            blocked_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n                .blocked_by = blocker_ids,\n            };\n        }\n\n        try ctx.output.printJson(BlockedResult{\n            .success = true,\n            .issues = blocked_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        for (display_issues) |issue| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            try ctx.output.print(\"{s}  {s}\\n\", .{ issue.id, issue.title });\n\n            if (blockers.len > 0) {\n                try ctx.output.print(\"  blocked by: \", .{});\n                for (blockers, 0..) |blocker, j| {\n                    if (j > 0) try ctx.output.print(\", \", .{});\n                    try ctx.output.print(\"{s}\", .{blocker.id});\n                }\n                try ctx.output.print(\"\\n\", .{});\n            }\n        }\n\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No blocked issues\", .{});\n        }\n    }\n}\n\nfn applyLimit(issues: []Issue, limit: ?u32) []Issue {\n    if (limit) |n| {\n        if (n < issues.len) {\n            return issues[0..n];\n        }\n    }\n    return issues;\n}\n\nfn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n    overdue_only: bool,\n) ![]Issue {\n    // No filters - return original slice\n    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null and !overdue_only) {\n        return try allocator.dupe(Issue, issues);\n    }\n\n    const now = std.time.timestamp();\n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    errdefer filtered.deinit(allocator);\n\n    for (issues) |issue| {\n        // Priority range filters (lower value = higher priority)\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        if (priority_max) |max_p| {\n            if (issue.priority.value > max_p.value) continue;\n        }\n\n        // Substring filters (case-insensitive)\n        if (title_contains) |query| {\n            if (!containsIgnoreCase(issue.title, query)) continue;\n        }\n        if (desc_contains) |query| {\n            if (issue.description) |desc| {\n                if (!containsIgnoreCase(desc, query)) continue;\n            } else continue;\n        }\n        if (notes_contains) |query| {\n            if (issue.notes) |notes| {\n                if (!containsIgnoreCase(notes, query)) continue;\n            } else continue;\n        }\n\n        // Overdue filter: only include issues past their due date\n        if (overdue_only) {\n            if (issue.due_at.value) |due_time| {\n                if (due_time >= now) continue;\n            } else continue;\n        }\n\n        try filtered.append(allocator, issue);\n    }\n\n    return filtered.toOwnedSlice(allocator);\n}\n\n// --- Tests ---\n\ntest \"ReadyError enum exists\" {\n    const err: ReadyError = ReadyError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ReadyError.WorkspaceNotInitialized);\n}\n\ntest \"ReadyResult struct works\" {\n    const result = ReadyResult{\n        .success = true,\n        .count = 3,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 3), result.count.?);\n}\n\ntest \"BlockedResult struct works\" {\n    const result = BlockedResult{\n        .success = true,\n        .count = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 2), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(ready_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"runBlocked detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const blocked_args = args.BlockedArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = runBlocked(blocked_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"run returns empty list for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"ready_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(ready_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":79,"oldLines":11,"newStart":79,"newLines":11,"lines":["     }"," ","     var graph = ctx.createGraph();","-    const issues = try graph.getReadyIssues();","+    const issues = try graph.getReadyIssues(ready_args.include_deferred);","     defer graph.freeIssues(issues);"," ","     // Apply filters","-    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains);","+    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);","     defer allocator.free(filtered);"," ","     const display_issues = applyLimit(filtered, ready_args.limit);"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016kQhgEJUZbBHys5t5GVFXj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LkYtWt8PAdwfoMEMtV4rtG","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/ready.zig","old_string":"    var graph = ctx.createGraph();\n    const issues = try graph.getBlockedIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains);\n    defer allocator.free(filtered);","new_string":"    var graph = ctx.createGraph();\n    const issues = try graph.getBlockedIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters (blocked command doesn't support overdue filter)\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains, false);\n    defer allocator.free(filtered);"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1202,"cache_read_input_tokens":63093,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1202},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"5ab76363-c994-4b6f-b6b1-e640c6d9212b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LkYtWt8PAdwfoMEMtV4rtG","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/ready.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"68ad3e5c-092a-44c6-b128-fbb782696678","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/ready.zig","oldString":"    var graph = ctx.createGraph();\n    const issues = try graph.getBlockedIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains);\n    defer allocator.free(filtered);","newString":"    var graph = ctx.createGraph();\n    const issues = try graph.getBlockedIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters (blocked command doesn't support overdue filter)\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains, false);\n    defer allocator.free(filtered);","originalFile":"//! Ready and blocked commands for beads_zig.\n//!\n//! `bz ready [-n LIMIT]` - Show issues ready to work on (no blockers)\n//! `bz blocked [-n LIMIT]` - Show blocked issues\n//!\n//! Workflow queries for finding actionable work.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst store = @import(\"../storage/store.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Priority = models.Priority;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst containsIgnoreCase = store.containsIgnoreCase;\n\npub const ReadyError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidFilter,\n};\n\npub const ReadyResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n    };\n};\n\npub const BlockedResult = struct {\n    success: bool,\n    issues: ?[]const BlockedIssue = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const BlockedIssue = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n        blocked_by: []const []const u8,\n    };\n};\n\npub fn run(\n    ready_args: args.ReadyArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (ready_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (ready_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues(ready_args.include_deferred);\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, ready_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);\n        defer allocator.free(compact_issues);\n\n        for (display_issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n            };\n        }\n\n        try ctx.output.printJson(ReadyResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(display_issues);\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No ready issues\", .{});\n        }\n    }\n}\n\npub fn runBlocked(\n    blocked_args: args.BlockedArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (blocked_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (blocked_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getBlockedIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, blocked_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var blocked_issues = try allocator.alloc(BlockedResult.BlockedIssue, display_issues.len);\n        defer {\n            for (blocked_issues) |bi| {\n                allocator.free(bi.blocked_by);\n            }\n            allocator.free(blocked_issues);\n        }\n\n        for (display_issues, 0..) |issue, i| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            var blocker_ids = try allocator.alloc([]const u8, blockers.len);\n            for (blockers, 0..) |blocker, j| {\n                blocker_ids[j] = blocker.id;\n            }\n\n            blocked_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n                .blocked_by = blocker_ids,\n            };\n        }\n\n        try ctx.output.printJson(BlockedResult{\n            .success = true,\n            .issues = blocked_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        for (display_issues) |issue| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            try ctx.output.print(\"{s}  {s}\\n\", .{ issue.id, issue.title });\n\n            if (blockers.len > 0) {\n                try ctx.output.print(\"  blocked by: \", .{});\n                for (blockers, 0..) |blocker, j| {\n                    if (j > 0) try ctx.output.print(\", \", .{});\n                    try ctx.output.print(\"{s}\", .{blocker.id});\n                }\n                try ctx.output.print(\"\\n\", .{});\n            }\n        }\n\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No blocked issues\", .{});\n        }\n    }\n}\n\nfn applyLimit(issues: []Issue, limit: ?u32) []Issue {\n    if (limit) |n| {\n        if (n < issues.len) {\n            return issues[0..n];\n        }\n    }\n    return issues;\n}\n\nfn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n    overdue_only: bool,\n) ![]Issue {\n    // No filters - return original slice\n    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null and !overdue_only) {\n        return try allocator.dupe(Issue, issues);\n    }\n\n    const now = std.time.timestamp();\n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    errdefer filtered.deinit(allocator);\n\n    for (issues) |issue| {\n        // Priority range filters (lower value = higher priority)\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        if (priority_max) |max_p| {\n            if (issue.priority.value > max_p.value) continue;\n        }\n\n        // Substring filters (case-insensitive)\n        if (title_contains) |query| {\n            if (!containsIgnoreCase(issue.title, query)) continue;\n        }\n        if (desc_contains) |query| {\n            if (issue.description) |desc| {\n                if (!containsIgnoreCase(desc, query)) continue;\n            } else continue;\n        }\n        if (notes_contains) |query| {\n            if (issue.notes) |notes| {\n                if (!containsIgnoreCase(notes, query)) continue;\n            } else continue;\n        }\n\n        // Overdue filter: only include issues past their due date\n        if (overdue_only) {\n            if (issue.due_at.value) |due_time| {\n                if (due_time >= now) continue;\n            } else continue;\n        }\n\n        try filtered.append(allocator, issue);\n    }\n\n    return filtered.toOwnedSlice(allocator);\n}\n\n// --- Tests ---\n\ntest \"ReadyError enum exists\" {\n    const err: ReadyError = ReadyError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ReadyError.WorkspaceNotInitialized);\n}\n\ntest \"ReadyResult struct works\" {\n    const result = ReadyResult{\n        .success = true,\n        .count = 3,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 3), result.count.?);\n}\n\ntest \"BlockedResult struct works\" {\n    const result = BlockedResult{\n        .success = true,\n        .count = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 2), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(ready_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"runBlocked detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const blocked_args = args.BlockedArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = runBlocked(blocked_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"run returns empty list for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"ready_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(ready_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":143,"oldLines":8,"newStart":143,"newLines":8,"lines":["     const issues = try graph.getBlockedIssues();","     defer graph.freeIssues(issues);"," ","-    // Apply filters","-    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains);","+    // Apply filters (blocked command doesn't support overdue filter)","+    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains, false);","     defer allocator.free(filtered);"," ","     const display_issues = applyLimit(filtered, blocked_args.limit);"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CD58vzMbB943d9ZWjMn2sg","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the graph.zig `getReadyIssues` to accept the `include_deferred` parameter."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":802,"cache_read_input_tokens":64295,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":802},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"916ce21e-a2f2-476a-a437-a2befbea48f7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CD58vzMbB943d9ZWjMn2sg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0132928xC7gXsFznZ8qgRPxY","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/storage/graph.zig","old_string":"    /// Get all issues that are ready (open, not blocked by open issues, not deferred).\n    pub fn getReadyIssues(self: *Self) ![]Issue {\n        const now = std.time.timestamp();\n\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open\n            if (!statusEql(issue.status, .open)) continue;\n\n            // Must not be deferred to future\n            if (issue.defer_until.value) |defer_time| {\n                if (defer_time > now) continue;\n            }","new_string":"    /// Get all issues that are ready (open, not blocked by open issues, optionally not deferred).\n    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n        const now = std.time.timestamp();\n\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open (or deferred if include_deferred is set)\n            if (statusEql(issue.status, .deferred)) {\n                if (!include_deferred) continue;\n            } else if (!statusEql(issue.status, .open)) {\n                continue;\n            }\n\n            // Must not be deferred to future (unless including deferred)\n            if (!include_deferred) {\n                if (issue.defer_until.value) |defer_time| {\n                    if (defer_time > now) continue;\n                }\n            }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":802,"cache_read_input_tokens":64295,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":802},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"2231bd37-7f11-456e-8876-ac7c5668da0f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0132928xC7gXsFznZ8qgRPxY","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/storage/graph.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f71acea6-947b-4cb6-8718-5553133226e6","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/storage/graph.zig","oldString":"    /// Get all issues that are ready (open, not blocked by open issues, not deferred).\n    pub fn getReadyIssues(self: *Self) ![]Issue {\n        const now = std.time.timestamp();\n\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open\n            if (!statusEql(issue.status, .open)) continue;\n\n            // Must not be deferred to future\n            if (issue.defer_until.value) |defer_time| {\n                if (defer_time > now) continue;\n            }","newString":"    /// Get all issues that are ready (open, not blocked by open issues, optionally not deferred).\n    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n        const now = std.time.timestamp();\n\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open (or deferred if include_deferred is set)\n            if (statusEql(issue.status, .deferred)) {\n                if (!include_deferred) continue;\n            } else if (!statusEql(issue.status, .open)) {\n                continue;\n            }\n\n            // Must not be deferred to future (unless including deferred)\n            if (!include_deferred) {\n                if (issue.defer_until.value) |defer_time| {\n                    if (defer_time > now) continue;\n                }\n            }","originalFile":"//! Dependency graph operations for beads_zig.\n//!\n//! Provides dependency management including:\n//! - Add/remove dependencies\n//! - Cycle detection (DFS algorithm)\n//! - Query dependencies and dependents\n//! - Ready/blocked issue queries\n\nconst std = @import(\"std\");\nconst store_mod = @import(\"store.zig\");\nconst IssueStore = store_mod.IssueStore;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Status = @import(\"../models/status.zig\").Status;\n\npub const DependencyGraphError = error{\n    SelfDependency,\n    CycleDetected,\n    DependencyNotFound,\n    IssueNotFound,\n};\n\npub const DependencyGraph = struct {\n    store: *IssueStore,\n    allocator: std.mem.Allocator,\n\n    const Self = @This();\n\n    pub fn init(store: *IssueStore, allocator: std.mem.Allocator) Self {\n        return .{\n            .store = store,\n            .allocator = allocator,\n        };\n    }\n\n    /// Add a dependency (issue_id depends on depends_on_id).\n    /// Returns error.SelfDependency if trying to depend on self.\n    /// Returns error.CycleDetected if adding would create a cycle.\n    pub fn addDependency(self: *Self, dep: Dependency) !void {\n        // Check for self-dependency\n        if (std.mem.eql(u8, dep.issue_id, dep.depends_on_id)) {\n            return DependencyGraphError.SelfDependency;\n        }\n\n        // Check if issue exists\n        const issue = self.store.getRef(dep.issue_id) orelse\n            return DependencyGraphError.IssueNotFound;\n\n        // Check for cycles before inserting\n        if (try self.wouldCreateCycle(dep.issue_id, dep.depends_on_id)) {\n            return DependencyGraphError.CycleDetected;\n        }\n\n        // Check if dependency already exists\n        for (issue.dependencies) |existing| {\n            if (std.mem.eql(u8, existing.depends_on_id, dep.depends_on_id)) {\n                return; // Already exists, no-op\n            }\n        }\n\n        // Clone and add the dependency\n        const cloned = try cloneDependency(dep, self.allocator);\n        errdefer freeDependency(@constCast(&cloned), self.allocator);\n\n        const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len + 1);\n        @memcpy(new_deps[0..issue.dependencies.len], issue.dependencies);\n        new_deps[issue.dependencies.len] = cloned;\n\n        // Only free the old array, not the dependency contents (they're now in new_deps)\n        if (issue.dependencies.len > 0) {\n            self.allocator.free(issue.dependencies);\n        }\n        issue.dependencies = new_deps;\n\n        try self.store.markDirty(dep.issue_id);\n    }\n\n    /// Remove a dependency.\n    pub fn removeDependency(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !void {\n        const issue = self.store.getRef(issue_id) orelse\n            return DependencyGraphError.IssueNotFound;\n\n        var found_idx: ?usize = null;\n        for (issue.dependencies, 0..) |dep, i| {\n            if (std.mem.eql(u8, dep.depends_on_id, depends_on_id)) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx) |fi| {\n            freeDependency(@constCast(&issue.dependencies[fi]), self.allocator);\n\n            if (issue.dependencies.len == 1) {\n                self.allocator.free(issue.dependencies);\n                issue.dependencies = &[_]Dependency{};\n            } else {\n                const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len - 1);\n                var j: usize = 0;\n                for (issue.dependencies, 0..) |dep, i| {\n                    if (i != fi) {\n                        new_deps[j] = dep;\n                        j += 1;\n                    }\n                }\n                self.allocator.free(issue.dependencies);\n                issue.dependencies = new_deps;\n            }\n\n            try self.store.markDirty(issue_id);\n        }\n    }\n\n    /// Get dependencies for an issue (what it depends on).\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]Dependency {\n        const issue = self.store.getRef(issue_id) orelse return &[_]Dependency{};\n\n        if (issue.dependencies.len == 0) return &[_]Dependency{};\n\n        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n        errdefer self.allocator.free(deps);\n\n        for (issue.dependencies, 0..) |dep, i| {\n            deps[i] = try cloneDependency(dep, self.allocator);\n        }\n\n        return deps;\n    }\n\n    /// Get dependents of an issue (what depends on it).\n    pub fn getDependents(self: *Self, issue_id: []const u8) ![]Dependency {\n        var deps: std.ArrayListUnmanaged(Dependency) = .{};\n        errdefer {\n            for (deps.items) |*dep| {\n                freeDependency(dep, self.allocator);\n            }\n            deps.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            for (issue.dependencies) |dep| {\n                if (std.mem.eql(u8, dep.depends_on_id, issue_id)) {\n                    const cloned = try cloneDependency(dep, self.allocator);\n                    try deps.append(self.allocator, cloned);\n                }\n            }\n        }\n\n        return deps.toOwnedSlice(self.allocator);\n    }\n\n    /// Check if adding a dependency would create a cycle.\n    /// Uses DFS from depends_on_id to see if it can reach issue_id.\n    pub fn wouldCreateCycle(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !bool {\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer {\n            var key_it = visited.keyIterator();\n            while (key_it.next()) |key| {\n                self.allocator.free(key.*);\n            }\n            visited.deinit(self.allocator);\n        }\n\n        return try self.dfsReachable(depends_on_id, issue_id, &visited);\n    }\n\n    fn dfsReachable(self: *Self, from: []const u8, target: []const u8, visited: *std.StringHashMapUnmanaged(void)) !bool {\n        if (std.mem.eql(u8, from, target)) return true;\n        if (visited.contains(from)) return false;\n\n        const from_copy = try self.allocator.dupe(u8, from);\n        errdefer self.allocator.free(from_copy);\n        try visited.put(self.allocator, from_copy, {});\n\n        const issue = self.store.getRef(from) orelse return false;\n\n        for (issue.dependencies) |dep| {\n            if (try self.dfsReachable(dep.depends_on_id, target, visited)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// Detect all cycles in the dependency graph.\n    /// Returns array of cycle paths, or null if no cycles.\n    pub fn detectCycles(self: *Self) !?[][]const u8 {\n        var all_issues: std.StringHashMapUnmanaged(void) = .{};\n        defer {\n            var it = all_issues.keyIterator();\n            while (it.next()) |key| {\n                self.allocator.free(key.*);\n            }\n            all_issues.deinit(self.allocator);\n        }\n\n        // Collect all issue IDs involved in dependencies\n        for (self.store.getAllRef()) |issue| {\n            if (issue.dependencies.len > 0) {\n                if (!all_issues.contains(issue.id)) {\n                    const id_copy = try self.allocator.dupe(u8, issue.id);\n                    try all_issues.put(self.allocator, id_copy, {});\n                }\n                for (issue.dependencies) |dep| {\n                    if (!all_issues.contains(dep.depends_on_id)) {\n                        const id_copy = try self.allocator.dupe(u8, dep.depends_on_id);\n                        try all_issues.put(self.allocator, id_copy, {});\n                    }\n                }\n            }\n        }\n\n        var cycles: std.ArrayListUnmanaged([]const u8) = .{};\n        errdefer {\n            for (cycles.items) |c| {\n                self.allocator.free(c);\n            }\n            cycles.deinit(self.allocator);\n        }\n\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer visited.deinit(self.allocator);\n\n        var rec_stack: std.StringHashMapUnmanaged(void) = .{};\n        defer rec_stack.deinit(self.allocator);\n\n        var it = all_issues.keyIterator();\n        while (it.next()) |key| {\n            if (!visited.contains(key.*)) {\n                var path: std.ArrayListUnmanaged([]const u8) = .{};\n                defer path.deinit(self.allocator);\n\n                if (try self.detectCycleDfs(key.*, &visited, &rec_stack, &path)) {\n                    const cycle_str = try std.mem.join(self.allocator, \" -> \", path.items);\n                    try cycles.append(self.allocator, cycle_str);\n                }\n            }\n        }\n\n        if (cycles.items.len == 0) {\n            return null;\n        }\n\n        return try cycles.toOwnedSlice(self.allocator);\n    }\n\n    fn detectCycleDfs(\n        self: *Self,\n        node: []const u8,\n        visited: *std.StringHashMapUnmanaged(void),\n        rec_stack: *std.StringHashMapUnmanaged(void),\n        path: *std.ArrayListUnmanaged([]const u8),\n    ) !bool {\n        try visited.put(self.allocator, node, {});\n        try rec_stack.put(self.allocator, node, {});\n        try path.append(self.allocator, node);\n\n        const issue = self.store.getRef(node) orelse {\n            _ = path.pop();\n            _ = rec_stack.remove(node);\n            return false;\n        };\n\n        for (issue.dependencies) |dep| {\n            if (!visited.contains(dep.depends_on_id)) {\n                if (try self.detectCycleDfs(dep.depends_on_id, visited, rec_stack, path)) {\n                    return true;\n                }\n            } else if (rec_stack.contains(dep.depends_on_id)) {\n                try path.append(self.allocator, dep.depends_on_id);\n                return true;\n            }\n        }\n\n        _ = rec_stack.remove(node);\n        _ = path.pop();\n        return false;\n    }\n\n    /// Get all issues that are ready (open, not blocked by open issues, not deferred).\n    pub fn getReadyIssues(self: *Self) ![]Issue {\n        const now = std.time.timestamp();\n\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open\n            if (!statusEql(issue.status, .open)) continue;\n\n            // Must not be deferred to future\n            if (issue.defer_until.value) |defer_time| {\n                if (defer_time > now) continue;\n            }\n\n            // Must not have any open blockers\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get all blocked issues (open issues with unresolved dependencies).\n    pub fn getBlockedIssues(self: *Self) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open\n            if (!statusEql(issue.status, .open)) continue;\n\n            // Must have at least one open blocker\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (!has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get blockers for an issue (open issues that this issue depends on).\n    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        const issue = self.store.getRef(issue_id) orelse return results.toOwnedSlice(self.allocator);\n\n        for (issue.dependencies) |dep| {\n            if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                if (!statusEql(blocker.status, .closed) and\n                    !statusEql(blocker.status, .tombstone))\n                {\n                    try results.append(self.allocator, try blocker.clone(self.allocator));\n                }\n            }\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Free an array of dependencies.\n    pub fn freeDependencies(self: *Self, deps: []Dependency) void {\n        for (deps) |*dep| {\n            freeDependency(dep, self.allocator);\n        }\n        self.allocator.free(deps);\n    }\n\n    /// Free an array of issues.\n    pub fn freeIssues(self: *Self, issues: []Issue) void {\n        for (issues) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        self.allocator.free(issues);\n    }\n\n    /// Free an array of cycle strings.\n    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n        for (cycles) |c| {\n            self.allocator.free(c);\n        }\n        self.allocator.free(cycles);\n    }\n};\n\n// Helper functions\nfn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n    var result: Dependency = undefined;\n\n    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n    errdefer allocator.free(result.issue_id);\n\n    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n    errdefer allocator.free(result.depends_on_id);\n\n    result.dep_type = switch (dep.dep_type) {\n        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n        else => dep.dep_type,\n    };\n\n    result.created_at = dep.created_at;\n    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n\n    return result;\n}\n\nfn freeDependency(dep: *Dependency, allocator: std.mem.Allocator) void {\n    allocator.free(dep.issue_id);\n    allocator.free(dep.depends_on_id);\n    switch (dep.dep_type) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n    if (dep.created_by) |c| allocator.free(c);\n    if (dep.metadata) |m| allocator.free(m);\n    if (dep.thread_id) |t| allocator.free(t);\n}\n\n// --- Tests ---\n\ntest \"DependencyGraph rejects self-dependency\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-self\", \"Self\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    const dep = Dependency{\n        .issue_id = \"bd-self\",\n        .depends_on_id = \"bd-self\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expectError(DependencyGraphError.SelfDependency, graph.addDependency(dep));\n}\n\ntest \"DependencyGraph rejects direct cycle\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    // A depends on B\n    try graph.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-b\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // B depends on A would create a cycle\n    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n        .issue_id = \"bd-b\",\n        .depends_on_id = \"bd-a\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    }));\n}\n\ntest \"DependencyGraph rejects indirect cycle\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n    try store.insert(Issue.init(\"bd-c\", \"C\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    // A depends on B\n    try graph.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-b\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // B depends on C\n    try graph.addDependency(.{\n        .issue_id = \"bd-b\",\n        .depends_on_id = \"bd-c\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // C depends on A would create a cycle\n    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n        .issue_id = \"bd-c\",\n        .depends_on_id = \"bd-a\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    }));\n}\n\ntest \"DependencyGraph getReadyIssues excludes blocked\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-blocked\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try graph.getReadyIssues();\n    defer graph.freeIssues(ready);\n\n    try std.testing.expectEqual(@as(usize, 2), ready.len);\n\n    // Verify blocked is not in the list\n    for (ready) |issue| {\n        try std.testing.expect(!std.mem.eql(u8, issue.id, \"bd-blocked\"));\n    }\n}\n\ntest \"DependencyGraph getReadyIssues includes when blocker closed\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    var blocker = Issue.init(\"bd-blocker\", \"Blocker\", 1706540000);\n    blocker.status = .closed;\n    try store.insert(blocker);\n    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-child\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try graph.getReadyIssues();\n    defer graph.freeIssues(ready);\n\n    try std.testing.expectEqual(@as(usize, 1), ready.len);\n    try std.testing.expectEqualStrings(\"bd-child\", ready[0].id);\n}\n\ntest \"DependencyGraph getBlockedIssues returns only blocked\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-blocked\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const blocked = try graph.getBlockedIssues();\n    defer graph.freeIssues(blocked);\n\n    try std.testing.expectEqual(@as(usize, 1), blocked.len);\n    try std.testing.expectEqualStrings(\"bd-blocked\", blocked[0].id);\n}\n","structuredPatch":[{"oldStart":278,"oldLines":8,"newStart":278,"newLines":8,"lines":["         return false;","     }"," ","-    /// Get all issues that are ready (open, not blocked by open issues, not deferred).","-    pub fn getReadyIssues(self: *Self) ![]Issue {","+    /// Get all issues that are ready (open, not blocked by open issues, optionally not deferred).","+    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {","         const now = std.time.timestamp();"," ","         var results: std.ArrayListUnmanaged(Issue) = .{};"]},{"oldStart":291,"oldLines":12,"newStart":291,"newLines":18,"lines":["         }"," ","         for (self.store.getAllRef()) |issue| {","-            // Must be open","-            if (!statusEql(issue.status, .open)) continue;","+            // Must be open (or deferred if include_deferred is set)","+            if (statusEql(issue.status, .deferred)) {","+                if (!include_deferred) continue;","+            } else if (!statusEql(issue.status, .open)) {","+                continue;","+            }"," ","-            // Must not be deferred to future","-            if (issue.defer_until.value) |defer_time| {","-                if (defer_time > now) continue;","+            // Must not be deferred to future (unless including deferred)","+            if (!include_deferred) {","+                if (issue.defer_until.value) |defer_time| {","+                    if (defer_time > now) continue;","+                }","             }"," ","             // Must not have any open blockers"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BNiV72RVfTtwciDDNvDAqG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FU3uZ3G3Gf85wJYjDjKYKP","name":"TodoWrite","input":{"todos":[{"content":"Add --overdue filter for list and ready commands","status":"completed","activeForm":"Adding --overdue filter for list and ready commands"},{"content":"Add --deferred flag to include deferred issues in list","status":"completed","activeForm":"Adding --deferred flag to include deferred issues in list"},{"content":"Run tests and verify implementation","status":"in_progress","activeForm":"Running tests and verifying implementation"},{"content":"Commit all changes","status":"pending","activeForm":"Committing all changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":856,"cache_read_input_tokens":65097,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":856},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"7a677810-edab-4d51-bf87-7777340bc45d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FU3uZ3G3Gf85wJYjDjKYKP","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"1321a3e4-b062-4cb6-9cf0-ca1aaa0f2b01","tool_use_result":{"oldTodos":[{"content":"Add --overdue filter for list and ready commands","status":"in_progress","activeForm":"Adding --overdue filter for list and ready commands"},{"content":"Add --deferred flag to include deferred issues in list","status":"pending","activeForm":"Adding --deferred flag to include deferred issues in list"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Commit all changes","status":"pending","activeForm":"Committing all changes"}],"newTodos":[{"content":"Add --overdue filter for list and ready commands","status":"completed","activeForm":"Adding --overdue filter for list and ready commands"},{"content":"Add --deferred flag to include deferred issues in list","status":"completed","activeForm":"Adding --deferred flag to include deferred issues in list"},{"content":"Run tests and verify implementation","status":"in_progress","activeForm":"Running tests and verifying implementation"},{"content":"Commit all changes","status":"pending","activeForm":"Committing all changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TYEAGiYv3ESrLdYgCBFCDZ","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me run the build to check for compilation errors."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":232,"cache_read_input_tokens":65953,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":232},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"7fa92664-895f-42ae-b6ce-46675f283a27"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TYEAGiYv3ESrLdYgCBFCDZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GAnRsvkXiSr4mnHdH7Wrfh","name":"Bash","input":{"command":"zig build 2>&1","description":"Build the project to check for compilation errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":232,"cache_read_input_tokens":65953,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":232},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"acda51f5-5cc4-4bf3-b598-dcf02db8f403"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GAnRsvkXiSr4mnHdH7Wrfh","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"eadd5842-0260-4f85-91c6-05578ec77a4e","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019KURv964By6r5cVBgwa515","type":"message","role":"assistant","content":[{"type":"text","text":"Build succeeded. Now let me run the tests to verify the implementation."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":121,"cache_read_input_tokens":66185,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":121},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"dc062756-8b2d-42c8-9420-208d17e8a48d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019KURv964By6r5cVBgwa515","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019nJzLqYjDdTJvMxhBViKck","name":"Bash","input":{"command":"zig build test 2>&1 | head -100","description":"Run the test suite","timeout":300000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":121,"cache_read_input_tokens":66185,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":121},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"0917872d-0eb4-4db9-b28c-0badc4e73552"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019nJzLqYjDdTJvMxhBViKck","type":"tool_result","content":"\u001b[2mtest\n\u001b(0mq\u001b(B run test\n   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 4 errors\n\u001b[0m\u001b[0m\u001b[1msrc/storage/dependencies.zig:283:32: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 1 argument(s), found 0\n\u001b[0m    const ready = try dep_store.getReadyIssues();\n                      \u001b[32m~~~~~~~~~^~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:282:9: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n    \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    dependencies: src/storage/mod.zig:18:34\n    refAllDecls__anon_74487: /opt/zig/lib/std/testing.zig:1179:14\n    12 reference(s) hidden; use '-freference-trace=14' to see all references\n\u001b[0m\u001b[1msrc/storage/dependencies.zig:319:32: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 1 argument(s), found 0\n\u001b[0m    const ready = try dep_store.getReadyIssues();\n                      \u001b[32m~~~~~~~~~^~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:282:9: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n    \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:598:28: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 1 argument(s), found 0\n\u001b[0m    const ready = try graph.getReadyIssues();\n                      \u001b[32m~~~~~^~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:282:9: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n    \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:631:28: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 1 argument(s), found 0\n\u001b[0m    const ready = try graph.getReadyIssues();\n                      \u001b[32m~~~~~^~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:282:9: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n    \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 4 compilation errors:\n/opt/zig/zig test -ODebug --dep toon_zig -Mroot=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name test --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 0/3 steps succeeded; 1 failed\ntest\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B run test\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 4 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x5312d5ab -Zab6d920a6c99114b test","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"88ffb74d-f1f9-4368-8bcf-06b58314a1cb","tool_use_result":{"stdout":"\u001b[2mtest\n\u001b(0mq\u001b(B run test\n   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 4 errors\n\u001b[0m\u001b[0m\u001b[1msrc/storage/dependencies.zig:283:32: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 1 argument(s), found 0\n\u001b[0m    const ready = try dep_store.getReadyIssues();\n                      \u001b[32m~~~~~~~~~^~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:282:9: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n    \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    dependencies: src/storage/mod.zig:18:34\n    refAllDecls__anon_74487: /opt/zig/lib/std/testing.zig:1179:14\n    12 reference(s) hidden; use '-freference-trace=14' to see all references\n\u001b[0m\u001b[1msrc/storage/dependencies.zig:319:32: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 1 argument(s), found 0\n\u001b[0m    const ready = try dep_store.getReadyIssues();\n                      \u001b[32m~~~~~~~~~^~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:282:9: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n    \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:598:28: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 1 argument(s), found 0\n\u001b[0m    const ready = try graph.getReadyIssues();\n                      \u001b[32m~~~~~^~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:282:9: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n    \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:631:28: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 1 argument(s), found 0\n\u001b[0m    const ready = try graph.getReadyIssues();\n                      \u001b[32m~~~~~^~~~~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/storage/graph.zig:282:9: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n    \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 4 compilation errors:\n/opt/zig/zig test -ODebug --dep toon_zig -Mroot=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name test --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 0/3 steps succeeded; 1 failed\ntest\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B run test\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 4 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x5312d5ab -Zab6d920a6c99114b test","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019amPLWeBhmYwfnN8quQ8c5","type":"message","role":"assistant","content":[{"type":"text","text":"I need to fix the test files that call `getReadyIssues()` without the new parameter. Let me fix them."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1228,"cache_read_input_tokens":66306,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1228},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"09c8bb44-484e-4b0d-a26b-42b690cf5f72"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019amPLWeBhmYwfnN8quQ8c5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016ywFQZTFxqFJf76mKvAnP6","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/dependencies.zig","offset":275,"limit":60}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1228,"cache_read_input_tokens":66306,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1228},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"7df26eb1-148d-44c6-b5aa-b6cb09235754"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016ywFQZTFxqFJf76mKvAnP6","type":"tool_result","content":"   275→        .depends_on_id = \"bd-blocker\",\n   276→        .dep_type = .blocks,\n   277→        .created_at = 1706540000,\n   278→        .created_by = null,\n   279→        .metadata = null,\n   280→        .thread_id = null,\n   281→    });\n   282→\n   283→    const ready = try dep_store.getReadyIssues();\n   284→    defer dep_store.freeIssues(ready);\n   285→\n   286→    // Should only have ready and blocker (blocker has no deps)\n   287→    try std.testing.expectEqual(@as(usize, 2), ready.len);\n   288→\n   289→    // Verify blocked is not in the list\n   290→    for (ready) |issue| {\n   291→        try std.testing.expect(!std.mem.eql(u8, issue.id, \"bd-blocked\"));\n   292→    }\n   293→}\n   294→\n   295→test \"DependencyStore.getReadyIssues includes issue when blocker is closed\" {\n   296→    const allocator = std.testing.allocator;\n   297→    var store = IssueStore.init(allocator, \"test_dep_ready_closed.jsonl\");\n   298→    defer store.deinit();\n   299→\n   300→    var blocker = Issue.init(\"bd-blocker\", \"Blocker\", 1706540000);\n   301→    blocker.status = .closed;\n   302→    try store.insert(blocker);\n   303→\n   304→    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n   305→\n   306→    var dep_store = DependencyStore.init(&store, allocator);\n   307→\n   308→    // child depends on blocker (which is closed)\n   309→    try dep_store.addDependency(.{\n   310→        .issue_id = \"bd-child\",\n   311→        .depends_on_id = \"bd-blocker\",\n   312→        .dep_type = .blocks,\n   313→        .created_at = 1706540000,\n   314→        .created_by = null,\n   315→        .metadata = null,\n   316→        .thread_id = null,\n   317→    });\n   318→\n   319→    const ready = try dep_store.getReadyIssues();\n   320→    defer dep_store.freeIssues(ready);\n   321→\n   322→    // Child should be ready since blocker is closed\n   323→    try std.testing.expectEqual(@as(usize, 1), ready.len);\n   324→    try std.testing.expectEqualStrings(\"bd-child\", ready[0].id);\n   325→}\n   326→\n   327→test \"DependencyStore.getBlockedIssues returns only blocked issues\" {\n   328→    const allocator = std.testing.allocator;\n   329→    var store = IssueStore.init(allocator, \"test_dep_blocked.jsonl\");\n   330→    defer store.deinit();\n   331→\n   332→    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n   333→    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n   334→    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"05e4052c-2a7b-47d9-8722-b3ed5f579b92","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/storage/dependencies.zig","content":"        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try dep_store.getReadyIssues();\n    defer dep_store.freeIssues(ready);\n\n    // Should only have ready and blocker (blocker has no deps)\n    try std.testing.expectEqual(@as(usize, 2), ready.len);\n\n    // Verify blocked is not in the list\n    for (ready) |issue| {\n        try std.testing.expect(!std.mem.eql(u8, issue.id, \"bd-blocked\"));\n    }\n}\n\ntest \"DependencyStore.getReadyIssues includes issue when blocker is closed\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_ready_closed.jsonl\");\n    defer store.deinit();\n\n    var blocker = Issue.init(\"bd-blocker\", \"Blocker\", 1706540000);\n    blocker.status = .closed;\n    try store.insert(blocker);\n\n    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    // child depends on blocker (which is closed)\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-child\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try dep_store.getReadyIssues();\n    defer dep_store.freeIssues(ready);\n\n    // Child should be ready since blocker is closed\n    try std.testing.expectEqual(@as(usize, 1), ready.len);\n    try std.testing.expectEqualStrings(\"bd-child\", ready[0].id);\n}\n\ntest \"DependencyStore.getBlockedIssues returns only blocked issues\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_blocked.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));","numLines":60,"startLine":275,"totalLines":390}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019amPLWeBhmYwfnN8quQ8c5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UrwnohXfDjAx23tniyxY2Y","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/graph.zig","offset":590,"limit":60}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1228,"cache_read_input_tokens":66306,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1228},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"298fe2b8-2c89-4c13-9ed7-9f619c5c56b3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UrwnohXfDjAx23tniyxY2Y","type":"tool_result","content":"   590→        .depends_on_id = \"bd-blocker\",\n   591→        .dep_type = .blocks,\n   592→        .created_at = 1706540000,\n   593→        .created_by = null,\n   594→        .metadata = null,\n   595→        .thread_id = null,\n   596→    });\n   597→\n   598→    const ready = try graph.getReadyIssues();\n   599→    defer graph.freeIssues(ready);\n   600→\n   601→    try std.testing.expectEqual(@as(usize, 2), ready.len);\n   602→\n   603→    // Verify blocked is not in the list\n   604→    for (ready) |issue| {\n   605→        try std.testing.expect(!std.mem.eql(u8, issue.id, \"bd-blocked\"));\n   606→    }\n   607→}\n   608→\n   609→test \"DependencyGraph getReadyIssues includes when blocker closed\" {\n   610→    const allocator = std.testing.allocator;\n   611→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   612→    defer store.deinit();\n   613→\n   614→    var blocker = Issue.init(\"bd-blocker\", \"Blocker\", 1706540000);\n   615→    blocker.status = .closed;\n   616→    try store.insert(blocker);\n   617→    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n   618→\n   619→    var graph = DependencyGraph.init(&store, allocator);\n   620→\n   621→    try graph.addDependency(.{\n   622→        .issue_id = \"bd-child\",\n   623→        .depends_on_id = \"bd-blocker\",\n   624→        .dep_type = .blocks,\n   625→        .created_at = 1706540000,\n   626→        .created_by = null,\n   627→        .metadata = null,\n   628→        .thread_id = null,\n   629→    });\n   630→\n   631→    const ready = try graph.getReadyIssues();\n   632→    defer graph.freeIssues(ready);\n   633→\n   634→    try std.testing.expectEqual(@as(usize, 1), ready.len);\n   635→    try std.testing.expectEqualStrings(\"bd-child\", ready[0].id);\n   636→}\n   637→\n   638→test \"DependencyGraph getBlockedIssues returns only blocked\" {\n   639→    const allocator = std.testing.allocator;\n   640→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   641→    defer store.deinit();\n   642→\n   643→    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n   644→    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n   645→    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n   646→\n   647→    var graph = DependencyGraph.init(&store, allocator);\n   648→\n   649→    try graph.addDependency(.{\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"d00732d4-64a7-4369-9c82-d63b1379c7a1","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/storage/graph.zig","content":"        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try graph.getReadyIssues();\n    defer graph.freeIssues(ready);\n\n    try std.testing.expectEqual(@as(usize, 2), ready.len);\n\n    // Verify blocked is not in the list\n    for (ready) |issue| {\n        try std.testing.expect(!std.mem.eql(u8, issue.id, \"bd-blocked\"));\n    }\n}\n\ntest \"DependencyGraph getReadyIssues includes when blocker closed\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    var blocker = Issue.init(\"bd-blocker\", \"Blocker\", 1706540000);\n    blocker.status = .closed;\n    try store.insert(blocker);\n    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-child\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try graph.getReadyIssues();\n    defer graph.freeIssues(ready);\n\n    try std.testing.expectEqual(@as(usize, 1), ready.len);\n    try std.testing.expectEqualStrings(\"bd-child\", ready[0].id);\n}\n\ntest \"DependencyGraph getBlockedIssues returns only blocked\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{","numLines":60,"startLine":590,"totalLines":665}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Rq14j8xVEHAxwmRNoxicqU","type":"message","role":"assistant","content":[{"type":"text","text":"I need to update the test files to pass `false` as the default for `include_deferred`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2169,"cache_read_input_tokens":67534,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2169},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"293bb9c7-388c-41ad-a9fc-f671b9bbfc15"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Rq14j8xVEHAxwmRNoxicqU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CjnSVZDMB5uc3ANBSWqhNk","name":"Edit","input":{"replace_all":true,"file_path":"/home/hotschmoe/beads_zig/src/storage/dependencies.zig","old_string":"dep_store.getReadyIssues()","new_string":"dep_store.getReadyIssues(false)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2169,"cache_read_input_tokens":67534,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2169},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"296fb3e3-6c4a-44aa-9dc7-490c1e839a59"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CjnSVZDMB5uc3ANBSWqhNk","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/storage/dependencies.zig has been updated. All occurrences of 'dep_store.getReadyIssues()' were successfully replaced with 'dep_store.getReadyIssues(false)'."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"4ef93dec-ed99-4c15-847e-a17142b8537d","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/storage/dependencies.zig","oldString":"dep_store.getReadyIssues()","newString":"dep_store.getReadyIssues(false)","originalFile":"//! Dependency storage operations for beads_zig.\n//!\n//! Provides operations for managing issue dependencies including:\n//! - Add/remove dependencies\n//! - Cycle detection (prevents circular dependencies)\n//! - Query dependencies and dependents\n//! - Ready/blocked issue queries\n//!\n//! This module wraps the DependencyGraph for backwards compatibility.\n\nconst std = @import(\"std\");\nconst graph_mod = @import(\"graph.zig\");\nconst store_mod = @import(\"store.zig\");\nconst IssueStore = store_mod.IssueStore;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\n\npub const DependencyStoreError = graph_mod.DependencyGraphError;\n\n/// Re-export DependencyGraph as DependencyStore for backwards compatibility.\npub const DependencyStore = graph_mod.DependencyGraph;\n\n// --- Tests ---\n\ntest \"DependencyStore.add creates dependency\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_add.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-parent\", \"Parent\", 1706540000));\n    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    const dep = Dependency{\n        .issue_id = \"bd-child\",\n        .depends_on_id = \"bd-parent\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try dep_store.addDependency(dep);\n\n    const deps = try dep_store.getDependencies(\"bd-child\");\n    defer dep_store.freeDependencies(deps);\n\n    try std.testing.expectEqual(@as(usize, 1), deps.len);\n    try std.testing.expectEqualStrings(\"bd-parent\", deps[0].depends_on_id);\n}\n\ntest \"DependencyStore.add rejects self-dependency\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_self.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-self\", \"Self\", 1706540000));\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    const dep = Dependency{\n        .issue_id = \"bd-self\",\n        .depends_on_id = \"bd-self\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expectError(DependencyStoreError.SelfDependency, dep_store.addDependency(dep));\n}\n\ntest \"DependencyStore.add rejects direct cycle\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_direct_cycle.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    // A depends on B\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-b\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // B depends on A would create a cycle\n    const cycle_dep = Dependency{\n        .issue_id = \"bd-b\",\n        .depends_on_id = \"bd-a\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expectError(DependencyStoreError.CycleDetected, dep_store.addDependency(cycle_dep));\n}\n\ntest \"DependencyStore.add rejects indirect cycle (A->B->C->A)\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_indirect_cycle.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n    try store.insert(Issue.init(\"bd-c\", \"C\", 1706540000));\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    // A depends on B\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-b\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // B depends on C\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-b\",\n        .depends_on_id = \"bd-c\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // C depends on A would create a cycle\n    const cycle_dep = Dependency{\n        .issue_id = \"bd-c\",\n        .depends_on_id = \"bd-a\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expectError(DependencyStoreError.CycleDetected, dep_store.addDependency(cycle_dep));\n}\n\ntest \"DependencyStore.remove removes dependency\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_remove.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-parent\", \"Parent\", 1706540000));\n    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-child\",\n        .depends_on_id = \"bd-parent\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    try dep_store.removeDependency(\"bd-child\", \"bd-parent\");\n\n    const deps = try dep_store.getDependencies(\"bd-child\");\n    defer dep_store.freeDependencies(deps);\n\n    try std.testing.expectEqual(@as(usize, 0), deps.len);\n}\n\ntest \"DependencyStore.getDependencies returns dependencies\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_get.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n    try store.insert(Issue.init(\"bd-c\", \"C\", 1706540000));\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    // A depends on B and C\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-b\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-c\",\n        .dep_type = .waits_for,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const deps = try dep_store.getDependencies(\"bd-a\");\n    defer dep_store.freeDependencies(deps);\n\n    try std.testing.expectEqual(@as(usize, 2), deps.len);\n}\n\ntest \"DependencyStore.getDependents returns dependents\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_dependents.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-parent\", \"Parent\", 1706540000));\n    try store.insert(Issue.init(\"bd-child1\", \"Child 1\", 1706540000));\n    try store.insert(Issue.init(\"bd-child2\", \"Child 2\", 1706540000));\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    // Both children depend on parent\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-child1\",\n        .depends_on_id = \"bd-parent\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-child2\",\n        .depends_on_id = \"bd-parent\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const dependents = try dep_store.getDependents(\"bd-parent\");\n    defer dep_store.freeDependencies(dependents);\n\n    try std.testing.expectEqual(@as(usize, 2), dependents.len);\n}\n\ntest \"DependencyStore.getReadyIssues excludes blocked issues\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_ready.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    // blocked depends on blocker\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-blocked\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try dep_store.getReadyIssues();\n    defer dep_store.freeIssues(ready);\n\n    // Should only have ready and blocker (blocker has no deps)\n    try std.testing.expectEqual(@as(usize, 2), ready.len);\n\n    // Verify blocked is not in the list\n    for (ready) |issue| {\n        try std.testing.expect(!std.mem.eql(u8, issue.id, \"bd-blocked\"));\n    }\n}\n\ntest \"DependencyStore.getReadyIssues includes issue when blocker is closed\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_ready_closed.jsonl\");\n    defer store.deinit();\n\n    var blocker = Issue.init(\"bd-blocker\", \"Blocker\", 1706540000);\n    blocker.status = .closed;\n    try store.insert(blocker);\n\n    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    // child depends on blocker (which is closed)\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-child\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try dep_store.getReadyIssues();\n    defer dep_store.freeIssues(ready);\n\n    // Child should be ready since blocker is closed\n    try std.testing.expectEqual(@as(usize, 1), ready.len);\n    try std.testing.expectEqualStrings(\"bd-child\", ready[0].id);\n}\n\ntest \"DependencyStore.getBlockedIssues returns only blocked issues\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_blocked.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    // blocked depends on blocker\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-blocked\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const blocked = try dep_store.getBlockedIssues();\n    defer dep_store.freeIssues(blocked);\n\n    try std.testing.expectEqual(@as(usize, 1), blocked.len);\n    try std.testing.expectEqualStrings(\"bd-blocked\", blocked[0].id);\n}\n\ntest \"DependencyStore dirty tracking on add\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test_dep_dirty.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-parent\", \"Parent\", 1706540000));\n    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n\n    // Clear dirty flags from insert\n    try store.clearDirty(\"bd-parent\");\n    try store.clearDirty(\"bd-child\");\n\n    var dep_store = DependencyStore.init(&store, allocator);\n\n    try dep_store.addDependency(.{\n        .issue_id = \"bd-child\",\n        .depends_on_id = \"bd-parent\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // Child should be marked dirty\n    const dirty_ids = try store.getDirtyIds();\n    defer {\n        for (dirty_ids) |id| allocator.free(id);\n        allocator.free(dirty_ids);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), dirty_ids.len);\n    try std.testing.expectEqualStrings(\"bd-child\", dirty_ids[0]);\n}\n","structuredPatch":[{"oldStart":280,"oldLines":7,"newStart":280,"newLines":7,"lines":["         .thread_id = null,","     });"," ","-    const ready = try dep_store.getReadyIssues();","+    const ready = try dep_store.getReadyIssues(false);","     defer dep_store.freeIssues(ready);"," ","     // Should only have ready and blocker (blocker has no deps)"]},{"oldStart":316,"oldLines":7,"newStart":316,"newLines":7,"lines":["         .thread_id = null,","     });"," ","-    const ready = try dep_store.getReadyIssues();","+    const ready = try dep_store.getReadyIssues(false);","     defer dep_store.freeIssues(ready);"," ","     // Child should be ready since blocker is closed"]}],"userModified":false,"replaceAll":true}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Rq14j8xVEHAxwmRNoxicqU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DF3rQFFf61yefi2RKzpKTD","name":"Edit","input":{"replace_all":true,"file_path":"/home/hotschmoe/beads_zig/src/storage/graph.zig","old_string":"graph.getReadyIssues()","new_string":"graph.getReadyIssues(false)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2169,"cache_read_input_tokens":67534,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2169},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"8098559e-4a12-4cde-9455-5ed9bcb9d65a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DF3rQFFf61yefi2RKzpKTD","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/storage/graph.zig has been updated. All occurrences of 'graph.getReadyIssues()' were successfully replaced with 'graph.getReadyIssues(false)'."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"80a2dec7-91bb-42e1-a48e-0d2e2e36ff26","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/storage/graph.zig","oldString":"graph.getReadyIssues()","newString":"graph.getReadyIssues(false)","originalFile":"//! Dependency graph operations for beads_zig.\n//!\n//! Provides dependency management including:\n//! - Add/remove dependencies\n//! - Cycle detection (DFS algorithm)\n//! - Query dependencies and dependents\n//! - Ready/blocked issue queries\n\nconst std = @import(\"std\");\nconst store_mod = @import(\"store.zig\");\nconst IssueStore = store_mod.IssueStore;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Status = @import(\"../models/status.zig\").Status;\n\npub const DependencyGraphError = error{\n    SelfDependency,\n    CycleDetected,\n    DependencyNotFound,\n    IssueNotFound,\n};\n\npub const DependencyGraph = struct {\n    store: *IssueStore,\n    allocator: std.mem.Allocator,\n\n    const Self = @This();\n\n    pub fn init(store: *IssueStore, allocator: std.mem.Allocator) Self {\n        return .{\n            .store = store,\n            .allocator = allocator,\n        };\n    }\n\n    /// Add a dependency (issue_id depends on depends_on_id).\n    /// Returns error.SelfDependency if trying to depend on self.\n    /// Returns error.CycleDetected if adding would create a cycle.\n    pub fn addDependency(self: *Self, dep: Dependency) !void {\n        // Check for self-dependency\n        if (std.mem.eql(u8, dep.issue_id, dep.depends_on_id)) {\n            return DependencyGraphError.SelfDependency;\n        }\n\n        // Check if issue exists\n        const issue = self.store.getRef(dep.issue_id) orelse\n            return DependencyGraphError.IssueNotFound;\n\n        // Check for cycles before inserting\n        if (try self.wouldCreateCycle(dep.issue_id, dep.depends_on_id)) {\n            return DependencyGraphError.CycleDetected;\n        }\n\n        // Check if dependency already exists\n        for (issue.dependencies) |existing| {\n            if (std.mem.eql(u8, existing.depends_on_id, dep.depends_on_id)) {\n                return; // Already exists, no-op\n            }\n        }\n\n        // Clone and add the dependency\n        const cloned = try cloneDependency(dep, self.allocator);\n        errdefer freeDependency(@constCast(&cloned), self.allocator);\n\n        const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len + 1);\n        @memcpy(new_deps[0..issue.dependencies.len], issue.dependencies);\n        new_deps[issue.dependencies.len] = cloned;\n\n        // Only free the old array, not the dependency contents (they're now in new_deps)\n        if (issue.dependencies.len > 0) {\n            self.allocator.free(issue.dependencies);\n        }\n        issue.dependencies = new_deps;\n\n        try self.store.markDirty(dep.issue_id);\n    }\n\n    /// Remove a dependency.\n    pub fn removeDependency(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !void {\n        const issue = self.store.getRef(issue_id) orelse\n            return DependencyGraphError.IssueNotFound;\n\n        var found_idx: ?usize = null;\n        for (issue.dependencies, 0..) |dep, i| {\n            if (std.mem.eql(u8, dep.depends_on_id, depends_on_id)) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx) |fi| {\n            freeDependency(@constCast(&issue.dependencies[fi]), self.allocator);\n\n            if (issue.dependencies.len == 1) {\n                self.allocator.free(issue.dependencies);\n                issue.dependencies = &[_]Dependency{};\n            } else {\n                const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len - 1);\n                var j: usize = 0;\n                for (issue.dependencies, 0..) |dep, i| {\n                    if (i != fi) {\n                        new_deps[j] = dep;\n                        j += 1;\n                    }\n                }\n                self.allocator.free(issue.dependencies);\n                issue.dependencies = new_deps;\n            }\n\n            try self.store.markDirty(issue_id);\n        }\n    }\n\n    /// Get dependencies for an issue (what it depends on).\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]Dependency {\n        const issue = self.store.getRef(issue_id) orelse return &[_]Dependency{};\n\n        if (issue.dependencies.len == 0) return &[_]Dependency{};\n\n        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n        errdefer self.allocator.free(deps);\n\n        for (issue.dependencies, 0..) |dep, i| {\n            deps[i] = try cloneDependency(dep, self.allocator);\n        }\n\n        return deps;\n    }\n\n    /// Get dependents of an issue (what depends on it).\n    pub fn getDependents(self: *Self, issue_id: []const u8) ![]Dependency {\n        var deps: std.ArrayListUnmanaged(Dependency) = .{};\n        errdefer {\n            for (deps.items) |*dep| {\n                freeDependency(dep, self.allocator);\n            }\n            deps.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            for (issue.dependencies) |dep| {\n                if (std.mem.eql(u8, dep.depends_on_id, issue_id)) {\n                    const cloned = try cloneDependency(dep, self.allocator);\n                    try deps.append(self.allocator, cloned);\n                }\n            }\n        }\n\n        return deps.toOwnedSlice(self.allocator);\n    }\n\n    /// Check if adding a dependency would create a cycle.\n    /// Uses DFS from depends_on_id to see if it can reach issue_id.\n    pub fn wouldCreateCycle(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !bool {\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer {\n            var key_it = visited.keyIterator();\n            while (key_it.next()) |key| {\n                self.allocator.free(key.*);\n            }\n            visited.deinit(self.allocator);\n        }\n\n        return try self.dfsReachable(depends_on_id, issue_id, &visited);\n    }\n\n    fn dfsReachable(self: *Self, from: []const u8, target: []const u8, visited: *std.StringHashMapUnmanaged(void)) !bool {\n        if (std.mem.eql(u8, from, target)) return true;\n        if (visited.contains(from)) return false;\n\n        const from_copy = try self.allocator.dupe(u8, from);\n        errdefer self.allocator.free(from_copy);\n        try visited.put(self.allocator, from_copy, {});\n\n        const issue = self.store.getRef(from) orelse return false;\n\n        for (issue.dependencies) |dep| {\n            if (try self.dfsReachable(dep.depends_on_id, target, visited)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// Detect all cycles in the dependency graph.\n    /// Returns array of cycle paths, or null if no cycles.\n    pub fn detectCycles(self: *Self) !?[][]const u8 {\n        var all_issues: std.StringHashMapUnmanaged(void) = .{};\n        defer {\n            var it = all_issues.keyIterator();\n            while (it.next()) |key| {\n                self.allocator.free(key.*);\n            }\n            all_issues.deinit(self.allocator);\n        }\n\n        // Collect all issue IDs involved in dependencies\n        for (self.store.getAllRef()) |issue| {\n            if (issue.dependencies.len > 0) {\n                if (!all_issues.contains(issue.id)) {\n                    const id_copy = try self.allocator.dupe(u8, issue.id);\n                    try all_issues.put(self.allocator, id_copy, {});\n                }\n                for (issue.dependencies) |dep| {\n                    if (!all_issues.contains(dep.depends_on_id)) {\n                        const id_copy = try self.allocator.dupe(u8, dep.depends_on_id);\n                        try all_issues.put(self.allocator, id_copy, {});\n                    }\n                }\n            }\n        }\n\n        var cycles: std.ArrayListUnmanaged([]const u8) = .{};\n        errdefer {\n            for (cycles.items) |c| {\n                self.allocator.free(c);\n            }\n            cycles.deinit(self.allocator);\n        }\n\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer visited.deinit(self.allocator);\n\n        var rec_stack: std.StringHashMapUnmanaged(void) = .{};\n        defer rec_stack.deinit(self.allocator);\n\n        var it = all_issues.keyIterator();\n        while (it.next()) |key| {\n            if (!visited.contains(key.*)) {\n                var path: std.ArrayListUnmanaged([]const u8) = .{};\n                defer path.deinit(self.allocator);\n\n                if (try self.detectCycleDfs(key.*, &visited, &rec_stack, &path)) {\n                    const cycle_str = try std.mem.join(self.allocator, \" -> \", path.items);\n                    try cycles.append(self.allocator, cycle_str);\n                }\n            }\n        }\n\n        if (cycles.items.len == 0) {\n            return null;\n        }\n\n        return try cycles.toOwnedSlice(self.allocator);\n    }\n\n    fn detectCycleDfs(\n        self: *Self,\n        node: []const u8,\n        visited: *std.StringHashMapUnmanaged(void),\n        rec_stack: *std.StringHashMapUnmanaged(void),\n        path: *std.ArrayListUnmanaged([]const u8),\n    ) !bool {\n        try visited.put(self.allocator, node, {});\n        try rec_stack.put(self.allocator, node, {});\n        try path.append(self.allocator, node);\n\n        const issue = self.store.getRef(node) orelse {\n            _ = path.pop();\n            _ = rec_stack.remove(node);\n            return false;\n        };\n\n        for (issue.dependencies) |dep| {\n            if (!visited.contains(dep.depends_on_id)) {\n                if (try self.detectCycleDfs(dep.depends_on_id, visited, rec_stack, path)) {\n                    return true;\n                }\n            } else if (rec_stack.contains(dep.depends_on_id)) {\n                try path.append(self.allocator, dep.depends_on_id);\n                return true;\n            }\n        }\n\n        _ = rec_stack.remove(node);\n        _ = path.pop();\n        return false;\n    }\n\n    /// Get all issues that are ready (open, not blocked by open issues, optionally not deferred).\n    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n        const now = std.time.timestamp();\n\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open (or deferred if include_deferred is set)\n            if (statusEql(issue.status, .deferred)) {\n                if (!include_deferred) continue;\n            } else if (!statusEql(issue.status, .open)) {\n                continue;\n            }\n\n            // Must not be deferred to future (unless including deferred)\n            if (!include_deferred) {\n                if (issue.defer_until.value) |defer_time| {\n                    if (defer_time > now) continue;\n                }\n            }\n\n            // Must not have any open blockers\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get all blocked issues (open issues with unresolved dependencies).\n    pub fn getBlockedIssues(self: *Self) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open\n            if (!statusEql(issue.status, .open)) continue;\n\n            // Must have at least one open blocker\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (!has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get blockers for an issue (open issues that this issue depends on).\n    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        const issue = self.store.getRef(issue_id) orelse return results.toOwnedSlice(self.allocator);\n\n        for (issue.dependencies) |dep| {\n            if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                if (!statusEql(blocker.status, .closed) and\n                    !statusEql(blocker.status, .tombstone))\n                {\n                    try results.append(self.allocator, try blocker.clone(self.allocator));\n                }\n            }\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Free an array of dependencies.\n    pub fn freeDependencies(self: *Self, deps: []Dependency) void {\n        for (deps) |*dep| {\n            freeDependency(dep, self.allocator);\n        }\n        self.allocator.free(deps);\n    }\n\n    /// Free an array of issues.\n    pub fn freeIssues(self: *Self, issues: []Issue) void {\n        for (issues) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        self.allocator.free(issues);\n    }\n\n    /// Free an array of cycle strings.\n    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n        for (cycles) |c| {\n            self.allocator.free(c);\n        }\n        self.allocator.free(cycles);\n    }\n};\n\n// Helper functions\nfn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n    var result: Dependency = undefined;\n\n    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n    errdefer allocator.free(result.issue_id);\n\n    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n    errdefer allocator.free(result.depends_on_id);\n\n    result.dep_type = switch (dep.dep_type) {\n        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n        else => dep.dep_type,\n    };\n\n    result.created_at = dep.created_at;\n    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n\n    return result;\n}\n\nfn freeDependency(dep: *Dependency, allocator: std.mem.Allocator) void {\n    allocator.free(dep.issue_id);\n    allocator.free(dep.depends_on_id);\n    switch (dep.dep_type) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n    if (dep.created_by) |c| allocator.free(c);\n    if (dep.metadata) |m| allocator.free(m);\n    if (dep.thread_id) |t| allocator.free(t);\n}\n\n// --- Tests ---\n\ntest \"DependencyGraph rejects self-dependency\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-self\", \"Self\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    const dep = Dependency{\n        .issue_id = \"bd-self\",\n        .depends_on_id = \"bd-self\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expectError(DependencyGraphError.SelfDependency, graph.addDependency(dep));\n}\n\ntest \"DependencyGraph rejects direct cycle\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    // A depends on B\n    try graph.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-b\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // B depends on A would create a cycle\n    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n        .issue_id = \"bd-b\",\n        .depends_on_id = \"bd-a\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    }));\n}\n\ntest \"DependencyGraph rejects indirect cycle\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n    try store.insert(Issue.init(\"bd-c\", \"C\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    // A depends on B\n    try graph.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-b\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // B depends on C\n    try graph.addDependency(.{\n        .issue_id = \"bd-b\",\n        .depends_on_id = \"bd-c\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // C depends on A would create a cycle\n    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n        .issue_id = \"bd-c\",\n        .depends_on_id = \"bd-a\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    }));\n}\n\ntest \"DependencyGraph getReadyIssues excludes blocked\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-blocked\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try graph.getReadyIssues();\n    defer graph.freeIssues(ready);\n\n    try std.testing.expectEqual(@as(usize, 2), ready.len);\n\n    // Verify blocked is not in the list\n    for (ready) |issue| {\n        try std.testing.expect(!std.mem.eql(u8, issue.id, \"bd-blocked\"));\n    }\n}\n\ntest \"DependencyGraph getReadyIssues includes when blocker closed\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    var blocker = Issue.init(\"bd-blocker\", \"Blocker\", 1706540000);\n    blocker.status = .closed;\n    try store.insert(blocker);\n    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-child\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try graph.getReadyIssues();\n    defer graph.freeIssues(ready);\n\n    try std.testing.expectEqual(@as(usize, 1), ready.len);\n    try std.testing.expectEqualStrings(\"bd-child\", ready[0].id);\n}\n\ntest \"DependencyGraph getBlockedIssues returns only blocked\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-blocked\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const blocked = try graph.getBlockedIssues();\n    defer graph.freeIssues(blocked);\n\n    try std.testing.expectEqual(@as(usize, 1), blocked.len);\n    try std.testing.expectEqualStrings(\"bd-blocked\", blocked[0].id);\n}\n","structuredPatch":[{"oldStart":595,"oldLines":7,"newStart":595,"newLines":7,"lines":["         .thread_id = null,","     });"," ","-    const ready = try graph.getReadyIssues();","+    const ready = try graph.getReadyIssues(false);","     defer graph.freeIssues(ready);"," ","     try std.testing.expectEqual(@as(usize, 2), ready.len);"]},{"oldStart":628,"oldLines":7,"newStart":628,"newLines":7,"lines":["         .thread_id = null,","     });"," ","-    const ready = try graph.getReadyIssues();","+    const ready = try graph.getReadyIssues(false);","     defer graph.freeIssues(ready);"," ","     try std.testing.expectEqual(@as(usize, 1), ready.len);"]}],"userModified":false,"replaceAll":true}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EyoFoyQMnCca9r52y9jMzV","type":"message","role":"assistant","content":[{"type":"text","text":"Now run the tests again."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":667,"cache_read_input_tokens":69703,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":667},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"75738dbe-092b-4d48-af64-0a7de1efe938"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EyoFoyQMnCca9r52y9jMzV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016WGt5iSsjtfPuMtn6eRyDA","name":"Bash","input":{"command":"zig build test 2>&1 | tail -30","description":"Run the test suite again","timeout":300000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":667,"cache_read_input_tokens":69703,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":667},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"21cc8d2d-4b9f-4b39-8f14-e424aa9ddfbe"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016WGt5iSsjtfPuMtn6eRyDA","type":"tool_result","content":"640/661 tests.cli_test.test.bz create returns ID...OK\n641/661 tests.cli_test.test.bz q returns ID...OK\n642/661 tests.cli_test.test.bz list returns issues...OK\n643/661 tests.cli_test.test.bz list --json returns output...OK\n644/661 tests.cli_test.test.bz show displays issue...OK\n645/661 tests.cli_test.test.bz show not-found returns error...OK\n646/661 tests.cli_test.test.bz close marks issue as closed...OK\n647/661 tests.cli_test.test.bz reopen reopens closed issue...OK\n648/661 tests.cli_test.test.bz delete soft deletes issue...OK\n649/661 tests.cli_test.test.bz search finds matching issues...OK\n650/661 tests.cli_test.test.bz dep add creates dependency...OK\n651/661 tests.cli_test.test.bz dep add rejects cycles...OK\n652/661 tests.cli_test.test.bz ready shows unblocked issues...OK\n653/661 tests.cli_test.test.bz blocked shows blocked issues...OK\n654/661 tests.cli_test.test.bz unknown command returns error...OK\n655/661 tests.cli_test.test.bz without workspace shows error...OK\n656/661 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n657/661 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n658/661 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 74 issues created\nOK\n659/661 tests.stress_test.test.sequential writes: single thread baseline...OK\n660/661 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n661/661 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 661 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"bdc13799-e1f0-4b43-86e0-51c2735f6e00","tool_use_result":{"stdout":"640/661 tests.cli_test.test.bz create returns ID...OK\n641/661 tests.cli_test.test.bz q returns ID...OK\n642/661 tests.cli_test.test.bz list returns issues...OK\n643/661 tests.cli_test.test.bz list --json returns output...OK\n644/661 tests.cli_test.test.bz show displays issue...OK\n645/661 tests.cli_test.test.bz show not-found returns error...OK\n646/661 tests.cli_test.test.bz close marks issue as closed...OK\n647/661 tests.cli_test.test.bz reopen reopens closed issue...OK\n648/661 tests.cli_test.test.bz delete soft deletes issue...OK\n649/661 tests.cli_test.test.bz search finds matching issues...OK\n650/661 tests.cli_test.test.bz dep add creates dependency...OK\n651/661 tests.cli_test.test.bz dep add rejects cycles...OK\n652/661 tests.cli_test.test.bz ready shows unblocked issues...OK\n653/661 tests.cli_test.test.bz blocked shows blocked issues...OK\n654/661 tests.cli_test.test.bz unknown command returns error...OK\n655/661 tests.cli_test.test.bz without workspace shows error...OK\n656/661 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n657/661 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n658/661 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 74 issues created\nOK\n659/661 tests.stress_test.test.sequential writes: single thread baseline...OK\n660/661 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n661/661 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 661 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017dWvjYJekxgdrnua3zKNE3","type":"message","role":"assistant","content":[{"type":"text","text":"All 661 tests pass. Now let me do a quick manual test in the sandbox to verify the functionality works as expected."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":663,"cache_read_input_tokens":70370,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":663},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"662c6670-c9b0-4b1e-9ade-123255755f13"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017dWvjYJekxgdrnua3zKNE3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DtraseUkC3TF43Mb6BLXvh","name":"Bash","input":{"command":"mkdir -p /home/hotschmoe/beads_zig/sandbox && cd /home/hotschmoe/beads_zig/sandbox && rm -rf .beads && ../zig-out/bin/bz init","description":"Initialize sandbox for manual testing"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":663,"cache_read_input_tokens":70370,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":663},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"847706bf-3857-43fa-95b2-132246c29a97"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DtraseUkC3TF43Mb6BLXvh","type":"tool_result","content":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f49e6c3f-c326-4c22-a44c-8adf9ca8c975","tool_use_result":{"stdout":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013eLNWsMxKjiUrnJPmdV22c","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DwstQqiQ8Kogjmo9Bow3rK","name":"Bash","input":{"command":"../zig-out/bin/bz create \"Test overdue issue\" --due \"2020-01-01T00:00:00Z\" && ../zig-out/bin/bz create \"Test future issue\" --due \"2030-01-01T00:00:00Z\" && ../zig-out/bin/bz create \"No due date issue\"","description":"Create test issues with different due dates"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":194,"cache_read_input_tokens":71033,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":194},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"af76539b-4c0f-4413-9639-986a6b18b700"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DwstQqiQ8Kogjmo9Bow3rK","type":"tool_result","content":"Created issue bd-uhc\nCreated issue bd-r9g\nCreated issue bd-3ks","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"74c0617a-5604-40e4-9943-c52c9352425d","tool_use_result":{"stdout":"Created issue bd-uhc\nCreated issue bd-r9g\nCreated issue bd-3ks","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0196vmyVemQxiqHe66ddaJCL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Yak4qfNQfpsKrsBnir5C7T","name":"Bash","input":{"command":"echo \"=== All issues ===\" && ../zig-out/bin/bz list && echo \"\" && echo \"=== Overdue issues only ===\" && ../zig-out/bin/bz list --overdue","description":"Test the --overdue filter"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":194,"cache_read_input_tokens":71227,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":194},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"b41b0edf-b729-4a05-96d8-7597b73366ad"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Yak4qfNQfpsKrsBnir5C7T","type":"tool_result","content":"=== All issues ===\nbd-uhc  [OPEN] Test overdue issue\nbd-r9g  [OPEN] Test future issue\nbd-3ks  [OPEN] No due date issue\n\n=== Overdue issues only ===\nbd-uhc  [OPEN] Test overdue issue","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"893dde33-2b7d-4e47-84de-1461ce327981","tool_use_result":{"stdout":"=== All issues ===\nbd-uhc  [OPEN] Test overdue issue\nbd-r9g  [OPEN] Test future issue\nbd-3ks  [OPEN] No due date issue\n\n=== Overdue issues only ===\nbd-uhc  [OPEN] Test overdue issue","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015GaCa2nEGfBEV4KTph81Ld","type":"message","role":"assistant","content":[{"type":"text","text":"The --overdue filter works correctly. Now let me test the --deferred flag."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":207,"cache_read_input_tokens":71421,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":207},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"462f3908-58df-4afd-b9bf-22c77a4e95b9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015GaCa2nEGfBEV4KTph81Ld","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014cHffnWSB4GPhK6qfCoGoP","name":"Bash","input":{"command":"../zig-out/bin/bz defer bd-r9g --until \"+30d\" && echo \"\" && echo \"=== List (default - excludes deferred) ===\" && ../zig-out/bin/bz list && echo \"\" && echo \"=== List with --deferred ===\" && ../zig-out/bin/bz list --deferred","description":"Test the --deferred filter"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":207,"cache_read_input_tokens":71421,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":207},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"41c8eb1a-8293-4dc2-bcb3-17077af49c6d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014cHffnWSB4GPhK6qfCoGoP","type":"tool_result","content":"Deferred issue bd-r9g until 2026-03-04T08:21:19Z\n\n=== List (default - excludes deferred) ===\nbd-uhc  [OPEN] Test overdue issue\nbd-3ks  [OPEN] No due date issue\n\n=== List with --deferred ===\nbd-uhc  [OPEN] Test overdue issue\nbd-3ks  [OPEN] No due date issue","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"72df4e18-8465-4f57-a4e9-b1635a9d9288","tool_use_result":{"stdout":"Deferred issue bd-r9g until 2026-03-04T08:21:19Z\n\n=== List (default - excludes deferred) ===\nbd-uhc  [OPEN] Test overdue issue\nbd-3ks  [OPEN] No due date issue\n\n=== List with --deferred ===\nbd-uhc  [OPEN] Test overdue issue\nbd-3ks  [OPEN] No due date issue","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013sRVo49msum74fEY87KNhF","type":"message","role":"assistant","content":[{"type":"text","text":"Hmm, the --deferred doesn't seem to be working correctly. The issue is that deferred issues have status \"deferred\", but I'm only checking when the status filter is not set. Let me trace through the logic.\n\nLooking at the filtering:\n1. Line 58 sets `filters.status = .open;` by default when not `--all` and no `--status` specified\n2. This means deferred issues are filtered out by status before the `include_deferred` check\n\nThe issue is that the status filter is applied first and excludes deferred issues. The fix should allow deferred issues through when `include_deferred` is set even if status is `.open`. Let me re-think this."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":293,"cache_read_input_tokens":71628,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":293},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"3c656c14-122f-4e08-a5fb-c7f7d33b6354"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013sRVo49msum74fEY87KNhF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014MKP4ziEcgCM4hXvDa1xtv","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","offset":365,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":293,"cache_read_input_tokens":71628,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":293},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"288e0b15-b44d-4123-817e-34c2a4223bbf"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014MKP4ziEcgCM4hXvDa1xtv","type":"tool_result","content":"   365→            results.deinit(self.allocator);\n   366→        }\n   367→\n   368→        for (self.issues.items) |issue| {\n   369→            // Filter tombstones\n   370→            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n   371→                continue;\n   372→            }\n   373→\n   374→            // Apply filters\n   375→            if (filters.status) |s| {\n   376→                if (!statusEql(issue.status, s)) continue;\n   377→            }\n   378→            if (filters.priority) |p| {\n   379→                if (issue.priority.value != p.value) continue;\n   380→            }\n   381→            if (filters.issue_type) |t| {\n   382→                if (!issueTypeEql(issue.issue_type, t)) continue;\n   383→            }\n   384→            if (filters.assignee) |a| {\n   385→                if (issue.assignee == null) continue;\n   386→                if (!std.mem.eql(u8, issue.assignee.?, a)) continue;\n   387→            }\n   388→            if (filters.label) |lbl| {\n   389→                var found = false;\n   390→                for (issue.labels) |label| {\n   391→                    if (std.mem.eql(u8, label, lbl)) {\n   392→                        found = true;\n   393→                        break;\n   394→                    }\n   395→                }\n   396→                if (!found) continue;\n   397→            }\n   398→\n   399→            // label_any: OR logic - issue must have at least ONE of the specified labels\n   400→            if (filters.label_any.len > 0) {\n   401→                var found_any = false;\n   402→                for (filters.label_any) |any_label| {\n   403→                    for (issue.labels) |issue_label| {\n   404→                        if (std.mem.eql(u8, issue_label, any_label)) {\n   405→                            found_any = true;\n   406→                            break;\n   407→                        }\n   408→                    }\n   409→                    if (found_any) break;\n   410→                }\n   411→                if (!found_any) continue;\n   412→            }\n   413→\n   414→            // Priority range filters (lower value = higher priority)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"fe96aa29-5a24-49dd-8599-bf498118fb90","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/storage/store.zig","content":"            results.deinit(self.allocator);\n        }\n\n        for (self.issues.items) |issue| {\n            // Filter tombstones\n            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n                continue;\n            }\n\n            // Apply filters\n            if (filters.status) |s| {\n                if (!statusEql(issue.status, s)) continue;\n            }\n            if (filters.priority) |p| {\n                if (issue.priority.value != p.value) continue;\n            }\n            if (filters.issue_type) |t| {\n                if (!issueTypeEql(issue.issue_type, t)) continue;\n            }\n            if (filters.assignee) |a| {\n                if (issue.assignee == null) continue;\n                if (!std.mem.eql(u8, issue.assignee.?, a)) continue;\n            }\n            if (filters.label) |lbl| {\n                var found = false;\n                for (issue.labels) |label| {\n                    if (std.mem.eql(u8, label, lbl)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) continue;\n            }\n\n            // label_any: OR logic - issue must have at least ONE of the specified labels\n            if (filters.label_any.len > 0) {\n                var found_any = false;\n                for (filters.label_any) |any_label| {\n                    for (issue.labels) |issue_label| {\n                        if (std.mem.eql(u8, issue_label, any_label)) {\n                            found_any = true;\n                            break;\n                        }\n                    }\n                    if (found_any) break;\n                }\n                if (!found_any) continue;\n            }\n\n            // Priority range filters (lower value = higher priority)","numLines":50,"startLine":365,"totalLines":1271}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WAAfgUASV1f2TZCX6Y6VBU","type":"message","role":"assistant","content":[{"type":"text","text":"I see the issue. The status filter is checked early and rejects deferred issues when status filter is set to `.open`. The fix should modify the status filtering to also allow deferred issues when `include_deferred` is true."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1154,"cache_read_input_tokens":71921,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1154},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f4e4cd0d-8067-4c23-a1b2-2efd99c40332"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WAAfgUASV1f2TZCX6Y6VBU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QEyADMqqYiCPba93bstjPU","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","old_string":"            // Apply filters\n            if (filters.status) |s| {\n                if (!statusEql(issue.status, s)) continue;\n            }","new_string":"            // Apply filters\n            if (filters.status) |s| {\n                // When include_deferred is set, allow deferred issues through even when filtering for open\n                if (!statusEql(issue.status, s)) {\n                    if (filters.include_deferred and statusEql(issue.status, .deferred)) {\n                        // Allow deferred issues through\n                    } else {\n                        continue;\n                    }\n                }\n            }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1154,"cache_read_input_tokens":71921,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1154},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"1e803c57-3744-4836-93a7-6a750a368e4e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QEyADMqqYiCPba93bstjPU","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/storage/store.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"53126380-0666-4d50-89d1-a997a93676ff","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/storage/store.zig","oldString":"            // Apply filters\n            if (filters.status) |s| {\n                if (!statusEql(issue.status, s)) continue;\n            }","newString":"            // Apply filters\n            if (filters.status) |s| {\n                // When include_deferred is set, allow deferred issues through even when filtering for open\n                if (!statusEql(issue.status, s)) {\n                    if (filters.include_deferred and statusEql(issue.status, .deferred)) {\n                        // Allow deferred issues through\n                    } else {\n                        continue;\n                    }\n                }\n            }","originalFile":"//! In-memory issue store for beads_zig.\n//!\n//! Provides CRUD operations for issues using in-memory storage with:\n//! - Arena allocator for issue memory management\n//! - ArrayList + StringHashMap for fast ID lookup\n//! - Dirty tracking for sync operations\n//! - JSONL persistence via JsonlFile\n\nconst std = @import(\"std\");\nconst JsonlFile = @import(\"jsonl.zig\").JsonlFile;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Rfc3339Timestamp = @import(\"../models/issue.zig\").Rfc3339Timestamp;\nconst OptionalRfc3339Timestamp = @import(\"../models/issue.zig\").OptionalRfc3339Timestamp;\nconst Status = @import(\"../models/status.zig\").Status;\nconst Priority = @import(\"../models/priority.zig\").Priority;\nconst IssueType = @import(\"../models/issue_type.zig\").IssueType;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Comment = @import(\"../models/comment.zig\").Comment;\n\npub const IssueStoreError = error{\n    IssueNotFound,\n    DuplicateId,\n    InvalidIssue,\n    VersionMismatch,\n};\n\n/// Result of loading the store with corruption tracking.\npub const StoreLoadResult = struct {\n    /// Number of corrupt JSONL entries skipped.\n    jsonl_corruption_count: usize = 0,\n    /// Line numbers of corrupt JSONL entries (1-indexed).\n    jsonl_corrupt_lines: []const usize = &.{},\n\n    pub fn hasCorruption(self: StoreLoadResult) bool {\n        return self.jsonl_corruption_count > 0;\n    }\n\n    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n        if (self.jsonl_corrupt_lines.len > 0) {\n            allocator.free(self.jsonl_corrupt_lines);\n        }\n    }\n};\n\npub const IssueStore = struct {\n    allocator: std.mem.Allocator,\n    issues: std.ArrayListUnmanaged(Issue),\n    id_index: std.StringHashMapUnmanaged(usize),\n    dirty_ids: std.StringHashMapUnmanaged(i64),\n    dirty: bool,\n    jsonl_path: []const u8,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, jsonl_path: []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .issues = .{},\n            .id_index = .{},\n            .dirty_ids = .{},\n            .dirty = false,\n            .jsonl_path = jsonl_path,\n        };\n    }\n\n    pub fn deinit(self: *Self) void {\n        for (self.issues.items) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        self.issues.deinit(self.allocator);\n\n        var id_it = self.id_index.keyIterator();\n        while (id_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.id_index.deinit(self.allocator);\n\n        var dirty_it = self.dirty_ids.keyIterator();\n        while (dirty_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.dirty_ids.deinit(self.allocator);\n    }\n\n    /// Load issues from the JSONL file into memory.\n    pub fn loadFromFile(self: *Self) !void {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        const loaded_issues = try jsonl.readAll();\n        defer self.allocator.free(loaded_issues);\n\n        for (loaded_issues) |issue| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n\n            const idx = self.issues.items.len;\n            try self.issues.append(self.allocator, issue);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n\n        self.dirty = false;\n    }\n\n    /// Load issues from the JSONL file with graceful corruption recovery.\n    /// Logs and skips corrupt entries instead of failing.\n    /// Returns statistics about the load including corruption count.\n    pub fn loadFromFileWithRecovery(self: *Self) !StoreLoadResult {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        var load_result = try jsonl.readAllWithRecovery();\n        // Take ownership of corrupt_lines before freeing issues slice\n        const corrupt_lines = load_result.corrupt_lines;\n        load_result.corrupt_lines = &.{}; // Prevent double-free\n        errdefer if (corrupt_lines.len > 0) self.allocator.free(corrupt_lines);\n\n        const loaded_issues = load_result.issues;\n        defer self.allocator.free(loaded_issues);\n\n        for (loaded_issues) |issue| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n\n            const idx = self.issues.items.len;\n            try self.issues.append(self.allocator, issue);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n\n        self.dirty = false;\n\n        return StoreLoadResult{\n            .jsonl_corruption_count = load_result.corruption_count,\n            .jsonl_corrupt_lines = corrupt_lines,\n        };\n    }\n\n    /// Save all issues to the JSONL file.\n    pub fn saveToFile(self: *Self) !void {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        try jsonl.writeAll(self.issues.items);\n        self.dirty = false;\n\n        // Clear dirty tracking\n        var dirty_it = self.dirty_ids.keyIterator();\n        while (dirty_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.dirty_ids.clearRetainingCapacity();\n    }\n\n    /// Insert a new issue into the store.\n    pub fn insert(self: *Self, issue: Issue) !void {\n        if (self.id_index.contains(issue.id)) {\n            return IssueStoreError.DuplicateId;\n        }\n\n        const cloned = try issue.clone(self.allocator);\n        errdefer {\n            var c = cloned;\n            c.deinit(self.allocator);\n        }\n\n        const id_copy = try self.allocator.dupe(u8, cloned.id);\n        errdefer self.allocator.free(id_copy);\n\n        const idx = self.issues.items.len;\n        try self.issues.append(self.allocator, cloned);\n        try self.id_index.put(self.allocator, id_copy, idx);\n\n        try self.markDirty(issue.id);\n    }\n\n    /// Get an issue by ID (without embedded relations).\n    pub fn get(self: *Self, id: []const u8) !?Issue {\n        const idx = self.id_index.get(id) orelse return null;\n        if (idx >= self.issues.items.len) return null;\n\n        return try self.issues.items[idx].clone(self.allocator);\n    }\n\n    /// Get an issue with all embedded relations (labels, deps, comments).\n    /// Since we store everything in-memory, this just returns the issue as-is.\n    pub fn getWithRelations(self: *Self, id: []const u8) !?Issue {\n        return try self.get(id);\n    }\n\n    /// Get a reference to the stored issue (no clone).\n    /// Caller must NOT free or modify the returned issue.\n    pub fn getRef(self: *Self, id: []const u8) ?*Issue {\n        const idx = self.id_index.get(id) orelse return null;\n        if (idx >= self.issues.items.len) return null;\n        return &self.issues.items[idx];\n    }\n\n    /// Fields that can be updated on an issue.\n    pub const IssueUpdate = struct {\n        title: ?[]const u8 = null,\n        description: ?[]const u8 = null,\n        design: ?[]const u8 = null,\n        acceptance_criteria: ?[]const u8 = null,\n        notes: ?[]const u8 = null,\n        status: ?Status = null,\n        priority: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        owner: ?[]const u8 = null,\n        estimated_minutes: ?i32 = null,\n        closed_at: ?i64 = null,\n        close_reason: ?[]const u8 = null,\n        closed_by_session: ?[]const u8 = null,\n        due_at: ?i64 = null,\n        defer_until: ?i64 = null,\n        external_ref: ?[]const u8 = null,\n        source_system: ?[]const u8 = null,\n        pinned: ?bool = null,\n        is_template: ?bool = null,\n        content_hash: ?[]const u8 = null,\n\n        /// Expected version for optimistic locking.\n        /// If set, update will fail with VersionMismatch if issue.version != expected_version.\n        expected_version: ?u64 = null,\n    };\n\n    /// Update an issue with the given fields.\n    /// If updates.expected_version is set, performs optimistic locking check.\n    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {\n        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        // Optimistic locking check\n        if (updates.expected_version) |expected| {\n            if (issue.version != expected) {\n                return IssueStoreError.VersionMismatch;\n            }\n        }\n\n        // Increment version on every update\n        issue.version += 1;\n\n        // Update timestamp\n        issue.updated_at = Rfc3339Timestamp{ .value = now };\n\n        // Apply updates\n        if (updates.title) |v| {\n            self.allocator.free(issue.title);\n            issue.title = try self.allocator.dupe(u8, v);\n        }\n        if (updates.description) |v| {\n            if (issue.description) |d| self.allocator.free(d);\n            issue.description = try self.allocator.dupe(u8, v);\n        }\n        if (updates.design) |v| {\n            if (issue.design) |d| self.allocator.free(d);\n            issue.design = try self.allocator.dupe(u8, v);\n        }\n        if (updates.acceptance_criteria) |v| {\n            if (issue.acceptance_criteria) |a| self.allocator.free(a);\n            issue.acceptance_criteria = try self.allocator.dupe(u8, v);\n        }\n        if (updates.notes) |v| {\n            if (issue.notes) |n| self.allocator.free(n);\n            issue.notes = try self.allocator.dupe(u8, v);\n        }\n        if (updates.status) |v| {\n            freeStatus(issue.status, self.allocator);\n            issue.status = try cloneStatus(v, self.allocator);\n        }\n        if (updates.priority) |v| {\n            issue.priority = v;\n        }\n        if (updates.issue_type) |v| {\n            freeIssueType(issue.issue_type, self.allocator);\n            issue.issue_type = try cloneIssueType(v, self.allocator);\n        }\n        if (updates.assignee) |v| {\n            if (issue.assignee) |a| self.allocator.free(a);\n            issue.assignee = try self.allocator.dupe(u8, v);\n        }\n        if (updates.owner) |v| {\n            if (issue.owner) |o| self.allocator.free(o);\n            issue.owner = try self.allocator.dupe(u8, v);\n        }\n        if (updates.estimated_minutes) |v| {\n            issue.estimated_minutes = v;\n        }\n        if (updates.closed_at) |v| {\n            issue.closed_at = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.close_reason) |v| {\n            if (issue.close_reason) |r| self.allocator.free(r);\n            issue.close_reason = try self.allocator.dupe(u8, v);\n        }\n        if (updates.closed_by_session) |v| {\n            if (issue.closed_by_session) |s| self.allocator.free(s);\n            issue.closed_by_session = try self.allocator.dupe(u8, v);\n        }\n        if (updates.due_at) |v| {\n            issue.due_at = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.defer_until) |v| {\n            issue.defer_until = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.external_ref) |v| {\n            if (issue.external_ref) |e| self.allocator.free(e);\n            issue.external_ref = try self.allocator.dupe(u8, v);\n        }\n        if (updates.source_system) |v| {\n            if (issue.source_system) |s| self.allocator.free(s);\n            issue.source_system = try self.allocator.dupe(u8, v);\n        }\n        if (updates.pinned) |v| {\n            issue.pinned = v;\n        }\n        if (updates.is_template) |v| {\n            issue.is_template = v;\n        }\n        if (updates.content_hash) |v| {\n            if (issue.content_hash) |h| self.allocator.free(h);\n            issue.content_hash = try self.allocator.dupe(u8, v);\n        }\n\n        try self.markDirty(id);\n    }\n\n    /// Soft delete an issue by setting its status to tombstone.\n    pub fn delete(self: *Self, id: []const u8, now: i64) !void {\n        try self.update(id, .{ .status = .tombstone }, now);\n    }\n\n    /// Filters for listing issues.\n    pub const ListFilters = struct {\n        status: ?Status = null,\n        priority: ?Priority = null,\n        priority_min: ?Priority = null,\n        priority_max: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        label_any: []const []const u8 = &[_][]const u8{},\n        title_contains: ?[]const u8 = null,\n        desc_contains: ?[]const u8 = null,\n        notes_contains: ?[]const u8 = null,\n        include_tombstones: bool = false,\n        overdue: bool = false,\n        include_deferred: bool = false,\n        limit: ?u32 = null,\n        offset: ?u32 = null,\n        order_by: OrderBy = .created_at,\n        order_desc: bool = true,\n\n        pub const OrderBy = enum {\n            created_at,\n            updated_at,\n            priority,\n        };\n    };\n\n    /// List issues with optional filters.\n    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.issues.items) |issue| {\n            // Filter tombstones\n            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n                continue;\n            }\n\n            // Apply filters\n            if (filters.status) |s| {\n                if (!statusEql(issue.status, s)) continue;\n            }\n            if (filters.priority) |p| {\n                if (issue.priority.value != p.value) continue;\n            }\n            if (filters.issue_type) |t| {\n                if (!issueTypeEql(issue.issue_type, t)) continue;\n            }\n            if (filters.assignee) |a| {\n                if (issue.assignee == null) continue;\n                if (!std.mem.eql(u8, issue.assignee.?, a)) continue;\n            }\n            if (filters.label) |lbl| {\n                var found = false;\n                for (issue.labels) |label| {\n                    if (std.mem.eql(u8, label, lbl)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) continue;\n            }\n\n            // label_any: OR logic - issue must have at least ONE of the specified labels\n            if (filters.label_any.len > 0) {\n                var found_any = false;\n                for (filters.label_any) |any_label| {\n                    for (issue.labels) |issue_label| {\n                        if (std.mem.eql(u8, issue_label, any_label)) {\n                            found_any = true;\n                            break;\n                        }\n                    }\n                    if (found_any) break;\n                }\n                if (!found_any) continue;\n            }\n\n            // Priority range filters (lower value = higher priority)\n            if (filters.priority_min) |min_p| {\n                if (issue.priority.value < min_p.value) continue;\n            }\n            if (filters.priority_max) |max_p| {\n                if (issue.priority.value > max_p.value) continue;\n            }\n\n            // Substring filters (case-insensitive)\n            if (filters.title_contains) |query| {\n                if (!containsIgnoreCase(issue.title, query)) continue;\n            }\n            if (filters.desc_contains) |query| {\n                if (issue.description) |desc| {\n                    if (!containsIgnoreCase(desc, query)) continue;\n                } else continue;\n            }\n            if (filters.notes_contains) |query| {\n                if (issue.notes) |notes| {\n                    if (!containsIgnoreCase(notes, query)) continue;\n                } else continue;\n            }\n\n            // Overdue filter: only include issues past their due date\n            if (filters.overdue) {\n                const now = std.time.timestamp();\n                if (issue.due_at.value) |due_time| {\n                    if (due_time >= now) continue;\n                } else continue;\n            }\n\n            // Deferred filter: skip deferred issues unless explicitly included\n            if (!filters.include_deferred and statusEql(issue.status, .deferred)) {\n                continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort\n        const SortContext = struct {\n            order_by: ListFilters.OrderBy,\n            order_desc: bool,\n        };\n        const ctx = SortContext{ .order_by = filters.order_by, .order_desc = filters.order_desc };\n\n        std.mem.sortUnstable(Issue, results.items, ctx, struct {\n            fn lessThan(c: SortContext, a: Issue, b: Issue) bool {\n                const cmp: i64 = switch (c.order_by) {\n                    .created_at => a.created_at.value - b.created_at.value,\n                    .updated_at => a.updated_at.value - b.updated_at.value,\n                    .priority => @as(i64, a.priority.value) - @as(i64, b.priority.value),\n                };\n                return if (c.order_desc) cmp > 0 else cmp < 0;\n            }\n        }.lessThan);\n\n        // Apply offset and limit\n        var start: usize = 0;\n        if (filters.offset) |off| {\n            start = @min(off, results.items.len);\n        }\n\n        var end: usize = results.items.len;\n        if (filters.limit) |lim| {\n            end = @min(start + lim, results.items.len);\n        }\n\n        // Free items outside the range\n        for (results.items[0..start]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        for (results.items[end..]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n\n        // Return slice\n        const slice = try self.allocator.dupe(Issue, results.items[start..end]);\n        results.deinit(self.allocator);\n        return slice;\n    }\n\n    /// Result from counting issues.\n    pub const CountResult = struct {\n        key: []const u8,\n        count: u64,\n    };\n\n    /// Count issues, optionally grouped by a field.\n    pub fn count(self: *Self, group_by: ?GroupBy) ![]CountResult {\n        var counts: std.StringHashMapUnmanaged(u64) = .{};\n        defer counts.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const key_str: []const u8 = if (group_by) |g| switch (g) {\n                .status => issue.status.toString(),\n                .priority => switch (issue.priority.value) {\n                    0 => \"0\",\n                    1 => \"1\",\n                    2 => \"2\",\n                    3 => \"3\",\n                    4 => \"4\",\n                    else => unreachable,\n                },\n                .issue_type => issue.issue_type.toString(),\n                .assignee => issue.assignee orelse \"(unassigned)\",\n            } else \"total\";\n\n            const entry = counts.getOrPutValue(self.allocator, key_str, 0) catch continue;\n            entry.value_ptr.* += 1;\n        }\n\n        var results: std.ArrayListUnmanaged(CountResult) = .{};\n        errdefer {\n            for (results.items) |r| {\n                self.allocator.free(r.key);\n            }\n            results.deinit(self.allocator);\n        }\n\n        var it = counts.iterator();\n        while (it.next()) |entry| {\n            const key = try self.allocator.dupe(u8, entry.key_ptr.*);\n            try results.append(self.allocator, .{ .key = key, .count = entry.value_ptr.* });\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    pub const GroupBy = enum {\n        status,\n        priority,\n        issue_type,\n        assignee,\n    };\n\n    /// Check if an issue exists.\n    pub fn exists(self: *Self, id: []const u8) !bool {\n        return self.id_index.contains(id);\n    }\n\n    /// Get labels for an issue.\n    pub fn getLabels(self: *Self, issue_id: []const u8) ![]const []const u8 {\n        const idx = self.id_index.get(issue_id) orelse return &[_][]const u8{};\n        if (idx >= self.issues.items.len) return &[_][]const u8{};\n\n        const issue = self.issues.items[idx];\n        if (issue.labels.len == 0) return &[_][]const u8{};\n\n        const labels = try self.allocator.alloc([]const u8, issue.labels.len);\n        errdefer self.allocator.free(labels);\n\n        for (issue.labels, 0..) |label, i| {\n            labels[i] = try self.allocator.dupe(u8, label);\n        }\n        return labels;\n    }\n\n    /// Add a label to an issue.\n    pub fn addLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        // Check if already exists\n        for (issue.labels) |existing| {\n            if (std.mem.eql(u8, existing, label)) return;\n        }\n\n        // Add new label\n        const label_copy = try self.allocator.dupe(u8, label);\n        errdefer self.allocator.free(label_copy);\n\n        const new_labels = try self.allocator.alloc([]const u8, issue.labels.len + 1);\n        @memcpy(new_labels[0..issue.labels.len], issue.labels);\n        new_labels[issue.labels.len] = label_copy;\n\n        if (issue.labels.len > 0) {\n            self.allocator.free(issue.labels);\n        }\n        issue.labels = new_labels;\n\n        try self.markDirty(issue_id);\n    }\n\n    /// Remove a label from an issue.\n    pub fn removeLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        var found_idx: ?usize = null;\n        for (issue.labels, 0..) |existing, i| {\n            if (std.mem.eql(u8, existing, label)) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx) |fi| {\n            self.allocator.free(issue.labels[fi]);\n\n            if (issue.labels.len == 1) {\n                self.allocator.free(issue.labels);\n                issue.labels = &[_][]const u8{};\n            } else {\n                const new_labels = try self.allocator.alloc([]const u8, issue.labels.len - 1);\n                var j: usize = 0;\n                for (issue.labels, 0..) |lbl, i| {\n                    if (i != fi) {\n                        new_labels[j] = lbl;\n                        j += 1;\n                    }\n                }\n                self.allocator.free(issue.labels);\n                issue.labels = new_labels;\n            }\n\n            try self.markDirty(issue_id);\n        }\n    }\n\n    /// Get dependencies for an issue.\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]const Dependency {\n        const idx = self.id_index.get(issue_id) orelse return &[_]Dependency{};\n        if (idx >= self.issues.items.len) return &[_]Dependency{};\n\n        const issue = self.issues.items[idx];\n        if (issue.dependencies.len == 0) return &[_]Dependency{};\n\n        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n        errdefer self.allocator.free(deps);\n\n        for (issue.dependencies, 0..) |dep, i| {\n            deps[i] = try cloneDependency(dep, self.allocator);\n        }\n        return deps;\n    }\n\n    /// Get comments for an issue.\n    pub fn getComments(self: *Self, issue_id: []const u8) ![]const Comment {\n        const idx = self.id_index.get(issue_id) orelse return &[_]Comment{};\n        if (idx >= self.issues.items.len) return &[_]Comment{};\n\n        const issue = self.issues.items[idx];\n        if (issue.comments.len == 0) return &[_]Comment{};\n\n        const comments = try self.allocator.alloc(Comment, issue.comments.len);\n        errdefer self.allocator.free(comments);\n\n        for (issue.comments, 0..) |c, i| {\n            comments[i] = try cloneComment(c, self.allocator);\n        }\n        return comments;\n    }\n\n    /// Add a comment to an issue.\n    pub fn addComment(self: *Self, issue_id: []const u8, comment: Comment) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        const cloned = try cloneComment(comment, self.allocator);\n        errdefer freeComment(@constCast(&cloned), self.allocator);\n\n        const new_comments = try self.allocator.alloc(Comment, issue.comments.len + 1);\n        @memcpy(new_comments[0..issue.comments.len], issue.comments);\n        new_comments[issue.comments.len] = cloned;\n\n        if (issue.comments.len > 0) {\n            self.allocator.free(issue.comments);\n        }\n        issue.comments = new_comments;\n\n        try self.markDirty(issue_id);\n    }\n\n    /// Mark an issue as dirty for sync.\n    pub fn markDirty(self: *Self, id: []const u8) !void {\n        self.dirty = true;\n        const now = std.time.timestamp();\n\n        if (!self.dirty_ids.contains(id)) {\n            const id_copy = try self.allocator.dupe(u8, id);\n            try self.dirty_ids.put(self.allocator, id_copy, now);\n        } else {\n            self.dirty_ids.getPtr(id).?.* = now;\n        }\n    }\n\n    /// Clear dirty flag for an issue.\n    pub fn clearDirty(self: *Self, id: []const u8) !void {\n        if (self.dirty_ids.fetchRemove(id)) |kv| {\n            self.allocator.free(kv.key);\n        }\n    }\n\n    /// Get all dirty issue IDs.\n    pub fn getDirtyIds(self: *Self) ![][]const u8 {\n        var ids: std.ArrayListUnmanaged([]const u8) = .{};\n        errdefer {\n            for (ids.items) |id| {\n                self.allocator.free(id);\n            }\n            ids.deinit(self.allocator);\n        }\n\n        var it = self.dirty_ids.keyIterator();\n        while (it.next()) |key| {\n            const id = try self.allocator.dupe(u8, key.*);\n            try ids.append(self.allocator, id);\n        }\n\n        return ids.toOwnedSlice(self.allocator);\n    }\n\n    /// Check if the store has unsaved changes.\n    pub fn isDirty(self: *Self) bool {\n        return self.dirty;\n    }\n\n    /// Get total number of issues (excluding tombstones).\n    pub fn countTotal(self: *Self) usize {\n        var total: usize = 0;\n        for (self.issues.items) |issue| {\n            if (!statusEql(issue.status, .tombstone)) {\n                total += 1;\n            }\n        }\n        return total;\n    }\n\n    /// Get all issues as a slice (no clone, read-only).\n    pub fn getAllRef(self: *Self) []const Issue {\n        return self.issues.items;\n    }\n\n    /// Suggestion for similar ID lookup.\n    pub const IdSuggestion = struct {\n        id: []const u8,\n        title: []const u8,\n    };\n\n    /// Find similar IDs when a lookup fails (for \"did you mean\" suggestions).\n    /// Uses prefix matching and Levenshtein-like scoring.\n    /// Returns up to `max_count` suggestions, caller must free.\n    pub fn findSimilarIds(self: *Self, target: []const u8, max_count: usize) ![]IdSuggestion {\n        if (self.issues.items.len == 0) return &[_]IdSuggestion{};\n\n        const Scored = struct {\n            id: []const u8,\n            title: []const u8,\n            score: i32,\n        };\n\n        var candidates: std.ArrayListUnmanaged(Scored) = .{};\n        defer candidates.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const score = computeSimilarity(target, issue.id);\n            if (score > 0) {\n                try candidates.append(self.allocator, .{\n                    .id = issue.id,\n                    .title = issue.title,\n                    .score = score,\n                });\n            }\n        }\n\n        if (candidates.items.len == 0) return &[_]IdSuggestion{};\n\n        // Sort by score descending\n        std.mem.sortUnstable(Scored, candidates.items, {}, struct {\n            fn lessThan(_: void, a: Scored, b: Scored) bool {\n                return a.score > b.score;\n            }\n        }.lessThan);\n\n        const result_count = @min(max_count, candidates.items.len);\n        var suggestions = try self.allocator.alloc(IdSuggestion, result_count);\n        errdefer self.allocator.free(suggestions);\n\n        for (0..result_count) |i| {\n            suggestions[i] = .{\n                .id = try self.allocator.dupe(u8, candidates.items[i].id),\n                .title = try self.allocator.dupe(u8, candidates.items[i].title),\n            };\n        }\n\n        return suggestions;\n    }\n\n    /// Free suggestions returned by findSimilarIds.\n    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n        for (suggestions) |s| {\n            self.allocator.free(s.id);\n            self.allocator.free(s.title);\n        }\n        self.allocator.free(suggestions);\n    }\n};\n\n/// Compute similarity score between target and candidate ID.\n/// Higher score = more similar.\nfn computeSimilarity(target: []const u8, candidate: []const u8) i32 {\n    var score: i32 = 0;\n\n    // Exact prefix match (bd-abc matches bd-abc123)\n    if (std.mem.startsWith(u8, candidate, target)) {\n        score += 100;\n    }\n    // Candidate is prefix of target (bd-abc123 starts with bd-abc)\n    else if (std.mem.startsWith(u8, target, candidate)) {\n        score += 80;\n    }\n\n    // Common prefix length\n    var common_prefix: usize = 0;\n    const min_len = @min(target.len, candidate.len);\n    for (0..min_len) |i| {\n        if (target[i] == candidate[i]) {\n            common_prefix += 1;\n        } else {\n            break;\n        }\n    }\n    score += @intCast(common_prefix * 5);\n\n    // Contains target as substring\n    if (std.mem.indexOf(u8, candidate, target) != null) {\n        score += 30;\n    }\n\n    // Similar length bonus\n    const len_diff: i32 = @intCast(@abs(@as(i64, @intCast(target.len)) - @as(i64, @intCast(candidate.len))));\n    if (len_diff <= 2) {\n        score += 10;\n    }\n\n    return score;\n}\n\n// Helper functions\nfn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn issueTypeEql(a: IssueType, b: IssueType) bool {\n    const Tag = std.meta.Tag(IssueType);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\npub fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {\n    if (needle.len == 0) return true;\n    if (needle.len > haystack.len) return false;\n\n    const end = haystack.len - needle.len + 1;\n    var i: usize = 0;\n    while (i < end) : (i += 1) {\n        var match = true;\n        for (needle, 0..) |nc, j| {\n            const hc = haystack[i + j];\n            if (std.ascii.toLower(hc) != std.ascii.toLower(nc)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n\nfn cloneStatus(status: Status, allocator: std.mem.Allocator) !Status {\n    return switch (status) {\n        .custom => |s| Status{ .custom = try allocator.dupe(u8, s) },\n        else => status,\n    };\n}\n\nfn freeStatus(status: Status, allocator: std.mem.Allocator) void {\n    switch (status) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n}\n\nfn cloneIssueType(issue_type: IssueType, allocator: std.mem.Allocator) !IssueType {\n    return switch (issue_type) {\n        .custom => |s| IssueType{ .custom = try allocator.dupe(u8, s) },\n        else => issue_type,\n    };\n}\n\nfn freeIssueType(issue_type: IssueType, allocator: std.mem.Allocator) void {\n    switch (issue_type) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n}\n\nfn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n    var result: Dependency = undefined;\n\n    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n    errdefer allocator.free(result.issue_id);\n\n    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n    errdefer allocator.free(result.depends_on_id);\n\n    result.dep_type = switch (dep.dep_type) {\n        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n        else => dep.dep_type,\n    };\n\n    result.created_at = dep.created_at;\n    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n\n    return result;\n}\n\nfn cloneComment(comment: Comment, allocator: std.mem.Allocator) !Comment {\n    return Comment{\n        .id = comment.id,\n        .issue_id = try allocator.dupe(u8, comment.issue_id),\n        .author = try allocator.dupe(u8, comment.author),\n        .body = try allocator.dupe(u8, comment.body),\n        .created_at = comment.created_at,\n    };\n}\n\nfn freeComment(comment: *Comment, allocator: std.mem.Allocator) void {\n    allocator.free(comment.issue_id);\n    allocator.free(comment.author);\n    allocator.free(comment.body);\n}\n\n// --- Tests ---\n\ntest \"IssueStore insert and get\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-test1\", \"Test Issue\", 1706540000);\n    try store.insert(issue);\n\n    try std.testing.expect(try store.exists(\"bd-test1\"));\n\n    var retrieved = (try store.get(\"bd-test1\")).?;\n    defer retrieved.deinit(allocator);\n\n    try std.testing.expectEqualStrings(\"bd-test1\", retrieved.id);\n    try std.testing.expectEqualStrings(\"Test Issue\", retrieved.title);\n}\n\ntest \"IssueStore get returns null for missing\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const result = try store.get(\"bd-nonexistent\");\n    try std.testing.expect(result == null);\n}\n\ntest \"IssueStore update modifies fields\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-update\", \"Original Title\", 1706540000);\n    try store.insert(issue);\n\n    try store.update(\"bd-update\", .{\n        .title = \"Updated Title\",\n        .status = .in_progress,\n        .priority = Priority.HIGH,\n    }, 1706550000);\n\n    var updated = (try store.get(\"bd-update\")).?;\n    defer updated.deinit(allocator);\n\n    try std.testing.expectEqualStrings(\"Updated Title\", updated.title);\n    try std.testing.expect(statusEql(updated.status, .in_progress));\n    try std.testing.expectEqual(Priority.HIGH, updated.priority);\n}\n\ntest \"IssueStore update increments version\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-version\", \"Version Test\", 1706540000);\n    try store.insert(issue);\n\n    // Initial version should be 1\n    var v1 = (try store.get(\"bd-version\")).?;\n    defer v1.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 1), v1.version);\n\n    // Update should increment version\n    try store.update(\"bd-version\", .{ .title = \"Updated\" }, 1706550000);\n\n    var v2 = (try store.get(\"bd-version\")).?;\n    defer v2.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 2), v2.version);\n\n    // Another update should increment again\n    try store.update(\"bd-version\", .{ .title = \"Updated Again\" }, 1706560000);\n\n    var v3 = (try store.get(\"bd-version\")).?;\n    defer v3.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 3), v3.version);\n}\n\ntest \"IssueStore update with expected_version succeeds on match\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-optlock\", \"Optimistic Lock Test\", 1706540000);\n    try store.insert(issue);\n\n    // Get current version (1)\n    var current = (try store.get(\"bd-optlock\")).?;\n    const current_version = current.version;\n    current.deinit(allocator);\n\n    // Update with correct expected version should succeed\n    try store.update(\"bd-optlock\", .{\n        .title = \"Updated with lock\",\n        .expected_version = current_version,\n    }, 1706550000);\n\n    var updated = (try store.get(\"bd-optlock\")).?;\n    defer updated.deinit(allocator);\n    try std.testing.expectEqualStrings(\"Updated with lock\", updated.title);\n    try std.testing.expectEqual(@as(u64, 2), updated.version);\n}\n\ntest \"IssueStore update with expected_version fails on mismatch\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-conflict\", \"Conflict Test\", 1706540000);\n    try store.insert(issue);\n\n    // Update once to increment version to 2\n    try store.update(\"bd-conflict\", .{ .title = \"First Update\" }, 1706550000);\n\n    // Try to update with stale expected_version (1 instead of 2)\n    const result = store.update(\"bd-conflict\", .{\n        .title = \"Conflicting Update\",\n        .expected_version = 1, // Stale version\n    }, 1706560000);\n\n    try std.testing.expectError(IssueStoreError.VersionMismatch, result);\n\n    // Verify original update is preserved\n    var preserved = (try store.get(\"bd-conflict\")).?;\n    defer preserved.deinit(allocator);\n    try std.testing.expectEqualStrings(\"First Update\", preserved.title);\n    try std.testing.expectEqual(@as(u64, 2), preserved.version);\n}\n\ntest \"IssueStore delete sets tombstone\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-delete\", \"To Delete\", 1706540000);\n    try store.insert(issue);\n\n    try store.delete(\"bd-delete\", 1706550000);\n\n    var deleted = (try store.get(\"bd-delete\")).?;\n    defer deleted.deinit(allocator);\n\n    try std.testing.expect(statusEql(deleted.status, .tombstone));\n}\n\ntest \"IssueStore list returns issues\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-list1\", \"Issue 1\", 1706540000));\n    try store.insert(Issue.init(\"bd-list2\", \"Issue 2\", 1706550000));\n    try store.insert(Issue.init(\"bd-list3\", \"Issue 3\", 1706560000));\n\n    const issues = try store.list(.{});\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    try std.testing.expectEqual(@as(usize, 3), issues.len);\n}\n\ntest \"IssueStore list excludes tombstones\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-active\", \"Active\", 1706540000));\n    try store.insert(Issue.init(\"bd-deleted\", \"Deleted\", 1706550000));\n    try store.delete(\"bd-deleted\", 1706560000);\n\n    const issues = try store.list(.{});\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), issues.len);\n    try std.testing.expectEqualStrings(\"bd-active\", issues[0].id);\n}\n\ntest \"IssueStore dirty tracking\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-dirty\", \"Dirty Test\", 1706540000);\n    try store.insert(issue);\n\n    try std.testing.expect(store.isDirty());\n\n    const dirty_ids = try store.getDirtyIds();\n    defer {\n        for (dirty_ids) |id| {\n            allocator.free(id);\n        }\n        allocator.free(dirty_ids);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), dirty_ids.len);\n    try std.testing.expectEqualStrings(\"bd-dirty\", dirty_ids[0]);\n\n    try store.clearDirty(\"bd-dirty\");\n\n    const after_clear = try store.getDirtyIds();\n    defer allocator.free(after_clear);\n\n    try std.testing.expectEqual(@as(usize, 0), after_clear.len);\n}\n\ntest \"IssueStore addLabel and removeLabel\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-labels\", \"Label Test\", 1706540000));\n\n    try store.addLabel(\"bd-labels\", \"bug\");\n    try store.addLabel(\"bd-labels\", \"urgent\");\n\n    const labels = try store.getLabels(\"bd-labels\");\n    defer {\n        for (labels) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(labels);\n    }\n\n    try std.testing.expectEqual(@as(usize, 2), labels.len);\n\n    try store.removeLabel(\"bd-labels\", \"bug\");\n\n    const after_remove = try store.getLabels(\"bd-labels\");\n    defer {\n        for (after_remove) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(after_remove);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), after_remove.len);\n}\n\ntest \"StoreLoadResult.hasCorruption\" {\n    var result = StoreLoadResult{\n        .jsonl_corruption_count = 0,\n    };\n    try std.testing.expect(!result.hasCorruption());\n\n    result.jsonl_corruption_count = 3;\n    try std.testing.expect(result.hasCorruption());\n}\n\ntest \"IssueStore loadFromFileWithRecovery handles corrupt entries\" {\n    const allocator = std.testing.allocator;\n    const test_util = @import(\"../test_util.zig\");\n    const test_dir = try test_util.createTestDir(allocator, \"store_recovery\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"issues.jsonl\" });\n    defer allocator.free(test_path);\n\n    // Write a file with mixed valid and corrupt entries\n    // Use full Issue JSON format (all fields required by parser)\n    {\n        const file = try std.fs.cwd().createFile(test_path, .{});\n        defer file.close();\n\n        // Valid issue\n        const valid1 = \"{\\\"id\\\":\\\"bd-valid1\\\",\\\"content_hash\\\":null,\\\"title\\\":\\\"Valid Issue\\\",\\\"description\\\":null,\\\"design\\\":null,\\\"acceptance_criteria\\\":null,\\\"notes\\\":null,\\\"status\\\":\\\"open\\\",\\\"priority\\\":2,\\\"issue_type\\\":\\\"task\\\",\\\"assignee\\\":null,\\\"owner\\\":null,\\\"created_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"created_by\\\":null,\\\"updated_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"closed_at\\\":null,\\\"close_reason\\\":null,\\\"due_at\\\":null,\\\"defer_until\\\":null,\\\"estimated_minutes\\\":null,\\\"external_ref\\\":null,\\\"source_system\\\":null,\\\"pinned\\\":false,\\\"is_template\\\":false,\\\"labels\\\":[],\\\"dependencies\\\":[],\\\"comments\\\":[]}\\n\";\n        try file.writeAll(valid1);\n\n        // Corrupt entry\n        try file.writeAll(\"{invalid json here}\\n\");\n\n        // Another valid issue\n        const valid2 = \"{\\\"id\\\":\\\"bd-valid2\\\",\\\"content_hash\\\":null,\\\"title\\\":\\\"Another Valid Issue\\\",\\\"description\\\":null,\\\"design\\\":null,\\\"acceptance_criteria\\\":null,\\\"notes\\\":null,\\\"status\\\":\\\"open\\\",\\\"priority\\\":2,\\\"issue_type\\\":\\\"task\\\",\\\"assignee\\\":null,\\\"owner\\\":null,\\\"created_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"created_by\\\":null,\\\"updated_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"closed_at\\\":null,\\\"close_reason\\\":null,\\\"due_at\\\":null,\\\"defer_until\\\":null,\\\"estimated_minutes\\\":null,\\\"external_ref\\\":null,\\\"source_system\\\":null,\\\"pinned\\\":false,\\\"is_template\\\":false,\\\"labels\\\":[],\\\"dependencies\\\":[],\\\"comments\\\":[]}\\n\";\n        try file.writeAll(valid2);\n    }\n\n    var store = IssueStore.init(allocator, test_path);\n    defer store.deinit();\n\n    var result = try store.loadFromFileWithRecovery();\n    defer result.deinit(allocator);\n\n    // Should have loaded 2 valid issues\n    try std.testing.expectEqual(@as(usize, 2), store.issues.items.len);\n\n    // Should have tracked 1 corrupt entry\n    try std.testing.expectEqual(@as(usize, 1), result.jsonl_corruption_count);\n    try std.testing.expect(result.hasCorruption());\n\n    // Verify the correct issues were loaded\n    try std.testing.expect(try store.exists(\"bd-valid1\"));\n    try std.testing.expect(try store.exists(\"bd-valid2\"));\n}\n","structuredPatch":[{"oldStart":373,"oldLines":7,"newStart":373,"newLines":14,"lines":[" ","             // Apply filters","             if (filters.status) |s| {","-                if (!statusEql(issue.status, s)) continue;","+                // When include_deferred is set, allow deferred issues through even when filtering for open","+                if (!statusEql(issue.status, s)) {","+                    if (filters.include_deferred and statusEql(issue.status, .deferred)) {","+                        // Allow deferred issues through","+                    } else {","+                        continue;","+                    }","+                }","             }","             if (filters.priority) |p| {","                 if (issue.priority.value != p.value) continue;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015mM1Dtfw46UFck447yPG7o","type":"message","role":"assistant","content":[{"type":"text","text":"Also need to remove the later deferred filter check since we now handle it in the status filter. The later check was for the case where no status filter is set."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":361,"cache_read_input_tokens":73075,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":361},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"2740a631-e5f1-490f-8489-66dc08b52d67"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015mM1Dtfw46UFck447yPG7o","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NW5k1k2RsztjYhUkWu85Hs","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","old_string":"            // Overdue filter: only include issues past their due date\n            if (filters.overdue) {\n                const now = std.time.timestamp();\n                if (issue.due_at.value) |due_time| {\n                    if (due_time >= now) continue;\n                } else continue;\n            }\n\n            // Deferred filter: skip deferred issues unless explicitly included\n            if (!filters.include_deferred and statusEql(issue.status, .deferred)) {\n                continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));","new_string":"            // Overdue filter: only include issues past their due date\n            if (filters.overdue) {\n                const now = std.time.timestamp();\n                if (issue.due_at.value) |due_time| {\n                    if (due_time >= now) continue;\n                } else continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":361,"cache_read_input_tokens":73075,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":361},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"9b60f2db-7ae6-4b1f-84d7-7d3645ecab6a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NW5k1k2RsztjYhUkWu85Hs","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/storage/store.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"62885ae0-00b9-4d03-8010-f77ab440f687","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/storage/store.zig","oldString":"            // Overdue filter: only include issues past their due date\n            if (filters.overdue) {\n                const now = std.time.timestamp();\n                if (issue.due_at.value) |due_time| {\n                    if (due_time >= now) continue;\n                } else continue;\n            }\n\n            // Deferred filter: skip deferred issues unless explicitly included\n            if (!filters.include_deferred and statusEql(issue.status, .deferred)) {\n                continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));","newString":"            // Overdue filter: only include issues past their due date\n            if (filters.overdue) {\n                const now = std.time.timestamp();\n                if (issue.due_at.value) |due_time| {\n                    if (due_time >= now) continue;\n                } else continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));","originalFile":"//! In-memory issue store for beads_zig.\n//!\n//! Provides CRUD operations for issues using in-memory storage with:\n//! - Arena allocator for issue memory management\n//! - ArrayList + StringHashMap for fast ID lookup\n//! - Dirty tracking for sync operations\n//! - JSONL persistence via JsonlFile\n\nconst std = @import(\"std\");\nconst JsonlFile = @import(\"jsonl.zig\").JsonlFile;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Rfc3339Timestamp = @import(\"../models/issue.zig\").Rfc3339Timestamp;\nconst OptionalRfc3339Timestamp = @import(\"../models/issue.zig\").OptionalRfc3339Timestamp;\nconst Status = @import(\"../models/status.zig\").Status;\nconst Priority = @import(\"../models/priority.zig\").Priority;\nconst IssueType = @import(\"../models/issue_type.zig\").IssueType;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Comment = @import(\"../models/comment.zig\").Comment;\n\npub const IssueStoreError = error{\n    IssueNotFound,\n    DuplicateId,\n    InvalidIssue,\n    VersionMismatch,\n};\n\n/// Result of loading the store with corruption tracking.\npub const StoreLoadResult = struct {\n    /// Number of corrupt JSONL entries skipped.\n    jsonl_corruption_count: usize = 0,\n    /// Line numbers of corrupt JSONL entries (1-indexed).\n    jsonl_corrupt_lines: []const usize = &.{},\n\n    pub fn hasCorruption(self: StoreLoadResult) bool {\n        return self.jsonl_corruption_count > 0;\n    }\n\n    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n        if (self.jsonl_corrupt_lines.len > 0) {\n            allocator.free(self.jsonl_corrupt_lines);\n        }\n    }\n};\n\npub const IssueStore = struct {\n    allocator: std.mem.Allocator,\n    issues: std.ArrayListUnmanaged(Issue),\n    id_index: std.StringHashMapUnmanaged(usize),\n    dirty_ids: std.StringHashMapUnmanaged(i64),\n    dirty: bool,\n    jsonl_path: []const u8,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, jsonl_path: []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .issues = .{},\n            .id_index = .{},\n            .dirty_ids = .{},\n            .dirty = false,\n            .jsonl_path = jsonl_path,\n        };\n    }\n\n    pub fn deinit(self: *Self) void {\n        for (self.issues.items) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        self.issues.deinit(self.allocator);\n\n        var id_it = self.id_index.keyIterator();\n        while (id_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.id_index.deinit(self.allocator);\n\n        var dirty_it = self.dirty_ids.keyIterator();\n        while (dirty_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.dirty_ids.deinit(self.allocator);\n    }\n\n    /// Load issues from the JSONL file into memory.\n    pub fn loadFromFile(self: *Self) !void {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        const loaded_issues = try jsonl.readAll();\n        defer self.allocator.free(loaded_issues);\n\n        for (loaded_issues) |issue| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n\n            const idx = self.issues.items.len;\n            try self.issues.append(self.allocator, issue);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n\n        self.dirty = false;\n    }\n\n    /// Load issues from the JSONL file with graceful corruption recovery.\n    /// Logs and skips corrupt entries instead of failing.\n    /// Returns statistics about the load including corruption count.\n    pub fn loadFromFileWithRecovery(self: *Self) !StoreLoadResult {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        var load_result = try jsonl.readAllWithRecovery();\n        // Take ownership of corrupt_lines before freeing issues slice\n        const corrupt_lines = load_result.corrupt_lines;\n        load_result.corrupt_lines = &.{}; // Prevent double-free\n        errdefer if (corrupt_lines.len > 0) self.allocator.free(corrupt_lines);\n\n        const loaded_issues = load_result.issues;\n        defer self.allocator.free(loaded_issues);\n\n        for (loaded_issues) |issue| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n\n            const idx = self.issues.items.len;\n            try self.issues.append(self.allocator, issue);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n\n        self.dirty = false;\n\n        return StoreLoadResult{\n            .jsonl_corruption_count = load_result.corruption_count,\n            .jsonl_corrupt_lines = corrupt_lines,\n        };\n    }\n\n    /// Save all issues to the JSONL file.\n    pub fn saveToFile(self: *Self) !void {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        try jsonl.writeAll(self.issues.items);\n        self.dirty = false;\n\n        // Clear dirty tracking\n        var dirty_it = self.dirty_ids.keyIterator();\n        while (dirty_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.dirty_ids.clearRetainingCapacity();\n    }\n\n    /// Insert a new issue into the store.\n    pub fn insert(self: *Self, issue: Issue) !void {\n        if (self.id_index.contains(issue.id)) {\n            return IssueStoreError.DuplicateId;\n        }\n\n        const cloned = try issue.clone(self.allocator);\n        errdefer {\n            var c = cloned;\n            c.deinit(self.allocator);\n        }\n\n        const id_copy = try self.allocator.dupe(u8, cloned.id);\n        errdefer self.allocator.free(id_copy);\n\n        const idx = self.issues.items.len;\n        try self.issues.append(self.allocator, cloned);\n        try self.id_index.put(self.allocator, id_copy, idx);\n\n        try self.markDirty(issue.id);\n    }\n\n    /// Get an issue by ID (without embedded relations).\n    pub fn get(self: *Self, id: []const u8) !?Issue {\n        const idx = self.id_index.get(id) orelse return null;\n        if (idx >= self.issues.items.len) return null;\n\n        return try self.issues.items[idx].clone(self.allocator);\n    }\n\n    /// Get an issue with all embedded relations (labels, deps, comments).\n    /// Since we store everything in-memory, this just returns the issue as-is.\n    pub fn getWithRelations(self: *Self, id: []const u8) !?Issue {\n        return try self.get(id);\n    }\n\n    /// Get a reference to the stored issue (no clone).\n    /// Caller must NOT free or modify the returned issue.\n    pub fn getRef(self: *Self, id: []const u8) ?*Issue {\n        const idx = self.id_index.get(id) orelse return null;\n        if (idx >= self.issues.items.len) return null;\n        return &self.issues.items[idx];\n    }\n\n    /// Fields that can be updated on an issue.\n    pub const IssueUpdate = struct {\n        title: ?[]const u8 = null,\n        description: ?[]const u8 = null,\n        design: ?[]const u8 = null,\n        acceptance_criteria: ?[]const u8 = null,\n        notes: ?[]const u8 = null,\n        status: ?Status = null,\n        priority: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        owner: ?[]const u8 = null,\n        estimated_minutes: ?i32 = null,\n        closed_at: ?i64 = null,\n        close_reason: ?[]const u8 = null,\n        closed_by_session: ?[]const u8 = null,\n        due_at: ?i64 = null,\n        defer_until: ?i64 = null,\n        external_ref: ?[]const u8 = null,\n        source_system: ?[]const u8 = null,\n        pinned: ?bool = null,\n        is_template: ?bool = null,\n        content_hash: ?[]const u8 = null,\n\n        /// Expected version for optimistic locking.\n        /// If set, update will fail with VersionMismatch if issue.version != expected_version.\n        expected_version: ?u64 = null,\n    };\n\n    /// Update an issue with the given fields.\n    /// If updates.expected_version is set, performs optimistic locking check.\n    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {\n        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        // Optimistic locking check\n        if (updates.expected_version) |expected| {\n            if (issue.version != expected) {\n                return IssueStoreError.VersionMismatch;\n            }\n        }\n\n        // Increment version on every update\n        issue.version += 1;\n\n        // Update timestamp\n        issue.updated_at = Rfc3339Timestamp{ .value = now };\n\n        // Apply updates\n        if (updates.title) |v| {\n            self.allocator.free(issue.title);\n            issue.title = try self.allocator.dupe(u8, v);\n        }\n        if (updates.description) |v| {\n            if (issue.description) |d| self.allocator.free(d);\n            issue.description = try self.allocator.dupe(u8, v);\n        }\n        if (updates.design) |v| {\n            if (issue.design) |d| self.allocator.free(d);\n            issue.design = try self.allocator.dupe(u8, v);\n        }\n        if (updates.acceptance_criteria) |v| {\n            if (issue.acceptance_criteria) |a| self.allocator.free(a);\n            issue.acceptance_criteria = try self.allocator.dupe(u8, v);\n        }\n        if (updates.notes) |v| {\n            if (issue.notes) |n| self.allocator.free(n);\n            issue.notes = try self.allocator.dupe(u8, v);\n        }\n        if (updates.status) |v| {\n            freeStatus(issue.status, self.allocator);\n            issue.status = try cloneStatus(v, self.allocator);\n        }\n        if (updates.priority) |v| {\n            issue.priority = v;\n        }\n        if (updates.issue_type) |v| {\n            freeIssueType(issue.issue_type, self.allocator);\n            issue.issue_type = try cloneIssueType(v, self.allocator);\n        }\n        if (updates.assignee) |v| {\n            if (issue.assignee) |a| self.allocator.free(a);\n            issue.assignee = try self.allocator.dupe(u8, v);\n        }\n        if (updates.owner) |v| {\n            if (issue.owner) |o| self.allocator.free(o);\n            issue.owner = try self.allocator.dupe(u8, v);\n        }\n        if (updates.estimated_minutes) |v| {\n            issue.estimated_minutes = v;\n        }\n        if (updates.closed_at) |v| {\n            issue.closed_at = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.close_reason) |v| {\n            if (issue.close_reason) |r| self.allocator.free(r);\n            issue.close_reason = try self.allocator.dupe(u8, v);\n        }\n        if (updates.closed_by_session) |v| {\n            if (issue.closed_by_session) |s| self.allocator.free(s);\n            issue.closed_by_session = try self.allocator.dupe(u8, v);\n        }\n        if (updates.due_at) |v| {\n            issue.due_at = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.defer_until) |v| {\n            issue.defer_until = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.external_ref) |v| {\n            if (issue.external_ref) |e| self.allocator.free(e);\n            issue.external_ref = try self.allocator.dupe(u8, v);\n        }\n        if (updates.source_system) |v| {\n            if (issue.source_system) |s| self.allocator.free(s);\n            issue.source_system = try self.allocator.dupe(u8, v);\n        }\n        if (updates.pinned) |v| {\n            issue.pinned = v;\n        }\n        if (updates.is_template) |v| {\n            issue.is_template = v;\n        }\n        if (updates.content_hash) |v| {\n            if (issue.content_hash) |h| self.allocator.free(h);\n            issue.content_hash = try self.allocator.dupe(u8, v);\n        }\n\n        try self.markDirty(id);\n    }\n\n    /// Soft delete an issue by setting its status to tombstone.\n    pub fn delete(self: *Self, id: []const u8, now: i64) !void {\n        try self.update(id, .{ .status = .tombstone }, now);\n    }\n\n    /// Filters for listing issues.\n    pub const ListFilters = struct {\n        status: ?Status = null,\n        priority: ?Priority = null,\n        priority_min: ?Priority = null,\n        priority_max: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        label_any: []const []const u8 = &[_][]const u8{},\n        title_contains: ?[]const u8 = null,\n        desc_contains: ?[]const u8 = null,\n        notes_contains: ?[]const u8 = null,\n        include_tombstones: bool = false,\n        overdue: bool = false,\n        include_deferred: bool = false,\n        limit: ?u32 = null,\n        offset: ?u32 = null,\n        order_by: OrderBy = .created_at,\n        order_desc: bool = true,\n\n        pub const OrderBy = enum {\n            created_at,\n            updated_at,\n            priority,\n        };\n    };\n\n    /// List issues with optional filters.\n    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.issues.items) |issue| {\n            // Filter tombstones\n            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n                continue;\n            }\n\n            // Apply filters\n            if (filters.status) |s| {\n                // When include_deferred is set, allow deferred issues through even when filtering for open\n                if (!statusEql(issue.status, s)) {\n                    if (filters.include_deferred and statusEql(issue.status, .deferred)) {\n                        // Allow deferred issues through\n                    } else {\n                        continue;\n                    }\n                }\n            }\n            if (filters.priority) |p| {\n                if (issue.priority.value != p.value) continue;\n            }\n            if (filters.issue_type) |t| {\n                if (!issueTypeEql(issue.issue_type, t)) continue;\n            }\n            if (filters.assignee) |a| {\n                if (issue.assignee == null) continue;\n                if (!std.mem.eql(u8, issue.assignee.?, a)) continue;\n            }\n            if (filters.label) |lbl| {\n                var found = false;\n                for (issue.labels) |label| {\n                    if (std.mem.eql(u8, label, lbl)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) continue;\n            }\n\n            // label_any: OR logic - issue must have at least ONE of the specified labels\n            if (filters.label_any.len > 0) {\n                var found_any = false;\n                for (filters.label_any) |any_label| {\n                    for (issue.labels) |issue_label| {\n                        if (std.mem.eql(u8, issue_label, any_label)) {\n                            found_any = true;\n                            break;\n                        }\n                    }\n                    if (found_any) break;\n                }\n                if (!found_any) continue;\n            }\n\n            // Priority range filters (lower value = higher priority)\n            if (filters.priority_min) |min_p| {\n                if (issue.priority.value < min_p.value) continue;\n            }\n            if (filters.priority_max) |max_p| {\n                if (issue.priority.value > max_p.value) continue;\n            }\n\n            // Substring filters (case-insensitive)\n            if (filters.title_contains) |query| {\n                if (!containsIgnoreCase(issue.title, query)) continue;\n            }\n            if (filters.desc_contains) |query| {\n                if (issue.description) |desc| {\n                    if (!containsIgnoreCase(desc, query)) continue;\n                } else continue;\n            }\n            if (filters.notes_contains) |query| {\n                if (issue.notes) |notes| {\n                    if (!containsIgnoreCase(notes, query)) continue;\n                } else continue;\n            }\n\n            // Overdue filter: only include issues past their due date\n            if (filters.overdue) {\n                const now = std.time.timestamp();\n                if (issue.due_at.value) |due_time| {\n                    if (due_time >= now) continue;\n                } else continue;\n            }\n\n            // Deferred filter: skip deferred issues unless explicitly included\n            if (!filters.include_deferred and statusEql(issue.status, .deferred)) {\n                continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort\n        const SortContext = struct {\n            order_by: ListFilters.OrderBy,\n            order_desc: bool,\n        };\n        const ctx = SortContext{ .order_by = filters.order_by, .order_desc = filters.order_desc };\n\n        std.mem.sortUnstable(Issue, results.items, ctx, struct {\n            fn lessThan(c: SortContext, a: Issue, b: Issue) bool {\n                const cmp: i64 = switch (c.order_by) {\n                    .created_at => a.created_at.value - b.created_at.value,\n                    .updated_at => a.updated_at.value - b.updated_at.value,\n                    .priority => @as(i64, a.priority.value) - @as(i64, b.priority.value),\n                };\n                return if (c.order_desc) cmp > 0 else cmp < 0;\n            }\n        }.lessThan);\n\n        // Apply offset and limit\n        var start: usize = 0;\n        if (filters.offset) |off| {\n            start = @min(off, results.items.len);\n        }\n\n        var end: usize = results.items.len;\n        if (filters.limit) |lim| {\n            end = @min(start + lim, results.items.len);\n        }\n\n        // Free items outside the range\n        for (results.items[0..start]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        for (results.items[end..]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n\n        // Return slice\n        const slice = try self.allocator.dupe(Issue, results.items[start..end]);\n        results.deinit(self.allocator);\n        return slice;\n    }\n\n    /// Result from counting issues.\n    pub const CountResult = struct {\n        key: []const u8,\n        count: u64,\n    };\n\n    /// Count issues, optionally grouped by a field.\n    pub fn count(self: *Self, group_by: ?GroupBy) ![]CountResult {\n        var counts: std.StringHashMapUnmanaged(u64) = .{};\n        defer counts.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const key_str: []const u8 = if (group_by) |g| switch (g) {\n                .status => issue.status.toString(),\n                .priority => switch (issue.priority.value) {\n                    0 => \"0\",\n                    1 => \"1\",\n                    2 => \"2\",\n                    3 => \"3\",\n                    4 => \"4\",\n                    else => unreachable,\n                },\n                .issue_type => issue.issue_type.toString(),\n                .assignee => issue.assignee orelse \"(unassigned)\",\n            } else \"total\";\n\n            const entry = counts.getOrPutValue(self.allocator, key_str, 0) catch continue;\n            entry.value_ptr.* += 1;\n        }\n\n        var results: std.ArrayListUnmanaged(CountResult) = .{};\n        errdefer {\n            for (results.items) |r| {\n                self.allocator.free(r.key);\n            }\n            results.deinit(self.allocator);\n        }\n\n        var it = counts.iterator();\n        while (it.next()) |entry| {\n            const key = try self.allocator.dupe(u8, entry.key_ptr.*);\n            try results.append(self.allocator, .{ .key = key, .count = entry.value_ptr.* });\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    pub const GroupBy = enum {\n        status,\n        priority,\n        issue_type,\n        assignee,\n    };\n\n    /// Check if an issue exists.\n    pub fn exists(self: *Self, id: []const u8) !bool {\n        return self.id_index.contains(id);\n    }\n\n    /// Get labels for an issue.\n    pub fn getLabels(self: *Self, issue_id: []const u8) ![]const []const u8 {\n        const idx = self.id_index.get(issue_id) orelse return &[_][]const u8{};\n        if (idx >= self.issues.items.len) return &[_][]const u8{};\n\n        const issue = self.issues.items[idx];\n        if (issue.labels.len == 0) return &[_][]const u8{};\n\n        const labels = try self.allocator.alloc([]const u8, issue.labels.len);\n        errdefer self.allocator.free(labels);\n\n        for (issue.labels, 0..) |label, i| {\n            labels[i] = try self.allocator.dupe(u8, label);\n        }\n        return labels;\n    }\n\n    /// Add a label to an issue.\n    pub fn addLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        // Check if already exists\n        for (issue.labels) |existing| {\n            if (std.mem.eql(u8, existing, label)) return;\n        }\n\n        // Add new label\n        const label_copy = try self.allocator.dupe(u8, label);\n        errdefer self.allocator.free(label_copy);\n\n        const new_labels = try self.allocator.alloc([]const u8, issue.labels.len + 1);\n        @memcpy(new_labels[0..issue.labels.len], issue.labels);\n        new_labels[issue.labels.len] = label_copy;\n\n        if (issue.labels.len > 0) {\n            self.allocator.free(issue.labels);\n        }\n        issue.labels = new_labels;\n\n        try self.markDirty(issue_id);\n    }\n\n    /// Remove a label from an issue.\n    pub fn removeLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        var found_idx: ?usize = null;\n        for (issue.labels, 0..) |existing, i| {\n            if (std.mem.eql(u8, existing, label)) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx) |fi| {\n            self.allocator.free(issue.labels[fi]);\n\n            if (issue.labels.len == 1) {\n                self.allocator.free(issue.labels);\n                issue.labels = &[_][]const u8{};\n            } else {\n                const new_labels = try self.allocator.alloc([]const u8, issue.labels.len - 1);\n                var j: usize = 0;\n                for (issue.labels, 0..) |lbl, i| {\n                    if (i != fi) {\n                        new_labels[j] = lbl;\n                        j += 1;\n                    }\n                }\n                self.allocator.free(issue.labels);\n                issue.labels = new_labels;\n            }\n\n            try self.markDirty(issue_id);\n        }\n    }\n\n    /// Get dependencies for an issue.\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]const Dependency {\n        const idx = self.id_index.get(issue_id) orelse return &[_]Dependency{};\n        if (idx >= self.issues.items.len) return &[_]Dependency{};\n\n        const issue = self.issues.items[idx];\n        if (issue.dependencies.len == 0) return &[_]Dependency{};\n\n        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n        errdefer self.allocator.free(deps);\n\n        for (issue.dependencies, 0..) |dep, i| {\n            deps[i] = try cloneDependency(dep, self.allocator);\n        }\n        return deps;\n    }\n\n    /// Get comments for an issue.\n    pub fn getComments(self: *Self, issue_id: []const u8) ![]const Comment {\n        const idx = self.id_index.get(issue_id) orelse return &[_]Comment{};\n        if (idx >= self.issues.items.len) return &[_]Comment{};\n\n        const issue = self.issues.items[idx];\n        if (issue.comments.len == 0) return &[_]Comment{};\n\n        const comments = try self.allocator.alloc(Comment, issue.comments.len);\n        errdefer self.allocator.free(comments);\n\n        for (issue.comments, 0..) |c, i| {\n            comments[i] = try cloneComment(c, self.allocator);\n        }\n        return comments;\n    }\n\n    /// Add a comment to an issue.\n    pub fn addComment(self: *Self, issue_id: []const u8, comment: Comment) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        const cloned = try cloneComment(comment, self.allocator);\n        errdefer freeComment(@constCast(&cloned), self.allocator);\n\n        const new_comments = try self.allocator.alloc(Comment, issue.comments.len + 1);\n        @memcpy(new_comments[0..issue.comments.len], issue.comments);\n        new_comments[issue.comments.len] = cloned;\n\n        if (issue.comments.len > 0) {\n            self.allocator.free(issue.comments);\n        }\n        issue.comments = new_comments;\n\n        try self.markDirty(issue_id);\n    }\n\n    /// Mark an issue as dirty for sync.\n    pub fn markDirty(self: *Self, id: []const u8) !void {\n        self.dirty = true;\n        const now = std.time.timestamp();\n\n        if (!self.dirty_ids.contains(id)) {\n            const id_copy = try self.allocator.dupe(u8, id);\n            try self.dirty_ids.put(self.allocator, id_copy, now);\n        } else {\n            self.dirty_ids.getPtr(id).?.* = now;\n        }\n    }\n\n    /// Clear dirty flag for an issue.\n    pub fn clearDirty(self: *Self, id: []const u8) !void {\n        if (self.dirty_ids.fetchRemove(id)) |kv| {\n            self.allocator.free(kv.key);\n        }\n    }\n\n    /// Get all dirty issue IDs.\n    pub fn getDirtyIds(self: *Self) ![][]const u8 {\n        var ids: std.ArrayListUnmanaged([]const u8) = .{};\n        errdefer {\n            for (ids.items) |id| {\n                self.allocator.free(id);\n            }\n            ids.deinit(self.allocator);\n        }\n\n        var it = self.dirty_ids.keyIterator();\n        while (it.next()) |key| {\n            const id = try self.allocator.dupe(u8, key.*);\n            try ids.append(self.allocator, id);\n        }\n\n        return ids.toOwnedSlice(self.allocator);\n    }\n\n    /// Check if the store has unsaved changes.\n    pub fn isDirty(self: *Self) bool {\n        return self.dirty;\n    }\n\n    /// Get total number of issues (excluding tombstones).\n    pub fn countTotal(self: *Self) usize {\n        var total: usize = 0;\n        for (self.issues.items) |issue| {\n            if (!statusEql(issue.status, .tombstone)) {\n                total += 1;\n            }\n        }\n        return total;\n    }\n\n    /// Get all issues as a slice (no clone, read-only).\n    pub fn getAllRef(self: *Self) []const Issue {\n        return self.issues.items;\n    }\n\n    /// Suggestion for similar ID lookup.\n    pub const IdSuggestion = struct {\n        id: []const u8,\n        title: []const u8,\n    };\n\n    /// Find similar IDs when a lookup fails (for \"did you mean\" suggestions).\n    /// Uses prefix matching and Levenshtein-like scoring.\n    /// Returns up to `max_count` suggestions, caller must free.\n    pub fn findSimilarIds(self: *Self, target: []const u8, max_count: usize) ![]IdSuggestion {\n        if (self.issues.items.len == 0) return &[_]IdSuggestion{};\n\n        const Scored = struct {\n            id: []const u8,\n            title: []const u8,\n            score: i32,\n        };\n\n        var candidates: std.ArrayListUnmanaged(Scored) = .{};\n        defer candidates.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const score = computeSimilarity(target, issue.id);\n            if (score > 0) {\n                try candidates.append(self.allocator, .{\n                    .id = issue.id,\n                    .title = issue.title,\n                    .score = score,\n                });\n            }\n        }\n\n        if (candidates.items.len == 0) return &[_]IdSuggestion{};\n\n        // Sort by score descending\n        std.mem.sortUnstable(Scored, candidates.items, {}, struct {\n            fn lessThan(_: void, a: Scored, b: Scored) bool {\n                return a.score > b.score;\n            }\n        }.lessThan);\n\n        const result_count = @min(max_count, candidates.items.len);\n        var suggestions = try self.allocator.alloc(IdSuggestion, result_count);\n        errdefer self.allocator.free(suggestions);\n\n        for (0..result_count) |i| {\n            suggestions[i] = .{\n                .id = try self.allocator.dupe(u8, candidates.items[i].id),\n                .title = try self.allocator.dupe(u8, candidates.items[i].title),\n            };\n        }\n\n        return suggestions;\n    }\n\n    /// Free suggestions returned by findSimilarIds.\n    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n        for (suggestions) |s| {\n            self.allocator.free(s.id);\n            self.allocator.free(s.title);\n        }\n        self.allocator.free(suggestions);\n    }\n};\n\n/// Compute similarity score between target and candidate ID.\n/// Higher score = more similar.\nfn computeSimilarity(target: []const u8, candidate: []const u8) i32 {\n    var score: i32 = 0;\n\n    // Exact prefix match (bd-abc matches bd-abc123)\n    if (std.mem.startsWith(u8, candidate, target)) {\n        score += 100;\n    }\n    // Candidate is prefix of target (bd-abc123 starts with bd-abc)\n    else if (std.mem.startsWith(u8, target, candidate)) {\n        score += 80;\n    }\n\n    // Common prefix length\n    var common_prefix: usize = 0;\n    const min_len = @min(target.len, candidate.len);\n    for (0..min_len) |i| {\n        if (target[i] == candidate[i]) {\n            common_prefix += 1;\n        } else {\n            break;\n        }\n    }\n    score += @intCast(common_prefix * 5);\n\n    // Contains target as substring\n    if (std.mem.indexOf(u8, candidate, target) != null) {\n        score += 30;\n    }\n\n    // Similar length bonus\n    const len_diff: i32 = @intCast(@abs(@as(i64, @intCast(target.len)) - @as(i64, @intCast(candidate.len))));\n    if (len_diff <= 2) {\n        score += 10;\n    }\n\n    return score;\n}\n\n// Helper functions\nfn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn issueTypeEql(a: IssueType, b: IssueType) bool {\n    const Tag = std.meta.Tag(IssueType);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\npub fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {\n    if (needle.len == 0) return true;\n    if (needle.len > haystack.len) return false;\n\n    const end = haystack.len - needle.len + 1;\n    var i: usize = 0;\n    while (i < end) : (i += 1) {\n        var match = true;\n        for (needle, 0..) |nc, j| {\n            const hc = haystack[i + j];\n            if (std.ascii.toLower(hc) != std.ascii.toLower(nc)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n\nfn cloneStatus(status: Status, allocator: std.mem.Allocator) !Status {\n    return switch (status) {\n        .custom => |s| Status{ .custom = try allocator.dupe(u8, s) },\n        else => status,\n    };\n}\n\nfn freeStatus(status: Status, allocator: std.mem.Allocator) void {\n    switch (status) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n}\n\nfn cloneIssueType(issue_type: IssueType, allocator: std.mem.Allocator) !IssueType {\n    return switch (issue_type) {\n        .custom => |s| IssueType{ .custom = try allocator.dupe(u8, s) },\n        else => issue_type,\n    };\n}\n\nfn freeIssueType(issue_type: IssueType, allocator: std.mem.Allocator) void {\n    switch (issue_type) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n}\n\nfn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n    var result: Dependency = undefined;\n\n    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n    errdefer allocator.free(result.issue_id);\n\n    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n    errdefer allocator.free(result.depends_on_id);\n\n    result.dep_type = switch (dep.dep_type) {\n        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n        else => dep.dep_type,\n    };\n\n    result.created_at = dep.created_at;\n    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n\n    return result;\n}\n\nfn cloneComment(comment: Comment, allocator: std.mem.Allocator) !Comment {\n    return Comment{\n        .id = comment.id,\n        .issue_id = try allocator.dupe(u8, comment.issue_id),\n        .author = try allocator.dupe(u8, comment.author),\n        .body = try allocator.dupe(u8, comment.body),\n        .created_at = comment.created_at,\n    };\n}\n\nfn freeComment(comment: *Comment, allocator: std.mem.Allocator) void {\n    allocator.free(comment.issue_id);\n    allocator.free(comment.author);\n    allocator.free(comment.body);\n}\n\n// --- Tests ---\n\ntest \"IssueStore insert and get\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-test1\", \"Test Issue\", 1706540000);\n    try store.insert(issue);\n\n    try std.testing.expect(try store.exists(\"bd-test1\"));\n\n    var retrieved = (try store.get(\"bd-test1\")).?;\n    defer retrieved.deinit(allocator);\n\n    try std.testing.expectEqualStrings(\"bd-test1\", retrieved.id);\n    try std.testing.expectEqualStrings(\"Test Issue\", retrieved.title);\n}\n\ntest \"IssueStore get returns null for missing\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const result = try store.get(\"bd-nonexistent\");\n    try std.testing.expect(result == null);\n}\n\ntest \"IssueStore update modifies fields\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-update\", \"Original Title\", 1706540000);\n    try store.insert(issue);\n\n    try store.update(\"bd-update\", .{\n        .title = \"Updated Title\",\n        .status = .in_progress,\n        .priority = Priority.HIGH,\n    }, 1706550000);\n\n    var updated = (try store.get(\"bd-update\")).?;\n    defer updated.deinit(allocator);\n\n    try std.testing.expectEqualStrings(\"Updated Title\", updated.title);\n    try std.testing.expect(statusEql(updated.status, .in_progress));\n    try std.testing.expectEqual(Priority.HIGH, updated.priority);\n}\n\ntest \"IssueStore update increments version\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-version\", \"Version Test\", 1706540000);\n    try store.insert(issue);\n\n    // Initial version should be 1\n    var v1 = (try store.get(\"bd-version\")).?;\n    defer v1.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 1), v1.version);\n\n    // Update should increment version\n    try store.update(\"bd-version\", .{ .title = \"Updated\" }, 1706550000);\n\n    var v2 = (try store.get(\"bd-version\")).?;\n    defer v2.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 2), v2.version);\n\n    // Another update should increment again\n    try store.update(\"bd-version\", .{ .title = \"Updated Again\" }, 1706560000);\n\n    var v3 = (try store.get(\"bd-version\")).?;\n    defer v3.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 3), v3.version);\n}\n\ntest \"IssueStore update with expected_version succeeds on match\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-optlock\", \"Optimistic Lock Test\", 1706540000);\n    try store.insert(issue);\n\n    // Get current version (1)\n    var current = (try store.get(\"bd-optlock\")).?;\n    const current_version = current.version;\n    current.deinit(allocator);\n\n    // Update with correct expected version should succeed\n    try store.update(\"bd-optlock\", .{\n        .title = \"Updated with lock\",\n        .expected_version = current_version,\n    }, 1706550000);\n\n    var updated = (try store.get(\"bd-optlock\")).?;\n    defer updated.deinit(allocator);\n    try std.testing.expectEqualStrings(\"Updated with lock\", updated.title);\n    try std.testing.expectEqual(@as(u64, 2), updated.version);\n}\n\ntest \"IssueStore update with expected_version fails on mismatch\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-conflict\", \"Conflict Test\", 1706540000);\n    try store.insert(issue);\n\n    // Update once to increment version to 2\n    try store.update(\"bd-conflict\", .{ .title = \"First Update\" }, 1706550000);\n\n    // Try to update with stale expected_version (1 instead of 2)\n    const result = store.update(\"bd-conflict\", .{\n        .title = \"Conflicting Update\",\n        .expected_version = 1, // Stale version\n    }, 1706560000);\n\n    try std.testing.expectError(IssueStoreError.VersionMismatch, result);\n\n    // Verify original update is preserved\n    var preserved = (try store.get(\"bd-conflict\")).?;\n    defer preserved.deinit(allocator);\n    try std.testing.expectEqualStrings(\"First Update\", preserved.title);\n    try std.testing.expectEqual(@as(u64, 2), preserved.version);\n}\n\ntest \"IssueStore delete sets tombstone\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-delete\", \"To Delete\", 1706540000);\n    try store.insert(issue);\n\n    try store.delete(\"bd-delete\", 1706550000);\n\n    var deleted = (try store.get(\"bd-delete\")).?;\n    defer deleted.deinit(allocator);\n\n    try std.testing.expect(statusEql(deleted.status, .tombstone));\n}\n\ntest \"IssueStore list returns issues\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-list1\", \"Issue 1\", 1706540000));\n    try store.insert(Issue.init(\"bd-list2\", \"Issue 2\", 1706550000));\n    try store.insert(Issue.init(\"bd-list3\", \"Issue 3\", 1706560000));\n\n    const issues = try store.list(.{});\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    try std.testing.expectEqual(@as(usize, 3), issues.len);\n}\n\ntest \"IssueStore list excludes tombstones\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-active\", \"Active\", 1706540000));\n    try store.insert(Issue.init(\"bd-deleted\", \"Deleted\", 1706550000));\n    try store.delete(\"bd-deleted\", 1706560000);\n\n    const issues = try store.list(.{});\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), issues.len);\n    try std.testing.expectEqualStrings(\"bd-active\", issues[0].id);\n}\n\ntest \"IssueStore dirty tracking\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-dirty\", \"Dirty Test\", 1706540000);\n    try store.insert(issue);\n\n    try std.testing.expect(store.isDirty());\n\n    const dirty_ids = try store.getDirtyIds();\n    defer {\n        for (dirty_ids) |id| {\n            allocator.free(id);\n        }\n        allocator.free(dirty_ids);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), dirty_ids.len);\n    try std.testing.expectEqualStrings(\"bd-dirty\", dirty_ids[0]);\n\n    try store.clearDirty(\"bd-dirty\");\n\n    const after_clear = try store.getDirtyIds();\n    defer allocator.free(after_clear);\n\n    try std.testing.expectEqual(@as(usize, 0), after_clear.len);\n}\n\ntest \"IssueStore addLabel and removeLabel\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-labels\", \"Label Test\", 1706540000));\n\n    try store.addLabel(\"bd-labels\", \"bug\");\n    try store.addLabel(\"bd-labels\", \"urgent\");\n\n    const labels = try store.getLabels(\"bd-labels\");\n    defer {\n        for (labels) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(labels);\n    }\n\n    try std.testing.expectEqual(@as(usize, 2), labels.len);\n\n    try store.removeLabel(\"bd-labels\", \"bug\");\n\n    const after_remove = try store.getLabels(\"bd-labels\");\n    defer {\n        for (after_remove) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(after_remove);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), after_remove.len);\n}\n\ntest \"StoreLoadResult.hasCorruption\" {\n    var result = StoreLoadResult{\n        .jsonl_corruption_count = 0,\n    };\n    try std.testing.expect(!result.hasCorruption());\n\n    result.jsonl_corruption_count = 3;\n    try std.testing.expect(result.hasCorruption());\n}\n\ntest \"IssueStore loadFromFileWithRecovery handles corrupt entries\" {\n    const allocator = std.testing.allocator;\n    const test_util = @import(\"../test_util.zig\");\n    const test_dir = try test_util.createTestDir(allocator, \"store_recovery\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"issues.jsonl\" });\n    defer allocator.free(test_path);\n\n    // Write a file with mixed valid and corrupt entries\n    // Use full Issue JSON format (all fields required by parser)\n    {\n        const file = try std.fs.cwd().createFile(test_path, .{});\n        defer file.close();\n\n        // Valid issue\n        const valid1 = \"{\\\"id\\\":\\\"bd-valid1\\\",\\\"content_hash\\\":null,\\\"title\\\":\\\"Valid Issue\\\",\\\"description\\\":null,\\\"design\\\":null,\\\"acceptance_criteria\\\":null,\\\"notes\\\":null,\\\"status\\\":\\\"open\\\",\\\"priority\\\":2,\\\"issue_type\\\":\\\"task\\\",\\\"assignee\\\":null,\\\"owner\\\":null,\\\"created_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"created_by\\\":null,\\\"updated_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"closed_at\\\":null,\\\"close_reason\\\":null,\\\"due_at\\\":null,\\\"defer_until\\\":null,\\\"estimated_minutes\\\":null,\\\"external_ref\\\":null,\\\"source_system\\\":null,\\\"pinned\\\":false,\\\"is_template\\\":false,\\\"labels\\\":[],\\\"dependencies\\\":[],\\\"comments\\\":[]}\\n\";\n        try file.writeAll(valid1);\n\n        // Corrupt entry\n        try file.writeAll(\"{invalid json here}\\n\");\n\n        // Another valid issue\n        const valid2 = \"{\\\"id\\\":\\\"bd-valid2\\\",\\\"content_hash\\\":null,\\\"title\\\":\\\"Another Valid Issue\\\",\\\"description\\\":null,\\\"design\\\":null,\\\"acceptance_criteria\\\":null,\\\"notes\\\":null,\\\"status\\\":\\\"open\\\",\\\"priority\\\":2,\\\"issue_type\\\":\\\"task\\\",\\\"assignee\\\":null,\\\"owner\\\":null,\\\"created_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"created_by\\\":null,\\\"updated_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"closed_at\\\":null,\\\"close_reason\\\":null,\\\"due_at\\\":null,\\\"defer_until\\\":null,\\\"estimated_minutes\\\":null,\\\"external_ref\\\":null,\\\"source_system\\\":null,\\\"pinned\\\":false,\\\"is_template\\\":false,\\\"labels\\\":[],\\\"dependencies\\\":[],\\\"comments\\\":[]}\\n\";\n        try file.writeAll(valid2);\n    }\n\n    var store = IssueStore.init(allocator, test_path);\n    defer store.deinit();\n\n    var result = try store.loadFromFileWithRecovery();\n    defer result.deinit(allocator);\n\n    // Should have loaded 2 valid issues\n    try std.testing.expectEqual(@as(usize, 2), store.issues.items.len);\n\n    // Should have tracked 1 corrupt entry\n    try std.testing.expectEqual(@as(usize, 1), result.jsonl_corruption_count);\n    try std.testing.expect(result.hasCorruption());\n\n    // Verify the correct issues were loaded\n    try std.testing.expect(try store.exists(\"bd-valid1\"));\n    try std.testing.expect(try store.exists(\"bd-valid2\"));\n}\n","structuredPatch":[{"oldStart":449,"oldLines":11,"newStart":449,"newLines":6,"lines":["                 } else continue;","             }"," ","-            // Deferred filter: skip deferred issues unless explicitly included","-            if (!filters.include_deferred and statusEql(issue.status, .deferred)) {","-                continue;","-            }","-","             try results.append(self.allocator, try issue.clone(self.allocator));","         }"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013mF3iEiTr24BCD4Vosi1KM","type":"message","role":"assistant","content":[{"type":"text","text":"Now rebuild and test again."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":444,"cache_read_input_tokens":73436,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":444},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"94fe8242-b789-4318-91da-e573b62239fe"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013mF3iEiTr24BCD4Vosi1KM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F2T6qYKoPTzBCggyLKefpf","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig && zig build 2>&1","description":"Rebuild after fix"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":444,"cache_read_input_tokens":73436,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":444},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"3db21141-35ae-4724-824f-0509478a1dcf"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F2T6qYKoPTzBCggyLKefpf","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"a793ed7f-4402-4c3f-9e97-c4659639084d","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01W95sA7RorLyMvwYedjKqnh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F3NLTVztdKAESVotAUChud","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig/sandbox && echo \"=== List (default - excludes deferred) ===\" && ../zig-out/bin/bz list && echo \"\" && echo \"=== List with --deferred ===\" && ../zig-out/bin/bz list --deferred","description":"Test the --deferred filter after fix"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":126,"cache_read_input_tokens":73880,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":126},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"b7e7a9b5-1ac7-43e5-85f7-0ccc63730c8b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F3NLTVztdKAESVotAUChud","type":"tool_result","content":"=== List (default - excludes deferred) ===\nbd-uhc  [OPEN] Test overdue issue\nbd-3ks  [OPEN] No due date issue\n\n=== List with --deferred ===\nbd-uhc  [OPEN] Test overdue issue\nbd-r9g  [DEFR] Test future issue\nbd-3ks  [OPEN] No due date issue","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"45842031-21a2-4109-bcf2-c2466b448a37","tool_use_result":{"stdout":"=== List (default - excludes deferred) ===\nbd-uhc  [OPEN] Test overdue issue\nbd-3ks  [OPEN] No due date issue\n\n=== List with --deferred ===\nbd-uhc  [OPEN] Test overdue issue\nbd-r9g  [DEFR] Test future issue\nbd-3ks  [OPEN] No due date issue","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AahKh7krSAKk8zkeUVWETm","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me test the ready command with both --overdue and --include-deferred."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":256,"cache_read_input_tokens":74006,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":256},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"24a6ae9f-04fe-4ef2-a30a-bcfa6abbf5a4"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AahKh7krSAKk8zkeUVWETm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SzmnACnC3rBVqVdPoUnFXJ","name":"Bash","input":{"command":"echo \"=== Ready (default) ===\" && ../zig-out/bin/bz ready && echo \"\" && echo \"=== Ready --overdue ===\" && ../zig-out/bin/bz ready --overdue && echo \"\" && echo \"=== Ready --include-deferred ===\" && ../zig-out/bin/bz ready --include-deferred","description":"Test ready command with new filters"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":256,"cache_read_input_tokens":74006,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":256},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"453b3bc3-0ca1-405c-80b7-9a6c724c1df4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SzmnACnC3rBVqVdPoUnFXJ","type":"tool_result","content":"=== Ready (default) ===\nbd-uhc  [OPEN] Test overdue issue\nbd-3ks  [OPEN] No due date issue\n\n=== Ready --overdue ===\nbd-uhc  [OPEN] Test overdue issue\n\n=== Ready --include-deferred ===\nbd-uhc  [OPEN] Test overdue issue\nbd-r9g  [DEFR] Test future issue\nbd-3ks  [OPEN] No due date issue","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"e88e9d02-49ad-4882-9791-072bc709528c","tool_use_result":{"stdout":"=== Ready (default) ===\nbd-uhc  [OPEN] Test overdue issue\nbd-3ks  [OPEN] No due date issue\n\n=== Ready --overdue ===\nbd-uhc  [OPEN] Test overdue issue\n\n=== Ready --include-deferred ===\nbd-uhc  [OPEN] Test overdue issue\nbd-r9g  [DEFR] Test future issue\nbd-3ks  [OPEN] No due date issue","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MnxktWBXaGCPgaVWeDgird","type":"message","role":"assistant","content":[{"type":"text","text":"All the new filters work correctly. Let me run the full test suite to make sure everything still passes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":303,"cache_read_input_tokens":74262,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":303},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"df58b0b7-4283-41e2-8fab-0daf5e475c86"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MnxktWBXaGCPgaVWeDgird","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XeMk6gRPwebks1kMsyr83c","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig && zig build test 2>&1 | tail -20","description":"Run full test suite","timeout":300000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":303,"cache_read_input_tokens":74262,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":303},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"e5331ef7-798f-425e-816d-31fdcecf57b1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XeMk6gRPwebks1kMsyr83c","type":"tool_result","content":"650/661 tests.cli_test.test.bz dep add creates dependency...OK\n651/661 tests.cli_test.test.bz dep add rejects cycles...OK\n652/661 tests.cli_test.test.bz ready shows unblocked issues...OK\n653/661 tests.cli_test.test.bz blocked shows blocked issues...OK\n654/661 tests.cli_test.test.bz unknown command returns error...OK\n655/661 tests.cli_test.test.bz without workspace shows error...OK\n656/661 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n657/661 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n658/661 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 72 issues created\nOK\n659/661 tests.stress_test.test.sequential writes: single thread baseline...OK\n660/661 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n661/661 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 661 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"ee4a34c2-0e4b-4898-928e-2ea492a9ffaf","tool_use_result":{"stdout":"650/661 tests.cli_test.test.bz dep add creates dependency...OK\n651/661 tests.cli_test.test.bz dep add rejects cycles...OK\n652/661 tests.cli_test.test.bz ready shows unblocked issues...OK\n653/661 tests.cli_test.test.bz blocked shows blocked issues...OK\n654/661 tests.cli_test.test.bz unknown command returns error...OK\n655/661 tests.cli_test.test.bz without workspace shows error...OK\n656/661 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n657/661 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n658/661 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 72 issues created\nOK\n659/661 tests.stress_test.test.sequential writes: single thread baseline...OK\n660/661 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n661/661 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 661 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EsM5fpSo9z4ovBRoq6aga6","type":"message","role":"assistant","content":[{"type":"text","text":"All 661 tests pass. Let me update the todo list and create the commit."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":653,"cache_read_input_tokens":74565,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":653},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"8035211d-8ded-4fd8-bdf8-8dd763222b2a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EsM5fpSo9z4ovBRoq6aga6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WHeUF7Bm91jFZaWCK6BDUi","name":"TodoWrite","input":{"todos":[{"content":"Add --overdue filter for list and ready commands","status":"completed","activeForm":"Adding --overdue filter for list and ready commands"},{"content":"Add --deferred flag to include deferred issues in list","status":"completed","activeForm":"Adding --deferred flag to include deferred issues in list"},{"content":"Run tests and verify implementation","status":"completed","activeForm":"Running tests and verifying implementation"},{"content":"Commit all changes","status":"in_progress","activeForm":"Committing all changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":653,"cache_read_input_tokens":74565,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":653},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"5c7e5260-2471-4c97-9045-045e62f7173a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WHeUF7Bm91jFZaWCK6BDUi","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"8e12a125-a1d1-43df-873b-a5ed88d6c286","tool_use_result":{"oldTodos":[{"content":"Add --overdue filter for list and ready commands","status":"completed","activeForm":"Adding --overdue filter for list and ready commands"},{"content":"Add --deferred flag to include deferred issues in list","status":"completed","activeForm":"Adding --deferred flag to include deferred issues in list"},{"content":"Run tests and verify implementation","status":"in_progress","activeForm":"Running tests and verifying implementation"},{"content":"Commit all changes","status":"pending","activeForm":"Committing all changes"}],"newTodos":[{"content":"Add --overdue filter for list and ready commands","status":"completed","activeForm":"Adding --overdue filter for list and ready commands"},{"content":"Add --deferred flag to include deferred issues in list","status":"completed","activeForm":"Adding --deferred flag to include deferred issues in list"},{"content":"Run tests and verify implementation","status":"completed","activeForm":"Running tests and verifying implementation"},{"content":"Commit all changes","status":"in_progress","activeForm":"Committing all changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01YAN68GK31crUEVFRc12npg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016dAKBsLBy2dJzLZpj3sEqV","name":"Bash","input":{"command":"git status","description":"Check git status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":251,"cache_read_input_tokens":75218,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":251},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"b59e57b6-63d8-4aba-9cbd-6046aebda1a1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016dAKBsLBy2dJzLZpj3sEqV","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 13 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/list.zig\n\tmodified:   src/cli/ready.zig\n\tmodified:   src/storage/dependencies.zig\n\tmodified:   src/storage/graph.zig\n\tmodified:   src/storage/store.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"e5d55e5f-0413-4847-b94b-f61143aa164e","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 13 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/list.zig\n\tmodified:   src/cli/ready.zig\n\tmodified:   src/storage/dependencies.zig\n\tmodified:   src/storage/graph.zig\n\tmodified:   src/storage/store.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01YAN68GK31crUEVFRc12npg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MeFoxTAY6LFbbC7x8VMdjw","name":"Bash","input":{"command":"git diff --stat","description":"Show changed files stats"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":251,"cache_read_input_tokens":75218,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":251},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"dfa03ead-daaf-427c-a814-dabcdbd9c261"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MeFoxTAY6LFbbC7x8VMdjw","type":"tool_result","content":" .beads/issues.jsonl          |  4 ++--\n .hot_ralph/state.json        |  6 +++---\n src/cli/args.zig             | 12 ++++++++++++\n src/cli/list.zig             |  6 ++++++\n src/cli/ready.zig            | 19 ++++++++++++++-----\n src/storage/dependencies.zig |  4 ++--\n src/storage/graph.zig        | 24 +++++++++++++++---------\n src/storage/store.zig        | 19 ++++++++++++++++++-\n 8 files changed, 72 insertions(+), 22 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"4a1cb33f-4a4f-4e27-9af9-b3e8507b8c33","tool_use_result":{"stdout":" .beads/issues.jsonl          |  4 ++--\n .hot_ralph/state.json        |  6 +++---\n src/cli/args.zig             | 12 ++++++++++++\n src/cli/list.zig             |  6 ++++++\n src/cli/ready.zig            | 19 ++++++++++++++-----\n src/storage/dependencies.zig |  4 ++--\n src/storage/graph.zig        | 24 +++++++++++++++---------\n src/storage/store.zig        | 19 ++++++++++++++++++-\n 8 files changed, 72 insertions(+), 22 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DapdiEMqGAscogfjfQQYyK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KR6o39co5yw1m2qCYE46JK","name":"Bash","input":{"command":"git log --oneline -3","description":"Show recent commits"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":578,"cache_read_input_tokens":75469,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":578},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"a48d6b6b-ef0f-41c4-b990-ed0b478dd587"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KR6o39co5yw1m2qCYE46JK","type":"tool_result","content":"3cb244d Plan mode: complete 2 tasks\nfec47b6 refactor: deduplicate containsIgnoreCase function\nf723d84 feat(cli): add priority range and substring filters","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"7a4b70bc-9f99-4590-8d8f-7727cdec92d9","tool_use_result":{"stdout":"3cb244d Plan mode: complete 2 tasks\nfec47b6 refactor: deduplicate containsIgnoreCase function\nf723d84 feat(cli): add priority range and substring filters","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SkL34TyCtigMieUoijgkqq","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll add the specific source files and commit."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":136,"cache_read_input_tokens":76047,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":136},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"7caa2021-75b5-4551-9818-0d6c23c34de9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SkL34TyCtigMieUoijgkqq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GFcmk6GrLrjxjKmT88Y61m","name":"Bash","input":{"command":"git add src/cli/args.zig src/cli/list.zig src/cli/ready.zig src/storage/dependencies.zig src/storage/graph.zig src/storage/store.zig && git status","description":"Stage changed source files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":136,"cache_read_input_tokens":76047,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":136},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"8cc8e146-1fc7-4812-9b5b-f938a9abacf4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GFcmk6GrLrjxjKmT88Y61m","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 13 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/list.zig\n\tmodified:   src/cli/ready.zig\n\tmodified:   src/storage/dependencies.zig\n\tmodified:   src/storage/graph.zig\n\tmodified:   src/storage/store.zig\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"f5c2b054-3d20-463b-a0cc-3d851452046a","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 13 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/list.zig\n\tmodified:   src/cli/ready.zig\n\tmodified:   src/storage/dependencies.zig\n\tmodified:   src/storage/graph.zig\n\tmodified:   src/storage/store.zig\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011prbfr9KaHbtW8NsX3FoDZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015bUAQEmzavxHKe7v1izfKD","name":"Bash","input":{"command":"git commit -m \"$(cat <<'EOF'\nfeat(cli): add --overdue and --deferred filters for list and ready\n\nAdd filtering capabilities for due dates and deferred issues:\n\n- `bz list --overdue` - Filter for issues past their due date\n- `bz ready --overdue` - Ready issues that are also overdue\n- `bz list --deferred` / `bz list --include-deferred` - Include deferred issues in results\n- `bz ready --include-deferred` - Include deferred issues in ready list\n\nThe list command now excludes deferred issues by default (matching previous ready behavior).\n\nImplements bd-1px (--overdue filter) and bd-3hb (--deferred flag).\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Commit the changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":364,"cache_read_input_tokens":76183,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":364},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"2e56ad6e-f718-4785-9ca1-b72f793c4c95"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015bUAQEmzavxHKe7v1izfKD","type":"tool_result","content":"[dev-hotschmoe 9016d44] feat(cli): add --overdue and --deferred filters for list and ready\n 6 files changed, 67 insertions(+), 17 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"501ccd42-9204-4387-9829-7a19fb510698","tool_use_result":{"stdout":"[dev-hotschmoe 9016d44] feat(cli): add --overdue and --deferred filters for list and ready\n 6 files changed, 67 insertions(+), 17 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017d6LosNMFJsusxt7Mcrqj4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XGn8DoKfw7efrx2bB2mMfx","name":"TodoWrite","input":{"todos":[{"content":"Add --overdue filter for list and ready commands","status":"completed","activeForm":"Adding --overdue filter for list and ready commands"},{"content":"Add --deferred flag to include deferred issues in list","status":"completed","activeForm":"Adding --deferred flag to include deferred issues in list"},{"content":"Run tests and verify implementation","status":"completed","activeForm":"Running tests and verifying implementation"},{"content":"Commit all changes","status":"completed","activeForm":"Committing all changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":331,"cache_read_input_tokens":76547,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":331},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"37416b80-6a80-477b-9226-9613fdcfff64"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XGn8DoKfw7efrx2bB2mMfx","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"87503698-255f-432c-a3e1-62acfa6aaf10","tool_use_result":{"oldTodos":[{"content":"Add --overdue filter for list and ready commands","status":"completed","activeForm":"Adding --overdue filter for list and ready commands"},{"content":"Add --deferred flag to include deferred issues in list","status":"completed","activeForm":"Adding --deferred flag to include deferred issues in list"},{"content":"Run tests and verify implementation","status":"completed","activeForm":"Running tests and verifying implementation"},{"content":"Commit all changes","status":"in_progress","activeForm":"Committing all changes"}],"newTodos":[{"content":"Add --overdue filter for list and ready commands","status":"completed","activeForm":"Adding --overdue filter for list and ready commands"},{"content":"Add --deferred flag to include deferred issues in list","status":"completed","activeForm":"Adding --deferred flag to include deferred issues in list"},{"content":"Run tests and verify implementation","status":"completed","activeForm":"Running tests and verifying implementation"},{"content":"Commit all changes","status":"completed","activeForm":"Committing all changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EYKeF4L1R4brgNz31kgfzv","type":"message","role":"assistant","content":[{"type":"text","text":"## Summary\n\nBoth tasks have been completed successfully:\n\n### Task 1: Add --overdue filter (bd-1px) - SUCCESS\n\nAdded `--overdue` flag to both `list` and `ready` commands:\n- `bz list --overdue` - Filters to show only issues past their due date\n- `bz ready --overdue` - Shows ready issues that are also overdue\n\n**Implementation:**\n- Added `overdue: bool` field to `ListArgs` and `ReadyArgs` in `src/cli/args.zig`\n- Added parsing for `--overdue` flag in argument parser\n- Added `overdue: bool` to `ListFilters` in `src/storage/store.zig`\n- Filtering compares `due_at` timestamp against current time (`std.time.timestamp()`)\n\n### Task 2: Add --deferred flag (bd-3hb) - SUCCESS\n\nAdded flags to include deferred issues in results:\n- `bz list --deferred` or `bz list --include-deferred` - Includes deferred issues in list\n- `bz ready --include-deferred` - Includes deferred issues in ready list\n\n**Implementation:**\n- Added `include_deferred: bool` field to `ListArgs` and `ReadyArgs`\n- Updated `getReadyIssues()` in `src/storage/graph.zig` to accept `include_deferred` parameter\n- Modified status filtering in `store.list()` to allow deferred issues through when flag is set\n\n### Files Modified:\n- `src/cli/args.zig` - Added new argument fields and parsing\n- `src/cli/list.zig` - Pass filters to store\n- `src/cli/ready.zig` - Updated filter function signature and calls\n- `src/storage/store.zig` - Added filter fields and filtering logic\n- `src/storage/graph.zig` - Updated `getReadyIssues()` signature\n- `src/storage/dependencies.zig` - Updated test calls\n\nAll 661 tests pass. Changes committed in `9016d44`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":230,"cache_read_input_tokens":76878,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":230},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","uuid":"d922001b-35e4-4abe-b5e0-bc322325cd00"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":314676,"duration_api_ms":343431,"num_turns":47,"result":"## Summary\n\nBoth tasks have been completed successfully:\n\n### Task 1: Add --overdue filter (bd-1px) - SUCCESS\n\nAdded `--overdue` flag to both `list` and `ready` commands:\n- `bz list --overdue` - Filters to show only issues past their due date\n- `bz ready --overdue` - Shows ready issues that are also overdue\n\n**Implementation:**\n- Added `overdue: bool` field to `ListArgs` and `ReadyArgs` in `src/cli/args.zig`\n- Added parsing for `--overdue` flag in argument parser\n- Added `overdue: bool` to `ListFilters` in `src/storage/store.zig`\n- Filtering compares `due_at` timestamp against current time (`std.time.timestamp()`)\n\n### Task 2: Add --deferred flag (bd-3hb) - SUCCESS\n\nAdded flags to include deferred issues in results:\n- `bz list --deferred` or `bz list --include-deferred` - Includes deferred issues in list\n- `bz ready --include-deferred` - Includes deferred issues in ready list\n\n**Implementation:**\n- Added `include_deferred: bool` field to `ListArgs` and `ReadyArgs`\n- Updated `getReadyIssues()` in `src/storage/graph.zig` to accept `include_deferred` parameter\n- Modified status filtering in `store.list()` to allow deferred issues through when flag is set\n\n### Files Modified:\n- `src/cli/args.zig` - Added new argument fields and parsing\n- `src/cli/list.zig` - Pass filters to store\n- `src/cli/ready.zig` - Updated filter function signature and calls\n- `src/storage/store.zig` - Added filter fields and filtering logic\n- `src/storage/graph.zig` - Updated `getReadyIssues()` signature\n- `src/storage/dependencies.zig` - Updated test calls\n\nAll 661 tests pass. Changes committed in `9016d44`.","session_id":"6d7d07fd-58aa-4800-9a5b-9084875620f3","total_cost_usd":2.08885515,"usage":{"input_tokens":2,"cache_creation_input_tokens":59132,"cache_read_input_tokens":2483778,"output_tokens":11656,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":59132,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":2,"outputTokens":11656,"cacheReadInputTokens":2483778,"cacheCreationInputTokens":59132,"webSearchRequests":0,"costUSD":1.9028739999999997,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":47367,"outputTokens":7604,"cacheReadInputTokens":507354,"cacheCreationInputTokens":39887,"webSearchRequests":0,"costUSD":0.18598115,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"c5430739-2b95-40c2-b52c-d8a48400672c"}
